#+title: MS thesis research notebook
#+author: Devon Walker
#+email: devonw@andrew.cmu.edu
#+TODO: TODO(t) INPROGRESS(w) | DONE(d) CANCELED(c)
#+STARTUP: hideblocks

* Journal
** May
*** 2016-05-19 Thu
 - cite:zan-2012-graph-reknit ues:
 1. Repairing graphene
 2. Stacked-graphene aperture effect
   2.1. Neural network?
*** 2016-05-20 Fri
 - cite:drahushuk-2012-mechan-gas Mechanisms of Gas Permeation through Single Layer Graphene Membranes - Drahushuk, Strano*

*** 2016-05-23 Mon
 - cite:du-2011-separ-hydrog Separation of Hydrogen and Nitrogen Gases With  Porous Graphene Membrane - Du, Zhao*

*** 2016-05-24 Tue
 - cite:koenig-2012-selec-molec Selective Molecular Sieving Through Porous Graphene - Keonig, Bunch*

*** 2016-05-25 Wed
 - cite:liu-2013-permean-h2 

 Simulators meeting
 - Jake presented neural network vs reaxff with Au

*** 2016-05-26 Thu
 - cite:jiang-2009-porous-graph

*** 2016-05-27 Fri
 - cite:sun-2014-mechan-molec

 Prepared for a group meeting presentation. Ended up not having one.

**** 2016-05-27 3pm Presentation Prep
     DEADLINE: <2016-05-27 Fri 3pm>
  (Meeting cancelled)

***** Concept of gas phase transport

  #+BEGIN_SRC python
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
import sys

heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]

def movie(constraint):
    images = []
    for i, h in enumerate(heights):
        with jasp('./dft/transport/g-mono/3x3/pore=1/molec=CO2/' + constraint + '/d={0:0.2f}'.format(h)) as calc:
            atoms = calc.get_atoms()
            images.append(atoms)
    view(images)

free = 'linear-unconst_all'
unconst_G = 'linear-unconst_G'
const_all = 'linear-const'

#movie(free)
#movie(unconst_G)
movie(const_all)
  #+END_SRC

  #+RESULTS:

***** Bond length of molecules change as they transport

  [[./img/final-project/G-bond-length.png]]

***** Total energy difference between H2 and CO2

  [[./img/final-project/total_energy-comparison.png]]

***** How constraints effect total energy

  Hydrogen transport through monolayer graphene. Pore=1
  [[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison.png]]

***** Non-interaction distance convergence
  [[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison-LJ_zoom.png]]

  How does this well distance change with other molecules?
  - Running comparisons with CO2 and N2.

***** Pore distance convergence
  What pore interaction distance is acceptable?

  [[./img/material/g-mono/4x4/pore=10/vac=16.png]]

  [[./img/material/g-mono/5x5/pore=10/vac=16.png]]

  [[./img/material/g-mono/6x6/pore=10/vac=16.png]]

***** Questions
  - How well is DFT handling multiple species?
  - - Smearing: sigma is not dependent on per molecule basis

  - Pressure can change diffusion pathways (gas phase vs adsorption)
  - - cite:du-2011-separ-hydrog
  - - cite:drahushuk-2012-mechan-gas

*** 2016-05-31 Tue
 - cite:drahushuk-2016-analy-time Analysis of Time-Varying, Stochastic Gas Transport Through Graphene Membranes - Drahushuk, Keonig, Bunch*, Strano*

 Created vaccuum distance graph to deteremine interaction distance of leading atoms in a molecule.

 Bilayer graphene unit cell in queue for relaxation.

 Need to redo some of the 'free' transport. The graphene plane simply shifted down as the molecules approached. Might help to fix carbons around the outside edge.

**** DONE Check in on monolayer 5x5 and 6x6 pore=10 calculations
     CLOSED: [2016-06-01 Wed 12:26]
** June
*** 2016-06-01 Wed
 - cite:shan-2012-influen-chemic
 - cite:schrier-2012-carbon-dioxid

 - cite:wang-2015-molec-valves Molecular valves for controlling gas phase transport made from discrete ångström-sized pores in graphene - Wang, Drahushuk, Strano*
   
 - cite:partoens-2007-from-graph


 Possible research idea: Look into pore stability of different passivating molecules, including what it takes to remove a passivated species (ie. if N is a more stable passivating species than H, what is the energy barrier for replacing H with N?).

**** DONE Finish structure of pore=10 for bilayer
     CLOSED: [2016-06-01 Wed 12:26]

*** 2016-06-02 Thu
**** DONE Finish pore=10 for bilayer
     CLOSED: [2016-06-01 Wed 12:26]

*** 2016-06-03 Fri
*** 2016-06-06 Mon
*** 2016-06-07 Tue
*** 2016-06-08 Wed
*** 2016-06-09 Thu
 Prepared for group meeting research update tomorrow.
*** 2016-06-10 Fri
 Group meeting.

*** 2016-06-13 Mon
*** 2016-06-14 Tue
*** 2016-06-15 Wed
*** 2016-06-16 Thu
 To build:
 - pick edge atoms
 - pick center atom
 - tie into ase database to see if structure has been run
 - top layer pore candidates

 Would the atoms removed necessarily need to be next to eachother?

 Paper motivation:
 http://pubs.acs.org/doi/abs/10.1021/acsnano.5b01762

 Paper to compare my results to (maybe):
 http://pubs.acs.org/doi/abs/10.1021/acsnano.5b01762

**** Choosing unique solutions for graphene pores

 #+BEGIN_SRC python
from ase import Atoms, Atom
from jasp import *
import numpy as np

import twodee as td


with jasp('dft/material/g-mono/final') as calc:
    atoms = calc.get_atoms()
atoms.center()
atoms = atoms.repeat((3,3,1))

def is_the_same(x, fun, *args):
    """True if the object is unchanged during the function call."""
    import copy
    y = copy.deepcopy(x)
    fun(*args)
    return x == y

def closest_atom(atoms, position, exclude=None):
    """Return the index of the atom closest to a position."""
    choices = [a.index for a in atoms]

    if exclude is not None:
        choices = [i for i in choices if i not in exclude]

    closest = None
    min_dist = None
    for i in choices:
        dist = np.linalg.norm(atoms[i].position - position)
        if np.absolute(dist) < min_dist or closest is None:
            min_dist = dist
            closest = i

    return closest

def center(atoms):
    """Return the position (x,y,z) of the center of the cell."""
    cell = np.array(atoms.get_cell())
    center = (cell[0] + cell[1]) / 2
    center += cell[2] / 2
    return center

def center_layer(atoms):
    """Return the position (x,y,z) of the center of a layer of atoms."""
    cell = np.array(atoms.get_cell())
    center = (cell[0] + cell[1]) / 2
    center += [0, 0, np.mean([a.position[2] for a in atoms])]
    return center


pore = [9]
#pore = [3, 8, 9, 14]
#pore = [6, 7, 8, 9, 12, 13, 14, 15]
td.paint_atoms(atoms, pore)
td.bp(atoms)
 #+END_SRC

 #+RESULTS:


 #+BEGIN_SRC python
import numpy as np

a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

print(a, a1*3, a2*3, a3*3)
 #+END_SRC

 #+RESULTS:
 : (2.46, array([ 6.39126748, -3.69      ,  0.        ]), array([ 6.39126748,  3.69      ,  0.        ]), array([  0.,   0.,  30.]))

**** New vasp vs jasp error

 Temporary simple-co with new vasp:
 #+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp
import numpy as np
np.set_printoptions(precision=3, suppress=True)

co = Atoms([Atom('C', [0, 0, 0]),
            Atom('O', [1.2, 0, 0])],
           cell=(6., 6., 6.))

calc = Vasp('~/tmp/molecules/simple-co',  # output dir
            xc='PBE',  # the exchange-correlation functional
            nbands=6,    # number of bands
            encut=350,    # planewave cutoff
            ismear=1,    # Methfessel-Paxton smearing
            sigma=0.01,  # very small smearing factor for a molecule
            atoms=co)
print('energy = {0} eV'.format(co.get_potential_energy()))
print(co.get_forces())
 #+END_SRC

 #+RESULTS:
 : energy = -14.69111507 eV
 : [[ 5.091  0.     0.   ]
 :  [-5.091  0.     0.   ]]

 This works:
 #+BEGIN_SRC python
from ase import Atoms, Atom
from jasp import *

with jasp('~/dft-book/molecules/simple-co') as calc:
    atoms = calc.get_atoms()
 #+END_SRC

 #+RESULTS:

 This doesn't:
 #+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

print(Vasp.default_parameters) # this works.

calc = Vasp('~/dft-book/molecules/simple-co')
atoms = calc.get_atoms()
 #+END_SRC

 #+RESULTS:

 Trace:
 #+BEGIN_SRC screen
Traceback (most recent call last):
  File "<stdin>", line 6, in <module>
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 45, in inner
    return func(self, *args, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp_core.py", line 242, in __init__
    str(label), atoms)
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 51, in inner
    return self.exception_handler(self, *sys.exc_info())
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 48, in inner
    return func(self, *args, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/ase-s16/ase/calculators/calculator.py", line 513, in __init__
    atoms, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 51, in inner
    return self.exception_handler(self, *sys.exc_info())
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 48, in inner
    return func(self, *args, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/ase-s16/ase/calculators/calculator.py", line 184, in __init__
    self.read(restart)  # read parameters, atoms and results
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 51, in inner
    return self.exception_handler(self, *sys.exc_info())
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 48, in inner
    return func(self, *args, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/readers.py", line 322, in read
    atoms = self.read_atoms()
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 51, in inner
    return self.exception_handler(self, *sys.exc_info())
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 48, in inner
    return func(self, *args, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/readers.py", line 249, in read_atoms
    atoms.positions = xatoms.positions[resort]
AttributeError: 'NoneType' object has no attribute 'positions'
 #+END_SRC

**** Monolayer graphene pore selector

 *What is it?*
 A script that takes a pristine monolayer of graphene and generates Atoms objects for all unique pores, up to the edge atoms.

 It should start with the most central carbon and systematically expand from that point, removing more and more adjacent carbons.

 /Input/
 Size of the ixi repeated monolayer graphene.

 /Output/
 A list of Atoms objects with all the possibile pore configurations. (Might have scalability issues here.)

 *Function list*
 - 


 *Next step*

*** 2016-06-21 Tue
*** 2016-06-22 Wed

 Job scraper test string:
 /home-guest/devonw/hydrogen2D/vasp/base/mat=graphene/layers=2 Queued: 1412411.gilgamesh.cheme.cmu.edu

**** Jasp Vasp comparison
***** New Vasp() view atoms bug
      CLOSED: [2016-06-22 Wed 11:39]

  #+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from vasp import Vasp
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '10:00:00'

from ase.visualize import view
import twodee as td


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3.5 * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

name = 'tmp/vasp/base/mat=graphene/layers=1'
calc = Vasp(name,
            xc='PBE',          # GGA functional type
            encut=520,
            kpts=[11,11,1],
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms)


print(atoms.get_potential_energy())
print(atoms.get_forces())
td.bp(atoms)
td.bp()

print(atoms.get_potential_energy())
#calc.view()
atoms2 = calc.get_atoms()

atoms2.set_calculator()
#view(atoms2)
print(atoms2)
#td.print_image(name, atoms)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  -18.44792199
  [[ 0.077 -0.017  0.   ]
   [-0.077  0.017  0.   ]]
  :END:

***** New Vasp() view atoms bug - in Jasp
      CLOSED: [2016-06-22 Wed 11:39]

  #+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'

from ase.visualize import view
import twodee as td


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3.5 * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

#td.bp(atoms)
name = 'tmp/jasp/base/mat=graphene/layers=1'
with jasp(name,
            xc='PBE',          # GGA functional type
            encut=520,
            kpts=(11,11,1),
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms) as calc:
    print(atoms.get_potential_energy())
    print(atoms.get_forces())
#    td.bp(calc.get_atoms())


#calc.view()

#atoms2.set_calculator()
#view(atoms2)
#print(atoms2)
#td.print_image(name, atoms)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  -18.44792199
  [[ 0.077 -0.017  0.   ]
   [-0.077  0.017  0.   ]]
  :END:

*** 2016-06-23 Thu

** July
** August
*** 2016-08-04 Thu
Do I need to apply Monte Carlo to the selection of my training data?

*** 2016-08-05 Fri
- [ ] Paper - cite:behler-2011-neural-networ 
  - 

*** 2016-08-08 Mon
- [X] Start more DFT relaxation calculations
  - Do not do relaxations on degenerate structures
- [ ] Train 8-8, 8-8-8, 16-16, 16-16-16 networks
  - Maybe just pick 2?
- [X] Create script to look at DB and add dbkey=0 to non-degenerate keys.
- [ ] Paper - cite:behler-2014-repres-poten
  - ref 17: Guidlines for the 'perfect potential'
  - [ ] ref 25: What is the tight binding method?
  - atomistic potentials
    - physical (empirical) potential :: derived from experimental data
    - mathematical (ab initio) potential :: derived from simulation data

Read this too: Constructing high-dimensional neural network potentials: A tutorial review - Behler - 2015

*** 2016-08-10 Wed
- [X] Merge estimate_4.db into master
- [X] DFT point calculations for size=4 uniques
- [X] DFT relaxation calculations for size=4 on uniques
- [X] Get LAMMPS running a calc

Test merge
#+BEGIN_SRC python :results output org drawer
from ase.db import connect
import shutil
import twodee as td

master = 'database/master.db'
temp_master = 'tmp/test_master.db'
shutil.copyfile(master, temp_master)

estimate = 'database/estimate_4.db'
temp_estimate = 'tmp/test_estimate.db'
shutil.copyfile(estimate, temp_estimate)

db_master = connect(temp_master)
db_estimate = connect(temp_estimate)

num_calcs = sum([1 for d in db_master.select()])
print("Master: {}".format(num_calcs))

n = 0
for de in db_estimate.select():
    atoms = db_estimate.get_atoms(de.id)
    keys = de.key_value_pairs
    db_master.write(atoms, **keys)
    n += 1
    if n == 100:
        break

num_calcs = sum([1 for d in db_master.select()])
print("Master: {}".format(num_calcs))
#+END_SRC

#+RESULTS:
:RESULTS:
Master: 745
Master: 845
:END:

*** 2016-08-11 Thu
- [X] Pull relaxation trajectory steps into database
- [X] Change amp code to development version
  - Use Gaussian instead of Behler for descriptor
- [X] Train 8-8, 8-8-8, 16-16, 16-16-16 networks
  - Maybe just pick 2?

*** 2016-08-12 Fri
- [X] Turn results into cohesive presentation
- [X] Lecture at 1pm
- [X] Group meeting presentation

*** 2016-08-17 Wed
- [-] Check cutoff distance for gaussian descriptor
  - [X] LJ in progress
  - [ ] Perturbation test
    - Waiting for size=4 pristine calculation to finish.
    - Compare to a calculated pore structure. 1, 2, & 3 carbon defects.
  - [ ] Analyzed
- [X] Start neural networks without force convergence
- [ ] Create validation/extrapolation template
- [ ] Get Amp training locally
  - Possibly better performance since ssh parallel should work

Future:
- [ ] Get LAMMPS running comparison calcs
- [ ] Add hash to keys (maybe just for uniques)

* Lexicon
- degenerate :: Identical structures, though possible viewed in a different way. Like 
- interstitial defects :: Locations in a crystal lattice not typically occupied. Self-interstitial (same atom-type as lattice) and interstial impurities (different type of atom).
- neural network potential (NNP) :: A potential that consists of using a neural network.
* Meetings
** 2016-03-08 4pm
   CLOSED: [2016-03-09 Wed 09:26] DEADLINE: <2016-03-08 Tue 16:00>
*** Questions
quantum mechanics:
- can we adsorb molecules to the surface which impart favorable changes to the electron density around diffusion sites?

neural network:
- can we use a neural network to address properties that dft doesn't model well, such as charging the material with a potential?

org-ref:
- can you later attach a pdf?
- duplicate current bibliography into default bibliography?
- do you highlight pdfs or just type into the notes file?

*** Actions
1. Table outlining separation data

** 2016-04-15 11am
   CLOSED: [2016-05-11 Wed 16:02] DEADLINE: <2016-04-15 Fri 11:00>
*** Final project suggestion
- develop a suggestion related to research
- look into what jasp is lacking

*** Neural networks
Behler-Parrinello paper from 2007
- inputs are atom positions
- questions
  - how is it not overfit with an 8200 optimizing set and 800 test set?
  - is there a way to use different inputs or generalize them? (ie. an input could be the position or presence of a functional group)

** 2016-05-12 11am
*** Final project feedback
[[file:~/techela/s16-06640/final-project/final-project.org::*Transport of carbon dioxide]]

*** Correct constraints for a molecule

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.constraints import FixAtoms, Hookean
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
import sys

JASPRC['queue.walltime'] = '10:00:00'

def print_converged(i, energy, time):
#    print(i, energy, time)
    print("CO2 Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("CO2 Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("CO2 Distance: {:5.2f}. Did not converge.".format(i))


# Height of the fixed atom
heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]


# Build base images
with jasp('graphene/G-c-final') as calc:
    G_defect = calc.get_atoms()
def_pos = np.array([5.681, 0., 5.]) # defect position

# http://en.wikipedia.org/wiki/Carbon_dioxide_(data_page)
CO_bond = 1.16 # Ang. C=O bond length in CO2

atoms =  [Atoms(G_defect) for i in range(len(heights))]
for i, h in enumerate(heights):
    CO2 = Atoms([Atom('O', def_pos + (0., 0., h - CO_bond)),
                 Atom('C', def_pos + (0., 0., h)),
                 Atom('O', def_pos + (0., 0., h + CO_bond))])

    atoms[i].extend(CO2)

# Constraint - fix all carbons (including the CO2 carbon)
carbon_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Hookean constraint
# Values for constants rt [Ang] and k [eV/Ang^-2] are from https://wiki.fysik.dtu.dk/ase/ase/constraints.html for a C=O bond
for atom in atoms[0]:
    if atom.symbol == 'O':
        hook_constraint = [Hookean(a1=atom.index, a2=atom.index+1, rt=1.58, k=10.),
                           Hookean(a1=atom.index+1, a2=atom.index+2, rt=1.58, k=10.)]
        break

ready = True

# Constrained graphene, constrained carbon in CO2
print('Unconstrained graphene, constrained carbon in CO2:')

atoms_yy = [Atoms(atoms[i]) for i in range(len(heights))]
#for i in range(len(heights)):
#    atoms_yy[i].set_constraint(carbon_constraint)





with jasp('transport/G-c-CO2-transport-no-yes-d=1.00a'.format(h),
                encut=450,         # From convergence check
                kpts=(6,6,1),      # From convergence check
                xc='PBE',          # GGA functional type. Important for the defect.
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms_yy[i]) as calc:
        try:
            calc.calculate()
            energy = atoms_yy[i].get_potential_energy()
            print_converged(h, energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            print_inprogress(h)
            ready = False
            pass
sys.exit()





TE_yy = []
BO_yy = [[], []]
for i, h in enumerate(heights):
    with jasp('transport/G-c-CO2-transport-no-yes-d={0:0.2f}'.format(h),
                encut=450,         # From convergence check
                kpts=(6,6,1),      # From convergence check
                xc='PBE',          # GGA functional type. Important for the defect.
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms_yy[i]) as calc:
        try:
            calc.calculate()
            energy = atoms_yy[i].get_potential_energy()
            TE_yy.append(energy)
            BO_yy[0].append(atoms_yy[i].get_distance(17,18))
            BO_yy[1].append(atoms_yy[i].get_distance(18,19))
            print_converged(h, energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            print_inprogress(h)
            ready = False
            pass


# Constrained graphene, constrained carbon in CO2 + Hookean oxygen
print('')
print('Unconstrained graphene, constrained carbon + Hookean oxygen:')

atoms_yh = [Atoms(atoms[i]) for i in range(len(heights))]
#for i in range(len(heights)):
#    atoms_yh[i].set_constraint(carbon_constraint + hook_constraint)

TE_yh = []
BO_yh = [[], []]
for i, h in enumerate(heights):
    with jasp('transport/G-c-CO2-transport-no-hook-d={0:0.2f}'.format(h),
                encut=450,         # From convergence check
                kpts=(6,6,1),      # From convergence check
                xc='PBE',          # GGA functional type. Important for the defect.
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms_yh[i]) as calc:
        try:
            calc.calculate()
            energy = atoms_yh[i].get_potential_energy()
            TE_yh.append(energy)
            BO_yh[0].append(atoms_yh[i].get_distance(17,18))
            BO_yh[1].append(atoms_yh[i].get_distance(18,19))
            print_converged(h, energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            print_inprogress(h)
            ready = False
            pass

if not ready:
    import sys; sys.exit()

import matplotlib.pyplot as plt

# Consider the change in energy from lowest energy state
TE_yy = np.array(TE_yy)
TE_yh = np.array(TE_yh)
TE_yy -= min(TE_yy)
TE_yh -= min(TE_yh)

print('')
print('Comparison of constraint techniques:')
file_path = './img/G-c-C-linear.png'
plt.figure(0)
plt.plot(heights, TE_yy, label='O uconstrained')
plt.plot(heights, TE_yh, label='Hookean constraint')
plt.xlabel('Height (Ang)')
plt.ylabel('$\Delta$ Energy (eV)')
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#view(atoms_yy)
#view(atoms_yh)
#+END_SRC

#+RESULTS:
: Unconstrained graphene, constrained carbon in CO2:
: CO2 Distance: -3.00. In progress.

*** Bilayer / Trilayer graphene
**** Bilayer

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys

def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

layer_dist = 3.32
b1 = a1
b2 = a * np.array([1./2., 3.0**0.5/2., 0.])
b3 = a3 - 2 * np.array([0., 0., layer_dist])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3),
                  Atom('C', 1./2. * b3),
                  Atom('C', 1./3. * b1 + 1./3. * b2 + 1./2. * b3)],
                  cell=[a1, a2, a3])


atoms = unitcell
#atoms = unitcell.repeat((3,3,1))
view(atoms)
sys.exit()

defect_pos = atoms[9].position
del atoms[9]

ready = True
with jasp('graphene/G-c-final',
            encut=450,         # From convergence check
            kpts=(6,6,1),      # From convergence check
            xc='PBE',          # GGA functional type. Important for the defect.
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

if not ready:
    sys.exit()

print('')
print('Defect position: {}'.format(defect_pos))

print('')
file_path = './img/bilayer.png'
#file_path = './img/G-c-final-repeat-present.png'
#atoms = atoms.repeat((3,3,1))
#atoms.rotate('x', -np.pi/4)
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
view(atoms)
#+END_SRC

#+RESULTS:
** 2016-06-10 3pm Group meeting
   CLOSED: [2016-06-15 Wed 09:44] DEADLINE: <2016-06-10 Fri 3pm>

** 2016-06-24 3pm Group meeting
   CLOSED: [2016-07-06 Wed 13:22]
** 2016-07-06 3pm Group meeting
   CLOSED: [2016-07-18 Mon 16:40]
** 2016-07-15 3pm Group meeting
   CLOSED: [2016-07-18 Mon 16:40]
** 2016-08-12 3pm Group meeting
*** Scimax issues

* Presentations
** DONE 2016-06-10 Group meeting
   CLOSED: [2016-06-15 Wed 09:44] DEADLINE: <2016-06-10 Fri 3pm>

*** Presentation
**** 06-640 Final project
***** Concept movie

 #+BEGIN_SRC python
from jasp import *
from ase.visualize import view

fp_dir = '~/techela/s16-06640/final-project/' # Directory of final project.

heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]

images_h2 = []
images_co2 = []

for h in heights:

    with jasp(fp_dir + 'transport/G-c-HHc-constraints-yes-hook-d={0:0.2f}'.format(h)) as calc:
        images_h2.append(calc.get_atoms())

    with jasp(fp_dir + 'transport/G-c-CO2-transport-yes-hook-d={0:0.2f}'.format(h)) as calc:
        images_co2.append(calc.get_atoms())

view(images_co2)
#view(images_h2) 
 #+END_SRC

 #+RESULTS:

 Limitations:
 - Graphene layer consisted of a 3x3 repeated monolayer in the x and y directions. Not large enough to say pores do not have an effect on one another.
 - Carbon atoms in graphene plane are fixed
 - One atom in each molecule is chosen to be fixed, with other atoms constrained with a Hookean constraint
   - Preserved molecule structure
   - Introduced new error (empirical correction)
     - If the atoms within a molecule got beyond a certain distance, an artificial energy penalty would be imposed to persuade the geometry relaxation to maintain the integrity of the molecule's structure.

***** Bond length change
 [[./img/final-project/G-bond-length.png]]

***** Barrier energy

 [[./img/final-project/total_energy-comparison.png]]


 Energy barriers:
     H2:  1.879 eV
     CO2: 4.643 eV

 Significantly large energy barrier, even for H2.

 Literature comparison: cite:jiang-2009-porous-graph
     H2: 0.22 eV
     6x6 repeated graphene monolayer.
     Pore = 10 removed carbons. H passivated.
 [[./img/ref/jiang-2009-h2passivated.png]]
 [[./img/material/g-mono/3x3/pore=1/final.png]]

**** Vacuum distance for convergence

 #+CAPTION: Vaccuum distance convergence. Height represents distance between the molecule's closest atom and the graphene plane.
 #+NAME: fig:vaccuum-molecule-distance
 [[./img/results/convergence-vaccuum-pore=1.png]]


 Converged distance appears to be around 4 Å.

 cite:sun-2014-mechan-molec reports between 5-6 Å is the distance of non-interaction for these molecules. They used classical MD with LJ potentials.

 Final project max distance for both molecules was 3 Å. CO2 calculations probably affected since the minimum should have been lower, meaning the barrier energy would be higher.

**** Monolayer graphene pore distance convergence

 Ideally, we could model a pore placed on an infinite graphene sheet. The energy per atom of this structure would aproach a pristine graphene sheet.

 #+CAPTION: The effect of distance between pores on energy and calculation time.
 #+NAME: fig:g-mono-energy_vs_pore_distance
 [[./img/results/monolayer-energy_vs_pore_distance.png]]
***** Structures

 Distance = 4.92. Structure = 2x2
 [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=2.png]]
 Distance = 7.38. Structure = 3x3
 [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=3.png]]
 Distance = 9.84. Structure = 4x4
 [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=4.png]]
 Distance = 12.3. Structure = 5x5
 [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=5.png]]
 Distance = 14.76. Structure = 6x6
 [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=6.png]]


***** Pore=10 comparison

 Note that the 4x4 structure is the smallest possible size for a pore with 10 removed carbon atoms.

 Distance = 9.84. Structure = 4x4
 [[./img/results/monolayer-energy_vs_pore_distance-pore=10-size=4.png]]
 Distance = 12.3. Structure = 5x5
 [[./img/results/monolayer-energy_vs_pore_distance-pore=10-size=5.png]]
 Distance = 14.76. Structure = 6x6
 [[./img/results/monolayer-energy_vs_pore_distance-pore=10-size=6.png]]
 #+CAPTION: The effect of distance between pores on energy and calculation time.
 #+NAME: fig:g-mono-energy_vs_pore_distance
 [[./img/results/monolayer-energy_vs_pore_distance-pore=10.png]]

**** Bilayer graphene neural network sidebar
 Proposed project: Use a neural network trained on different bilayer graphene pore structures to 

 Sidebar: Determine minimum energy structures of different pore configurations for smaller structures first. Use this information to inform the larger structures.

 Motivation:
 - DFT relaxations bilayer graphene with significant pore size would take too long.
 - Current etching of pores does not allow for the geometric accuracy. (cite:koenig-2012-selec-molec: heavily cited experimental graphene transport paper uses bilayer graphene but didn't determine exact pore structure after etching.)
 - Graphene was found to reknit itself, so minimum energy pore structures are important. cite:zan-2012-graph-reknit
 [[./img/ref/zan-2012-reknit.png]]
 - This smaller project can be done on monolayer graphene at the same time with minimal effort and faster speeds.

 Where I'm at with this:
 - Created a function for determining candidates for etching based on current index.
 - Working on the structure for managing all the calculations and removing duplicates.

 get_neighbors example:
 #+BEGIN_SRC python
from jasp import *
from ase import Atoms, Atom
import twodee as td

with jasp('dft/material/g-bi/final') as calc:
    atoms = calc.get_atoms()
i = 3
atoms = atoms.repeat([i,i,1])

#td.bp(atoms)
struct = td.structure(atoms, layers=2)
index = 16
neighbors = td.get_neighbors(atoms, index, struct['layers'][0])
neighbors.append(index)
td.paint_atoms(atoms, neighbors, layers=struct['layers'])
td.bp(atoms)
 #+END_SRC

** DONE 2016-07-06 Group meeting
   CLOSED: [2016-07-18 Mon 16:40]
*** 2D structure module - twodee
For mainting helper functions for manipulating 2D materials
[[./twodee.py]]

**** Tests
Tests maintained in this file at [[twodee tests]].

***** create_base

Plan to incorporate into ASE DB.

   #+BEGIN_SRC python :results drawer
import twodee as td

atoms = td.create_base("graphene", size=5)

td.bp(atoms)
   #+END_SRC

   #+RESULTS:

***** center_layer

   #+BEGIN_SRC python :results drawer
import twodee as td

atoms = td.create_base("graphene", layers=2, size=4)
layers = td.layers(atoms)
center1 = td.center_layer(atoms, layers[0])
center2 = td.center_layer(atoms, layers[1])
c1 = td.closest_atom(atoms, center1)
c2 = td.closest_atom(atoms, center2)
td.paint_atoms(atoms, [c1, c2])
td.bp(atoms)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   :END:

***** edges

   #+BEGIN_SRC python :results drawer
import twodee as td

unitcell = td.create_base("graphene", layers=2)
atoms = td.create_base("graphene", layers=2, size=5)

e = td.edges(atoms, unitcell)
td.paint_atoms(atoms, e)
td.bp(atoms)
td.bp([e])
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   :END:

***** get_neighbors

Show layers[0] and layers[1]

#+BEGIN_SRC python
import twodee as td

atoms = td.create_base("graphene", layers=2, size=5)
index = 45
layers = td.layers(atoms)
neighbors = td.get_neighbors(atoms, index, layers[0], cutoff=1.5)
td.paint_atoms(atoms, [index])
td.paint_atoms(atoms, neighbors, sym='O')
td.bp(atoms)
#+END_SRC

***** is_connected

   #+BEGIN_SRC python
import twodee as td

graphene_cutoff = 1.5 # Angstrom. Should put this somewhere more permanent.

unitcell = td.create_base("graphene", layers=1)
size = 3
atoms = td.create_base("graphene", layers=1, size=size)

edges = td.edges(atoms, unitcell)#

td.bp(atoms)
print(td.is_connected(atoms, [8, 9, 10]))
print(td.is_connected(atoms, [8, 10, 14]))
print(td.is_connected(atoms, [9]))
td.bp()
   #+END_SRC

   #+RESULTS:
   : True
   : False
   : True

*** Pore candidate selection algorithm
**** Constraints
1. The pore may not appear to break the structure of the graphene plane.
[[./img/presentation/group-meeting-20160706/edges.png]]

2. "Islands" of carbon atoms are not allowed.
[[./img/presentation/group-meeting-20160706/island.png]]

3. Removed carbons must be neighbors.
[[./img/presentation/group-meeting-20160706/bad_pore.png]]

Example pics:
#+BEGIN_SRC python :results silent
import twodee as td

unitcell = td.create_base("graphene", layers=1)
size = 4
atoms = td.create_base("graphene", layers=1, size=size)
edges = td.edges(atoms, unitcell)
island = [13, 14, 15, 20, 22, 23, 28, 29, 30, 19, 26, 27]
bad_pore = [10, 11, 12, 23, 30, 31]

a = atoms.copy()
td.paint_atoms(a, edges)
td.print_image('presentation/group-meeting-20160706/edges', a)

a = atoms.copy()
td.paint_atoms(a, edges)
td.paint_atoms(a, island, sym="O")
td.print_image('presentation/group-meeting-20160706/island', a)

a = atoms.copy()
td.paint_atoms(a, edges)
td.paint_atoms(a, bad_pore, sym="O")
td.print_image('presentation/group-meeting-20160706/bad_pore', a)
#+END_SRC


*Why constraints?*
The amount of combinations for pores will be very large, even with constraints. It will be more useful to look at "more likely" pore candidates for our calculations. However, this does not address the possibility that the material would prefer one of the structures that are being disregarded.

**** First pass - Tree branching
[[~/hydrogen2D/img/movies/candidates-islands/size=3.gif]]
[[~/hydrogen2D/img/movies/candidates-islands/size=4.gif]]
[[~/hydrogen2D/img/movies/candidates-islands/size=5.gif]]

Issue: Creates islands

Possible solution: Manipulate the algorithm to step farther back within its recursion loop to start a new tree branch.

- Difficult to conceptualize
- Even harder to prove it accurately captures all combinations

**** Second pass - Exclusion from all combinations

[[~/hydrogen2D/img/movies/candidates/candidates-size=3.gif]]

Notes:
1. Show a comparison of how the two algorithms move by showing the gifs side-by-side. Draw diagrams.
2. Show td.is_connected() loop structure

|          Graphene size |   Pore size | Calculation time |
| (unitcell repititions) | (# carbons) |        (seconds) |
|------------------------+-------------+------------------|
|                      3 |           1 |              0.1 |
|                      3 |           2 |              0.3 |
|                      3 |           3 |              0.5 |
|                      3 |           4 |              0.6 |
|                      3 |           5 |              0.5 |
|                      3 |           6 |              0.2 |
|                      3 |           7 |              0.1 |
|                      4 |           1 |              0.7 |
|                      4 |           2 |              5.3 |
|                      4 |           3 |             26.9 |
|                      4 |           4 |             95.1 |

**** Third pass - Improvements
1. Speed increases: Storing larger lists, instead of calling functions like get_neighbors each time (moves from O(n^2) to O(n)).

2. Reliability: Write a method for determiniing if all combinations meeting the constraints are accounted for (more difficult).

**** Future
How to select the best structures for DFT calculations and training a neural network?
1. Start with a hand-curated set that are often found in literature.
2. Use the previous algorith to determine all combinations. Select from a group that have been shown to have the most promise from a faster calculation type (MD).

** TODO 2016-08-12 Group meeting
*** Improved pore candidate selection algorithm
- Cached get_neighbor call
- Speed increased by an order of magnitude
- Writing finished algorithms to a json file for future calls
- Possible memory considerations for very large structures

#+caption: A speed comparison of the pore candidate selection algorithm before and after optimizations for a graphene monolayer unitcell repeated 4 times.
#+label: tbl:candidate-algo-speed
|   Pore size | Choices | Candidates | Old algo. time | New algo. time |
| (# carbons) |         |            |      (seconds) |      (seconds) |
|-------------+---------+------------+----------------+----------------|
|           1 |      18 |         18 |            0.7 |           0.09 |
|           2 |     153 |         21 |            5.3 |           0.37 |
|           3 |     816 |         32 |           26.9 |           1.69 |
|           4 |    3060 |         54 |         *95.1* |         *5.87* |
|           5 |    8568 |        102 |                |          15.58 |

*** Neural network
**** Overfit duplicate energies

The neural networks were trained on single-point energy calculations of porous graphene structures. The sizes of these structures consisted of 2, 3, and 4 graphene monolayer repetitions. Pores were selected of various sizes and shapes for each size. Figure ref:fig:iter=-1-validation shows the error between neural networks and DFT for the calculated energies of the training and validation sets.

#+caption: The error between neural network and DFT calculations for the training and validation sets.
#+label fig:iter=-1-validation
[[./img/presentation/20160812-group_meeting/validation.png]]

I believe the patterns arising in this are due to energy duplicates in the pore candidates. I will need to address this before moving forward. The outliers around -0.007 eV/atom are from a 3 repetition superstructure with a 3 or 5 carbon pore that forms a symmetrical hole, as opposed to a crack. The networks did keep the RMSE below 1 meV/atom, but are probably severely overfit.

The networks would ideally be able to handle larger structures than those in the training set. To test if they are currently able to do this, they were used to calculate porous structures (pore sizes of 0, 3, and 4 carbons removed) based on a 5 monolayer repetition. Figure ref:fig:size5-extrapolation.png shows the error between the neural network and DFT calculations for this larger structure.

#+caption: The error between neural network and DFT calculations for the training and validation sets.
#+label fig:size5-extrapolation
[[./img/presentation/20160812-group_meeting/extrapolation.png]]

We see the same patterns arise due to energy duplicates and the RMSE has risen to over 4 meV/atom in the best case. Pristine graphene shows a very small error, which is good though expected.

**** Improvements
1. Used the ASE implementation of EMT
  - asap3 EMT code only contains potentials for metals
  - ASE's EMT has experimental potentials for carbon and hydrogen
  - Differences in energy between duplicates matched well with previously calculated VASP point-energy calculations
  - Missed uniques are likely accounted for in relaxation steps
  - Went from 77 to 19 candidates for sizes 2 and 3

2. Added trajectories from relaxation steps

3. Started training new networks with 528 calculations
   - Previous network had 255 calculations for sizes 2, 3, and 4
   - New iteration contains 528 calculations for sizes 2 and 3
     - Size 4 DFT calculations are in queue and will be included on the next iteration

*** Templates for queue submission

We can use Jinja2 templates for constructing python code that can be submitted to gilgamesh. 

Benefits:
- Removes big string blocks
- Increases consistency and reuse
- Iteration is more intuitive than formatted strings

**** Building a neural network
***** Template
#+BEGIN_SRC python :results output org drawer :tangle ./twodee/templates/build_nn.py
#!/usr/bin/env python
from amp import Amp
from amp.descriptor.gaussian import Gaussian
from amp.model import LossFunction
from amp.model.neuralnetwork import NeuralNetwork
from amp.utilities import Annealer
from ase.db import connect
import os
import twodee as td

# Required arguments from template
iteration = {{ iteration }}
framework = {{ framework }}
work_dir = "{{ work_dir }}"
db_path = "{{ db_path }}"
cutoff = {{ cutoff }}
energy_rmse = {{ energy_rmse }}
force_rmse = {{ force_rmse }}
cores = {{ cores }}

# Set working directory
os.chdir(work_dir)

# Get atoms from the database
images = []
db = connect(db_path)
for d in db.select(['iteration<={}'.format(iteration, 'train_set=True')]):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images.append(atoms)

# Build Amp object
framework_str = "-".join([str(f) for f in framework])
label = "networks/iter={0}/{1}/{1}".format(iteration, framework_str)
dblabel = "networks/iter={0}/iter={0}".format(iteration)
desc = Gaussian(cutoff=cutoff)
model = NeuralNetwork(hiddenlayers=framework)
calc = Amp(label=label,
           dblabel=dblabel,
           descriptor=desc,
           model=model,
	   cores=cores)
loss = LossFunction(convergence={'energy_rmse': energy_rmse,
                                 'force_rmse': force_rmse})
calc.model.lossfunction = loss
           
# Perform simulated annealing for global search
Annealer(calc=calc, images=images)

# Train the network
calc.train(images=images)
#+END_SRC

***** Runner
#+BEGIN_SRC python :results code
from jinja2 import Environment, PackageLoader
import os
import twodee as td

# Load in template
env = Environment(loader=PackageLoader('twodee', 'templates'))
template = env.get_template("build_nn.py")

# Call template in loop
frameworks = ((8, 8),)#, (8, 8, 8))
for framework in frameworks:
    args = {'iteration': 0,
            'framework': framework,
            'work_dir': os.getcwd(),
            'db_path': "database/master.db",
            'cutoff': 6.5,
            'energy_rmse': 1e-2,
            'force_rmse': 5e-2,
            'cores': 1}

    code = template.render(**args)

    framework_str = "-".join([str(f) for f in framework])
    nn_dir = "networks/iter={0}/{1}".format(args['iteration'], framework_str)

    # Do something with the rendered template
    print(code)
    #submit_file = os.path.join(nn_dir, 'submit.py')
    #with open(submit_file, 'w') as f:
    #    f.write(code)
    #
    #td.qsub(submit_file, walltime="10:00:00", ppn=args['cores'])
    #print('{0} submitted.'.format(framework_str))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC python
#!/usr/bin/env python
from amp import Amp
from amp.descriptor.gaussian import Gaussian
from amp.model import LossFunction
from amp.model.neuralnetwork import NeuralNetwork
from amp.utilities import Annealer
from ase.db import connect
import os
import twodee as td

# Required arguments from template
iteration = 0
framework = (8, 8)
work_dir = "/home-guest/devonw/hydrogen2D"
db_path = "database/master.db"
cutoff = 6.5
energy_rmse = 0.01
force_rmse = 0.05
cores = 1

# Set working directory
os.chdir(work_dir)

# Get atoms from the database
images = []
db = connect(db_path)
for d in db.select(['iteration<={}'.format(iteration, 'train_set=True')]):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images.append(atoms)

# Build Amp object
framework_str = "-".join([str(f) for f in framework])
label = "networks/iter={0}/{1}/{1}".format(iteration, framework_str)
dblabel = "networks/iter={0}/iter={0}".format(iteration)
desc = Gaussian(cutoff=cutoff)
model = NeuralNetwork(hiddenlayers=framework)
calc = Amp(label=label,
           dblabel=dblabel,
           descriptor=desc,
           model=model,
	   cores=cores)
loss = LossFunction(convergence={'energy_rmse': energy_rmse,
                                 'force_rmse': force_rmse})
calc.model.lossfunction = loss
           
# Perform simulated annealing for global search
Annealer(calc=calc, images=images)

# Train the network
calc.train(images=images)
#+END_SRC

**** Generic building blocks
***** Build neural network submission file
A script which uses templates to build scripts that can be submitted to the queue on Gilgamesh.

The generated code does the following: 
1. Get atoms from a database with certain atoms marked 'train_set'.
2. Build an Amp object with the Behler descriptor and Neural Network regression.
3. Train to a moderate energy convergence.
4. Remove all training data except initial parameters.
5. Build an Amp object with the initial parameters.
6. Train to a strict convergence.

#+BEGIN_SRC python :results output org drawer
from jinja2 import Environment, PackageLoader
import os
import twodee as td

# Load in python templates
env = Environment(loader=PackageLoader('twodee', 'templates'))
header = env.get_template("header.py")
footer = env.get_template("footer.py")
ase_db_get = env.get_template("ase_db_get.py")
amp = env.get_template("amp.py")
amp_train = env.get_template("amp_train.py")
remove_file = env.get_template("remove_file.py")

wd = 'script_builder/'
framework = (5, 5)
framework_str = "-".join([str(f) for f in framework])
nn_dir = os.path.join(wd, framework_str, "")

# Collect the rendered code from the following templates
codes = []

# 1. Get atoms from a database with certain atoms marked 'train_set'.
db_path = os.path.join(wd, "test.db")
select = "train_set=True"
codes.append(ase_db_get.render(db_path=db_path, select=select))

# 2. Build an Amp object with the Behler descriptor and Neural Network regression.
desc_type = "Behler"
desc_args = {"cutoff": 6.5}
reg_type = "NeuralNetwork"
reg_args = {"hiddenlayers": framework}
amp_args = {"label": nn_dir}
codes.append(amp.render(desc_type=desc_type,
                        desc_args=desc_args,
                        reg_type=reg_type,
                        reg_args=reg_args,
                        amp_args=amp_args))

# 3. Train to a moderate energy convergence.
gs_type = "SimulatedAnnealing"
gs_args = {"temperature": 70, "steps": 50}
train_args = {"data_format": 'db',
                "cores": 1,
                "energy_goal": 10,
                "force_goal": None,
                "extend_variables": False}
codes.append(amp_train.render(train_args=train_args,
                                gs_type=gs_type,
                                gs_args=gs_args))

# 4. Remove all training data except initial parameters.
file_path = os.path.join(nn_dir, 'train-log.txt')
codes.append(remove_file.render(file_path=file_path))
file_path = os.path.join(nn_dir, 'trained-parameters.json')
codes.append(remove_file.render(file_path=file_path))

# 5. Build an Amp object with the initial parameters.
amp_args = {"label": nn_dir,
                "load": os.path.join(nn_dir, 'initial-parameters.json')}
codes.append(amp.render(amp_args=amp_args))

# 6. Train to a strict convergence.
train_args = {"data_format": 'db',
                "cores": 1,
                "energy_goal": 1e-3,
                "force_goal": None,
                "extend_variables": False}
codes.append(amp_train.render(train_args=train_args))
codes.append(footer.render())

# Combine all templates into one .py file and submit to queue
code = "\n\n".join(codes)

submit_file = os.path.join(nn_dir, 'submit.py')
with open(submit_file, 'w') as f:
    f.write(code)

#td.qsub(submit_file, walltime="10:00:00")
#print('{0} submitted.'.format(framework_str))
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

***** Output script
The output in the [[file:./script_builder/5-5/submit.py][submit.py]] file from the previous script. Strange spacing is due to not controlling whitespace well around conditional statements in the templates.

#+BEGIN_SRC python :results output org drawer
#!/usr/bin/env python
###############################################
# ase_db_get.py
# Template for selecting a list of atoms objects from an ASE DB

db_path = "script_builder/test.db"
select = "train_set=True"

from ase.db import connect
db = connect(db_path)

images = []
for d in db.select(select):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

#!/usr/bin/env python
###############################################
# amp.py
# Template for building an Amp calculator object

amp_args = {'label': 'script_builder/5-5/'}

# Build descriptor object
from amp.descriptor import Behler
desc = Behler(**{'cutoff': 6.5})
amp_args["descriptor"] = desc

# Build regression object
from amp.regression import NeuralNetwork
reg = NeuralNetwork(**{'hiddenlayers': (5, 5)})
amp_args["regression"] = reg

# Build Amp calculator object
from amp import Amp
calc = Amp(**amp_args)

#!/usr/bin/env python
###############################################
# amp_train.py
# Template for training an Amp object
# Required vars: calc (Amp)
#                images (Atoms)

train_args = {'cores': 1, 'force_goal': None, 'data_format': 'db', 'extend_variables': False, 'energy_goal': 10}


# Define global search object
from amp import SimulatedAnnealing
gs = SimulatedAnnealing(**{'steps': 50, 'temperature': 70})
train_args['global_search'] = gs


# Run training calculations
calc.train(images=images,
           **train_args)

#!/usr/bin/env python
###############################################
# remove_file.py
# Template for removing a file
# TODO devon: Deprecate? Consider a more generic setup.

file_path = "script_builder/5-5/train-log.txt"

import os
os.unlink(file_path)

#!/usr/bin/env python
###############################################
# remove_file.py
# Template for removing a file
# TODO devon: Deprecate? Consider a more generic setup.

file_path = "script_builder/5-5/trained-parameters.json"

import os
os.unlink(file_path)

#!/usr/bin/env python
###############################################
# amp.py
# Template for building an Amp calculator object

amp_args = {'load': 'script_builder/5-5/initial-parameters.json', 'label': 'script_builder/5-5/'}





# Build Amp calculator object
from amp import Amp
calc = Amp(**amp_args)

#!/usr/bin/env python
###############################################
# amp_train.py
# Template for training an Amp object
# Required vars: calc (Amp)
#                images (Atoms)

train_args = {'cores': 1, 'force_goal': None, 'data_format': 'db', 'extend_variables': False, 'energy_goal': 0.001}



# Run training calculations
calc.train(images=images,
           **train_args)

#!/usr/bin/env python
###############################################
# footer.py
# Template for printing standard success message for parsing



print("=======================================")
print("Successfully completed script.")
print("Exit status: 0")
#+END_SRC

#+RESULTS:
:RESULTS:
=======================================
Successfully completed script.
Exit status: 0
:END:

* Research
** Literature
*** Graphene
**** cite:novoselov-2005-two-dimen
**** cite:partoens-2006-from-graph graphene structure unitcell
**** cite:geim-2009-graph
**** *cite:jiang-2009-porous-graph DFT porous graphene separation of H2/CH4
 Selectivity results
 | Graphene monolayer porous N/H functionalized |  10^8 |
 | Graphene monolayer porous H functionalized   | 10^23 |
 | Traditional polymer / silica membranes       |  10^8 |
**** cite:pontes-2009-barrier-free DFT HCN production with substitutional doping using boron
**** DONE cite:du-2011-separ-hydrog DFT H2/N2 separation
     CLOSED: [2016-06-01 Wed 14:59]
**** DONE *cite:koenig-2012-selec-molec Experimental separation of common gases
     CLOSED: [2016-06-01 Wed 14:59]
**** cite:shan-2012-influen-chemic CO2/N2 separation using cite:jiang-2009-porous-graph funcitonalized groups
**** DONE cite:drahushuk-2012-mechan-gas MD H2/N2 separation. Explains mechanisms for gases crossing the membrane
     CLOSED: [2016-06-01 Wed 14:59]
**** cite:kim-2013-selec-gas  Exp O2/N2. Most work done on GO.
**** cite:miao-2013-first-princ DFT proton/H separation
**** cite:qin-2013-graph-with H2&He separation from air. Octogon pore + secondary small pore.
**** cite:ambrosetti-2014-gas-separ Water filtration through porous graphene. No permeation/selectivity data.
**** cite:celebi-2014-ultim-permeat Exp separation of H2/CO2 with bilayer G. Also a water permeance comparison to Goretex.
**** cite:tsetseris-2014-graph DFT Boron can pass through pristine graphene under moderate annealing conditions
**** cite:sun-2015-applic-nanop DFT separation for gases in natural gas processing
**** cite:wen-2015-inhib-effec Inhibition effect of non-permeating components
**** cite:achtyl-2015-aqueous-proton Exp/DFT Defect detection. Aqueous proton transfer

*** Polyphenylene (Porous Graphene (PG))
**** cite:bieri-2009-porous-graph Synthesis of PG
**** *cite:blankenburg-2010-porous-graph Selectivity study of common gases with DFT
 [[./img/blankenburg-2010-porous-graph-3.png]]
**** cite:schrier-2010-helium-separ Helium isotope separation
**** cite:li-2010-two-dimen-polyp H2 separation from CO2, CO, CH4
**** cite:lu-2014-promis-monol DFT O2 separation from harmful gases
**** cite:huang-2014-improv-permeab Bilayer porous graphene. H2/CH4 separation. High permeance and selectivity
**** cite:tao-2014-tunab-hydrog DFT PG-ESX study on hydrogen purification
 | Molecule |     Kinetic |
 |          | Diam. (Ang) |
 |----------+-------------|
 | H2       |         2.9 |
 | N2       |        3.64 |
 | CO       |        3.76 |
 | CH4      |         3.8 |
 Note: Agrees with common molecules table.

**** *cite:brockway-2013-noble-gas DFT PG-ESX study similar to Blankenberg's
**** Notes 
 High temperatures required for permeance of H2 and He would destroy a PG monolayer. cite:huang-2014-improv-permeab
*** hexagonal Boron Nitride (hBN)
**** cite:corso-2004-boron-nitrid-nanom Boron nitride nanomesh
 Hole in mesh: size 20 Å
 - 'likely driven by the lattice mismatch of the film and the rhodium substrate'
**** cite:jin-2009-fabric-frees monolayer fabrication with electron irradiation
**** cite:nag-2010-graph-analog-bn properties of hBN compared to graphene
**** cite:hu-2014-proton-trans proton transport of graphene, hBN, MoS2
**** *cite:zhang-2015-hexag-boron H2/CH4 separation. Triangular pores.
 Drahushuk, L. W.; Strano, M. S. Mechanisms of Gas Permeation
 through Single Layer Graphene. Langmuir 2012, 28, 16671−16678.
*** Graphene oxide
**** *cite:kim-2013-selec-gas
**** *cite:li-2013-ultrat-molec
**** cite:yoo-2013-graph-graph
*** Molybdenum disulphide (MoS2)
**** cite:hong-2015-explor-atomic 
*** Quantum mechanics
**** Lennard-Jones potential
 [[http://chemwiki.ucdavis.edu/Core/Physical_Chemistry/Physical_Properties_of_Matter/Atomic_and_Molecular_Properties/Intermolecular_Forces/Specific_Interactions/Lennard-Jones_Potential][ChemWiki - UC Davis]]

**** van der Waals radius
 [[http://chemwiki.ucdavis.edu/Core/Theoretical_Chemistry/Chemical_Bonding/General_Principles_of_Chemical_Bonding/Covalent_Bond_Distance%2C_Radius_and_van_der_Waals_Radius][ChemWiki - UC Davis]]
*** Neural networks
**** *cite:behler-2007-gener-neural
**** TODO cite:behler-2008-press-induc
**** TODO cite:behler-2011-neural-networ
**** TODO cite:behler-2014-repres-poten
*** Review articles
**** cite:yoo-2013-graph-graph Graphene and graphene oxide uses as barriers
*** Patents
**** TODO Aperture
 http://www.google.com/patents/US20140263035
*** Non-pertinent
**** TODO cite:britnell-2012-elect-tunnel hBN as a dielectric
*** To Read
**** TODO cite:elstner-1998-self-consis
**** TODO cite:zhu-2006-permean-shoul
**** TODO cite:zhang-2012-tunab-hydrog
**** TODO cite:drahushuk-2012-mechan-gas
**** TODO cite:nieszporek-2015-alkan-separ
**** TODO cite:liu-2014-mechan-proper
**** TODO cite:tao-2014-tunab-hydrog
**** TODO cite:wang-2014-trans-metal
**** TODO cite:bunch-2008-imper-atomic
**** TODO cite:leeuwen-1994-deriv-stock Derivation of L-J lengths of liquids.
**** TODO cite:hauser-2012-methan-selec Methane transfer through graphene, DFT
** Questions
** Are the kinetic diameters used in Blankenberg correct?
cite:blankenburg-2010-porous-graph uses cite:leeuwen-1994-deriv-stock for kinetic diameter of ammonia, even though they're stated for liquids.
cite:tsuru-2010-permeat-proper shows that certain kinetic diameter calculations may not apply to certain separations.
** What is the unit GPU?
Gas permeance unit
1 GPU = 0.33 mol/(m^2*s*Pa)
** What's a dispersion correction in dft?
Dipoles occur as a molecule passes through the membrane. They need to be accounted for in the energy calculations.
** Ryd compared to eV?
Stands for Rydberg constant.
1 eV = 7.350e-2 Ryd
300 eV = 22.096 Ryd
** TODO Best way to calculate a pore's diameter?
** What should I compare H2 transport with?
- cite:koenig-2012-selec-molec 
- cite:jiang-2009-porous-graph 
- cite:blankenburg-2010-porous-graph

** Properties
*** Bond lengths

| Molecule | Bond | Bond Length (Å) |
| H2       | H-H  |            0.74 |
| CO2      | C=O  |            1.21 |
| N2       | N=-N |            1.13 |

**** References
CO2 C=O, H2, N2: CRC Handbook, Section 9, Characteristic Bond Lengths in Free Molecules

*** Common molecules
Useful numbers:
- Average energy of a gas particle at room temperature: ~0.037 eV (need cite)
  - calculated as $E=(3/2)kT$, where $k$ is the Boltzmann constant

#+caption: Properties of common industrial gases.
#+name: tab:properties-common_gases
| Molecule      |  Kinetic |
|               | diameter |
|               |      (Å) |
|---------------+----------|
| He            |     2.60 |
| H2O           |     2.65 |
| Ne            |     2.79 |
| H2            |     2.89 |
| NH3           |     3.26 |
| CO2           |     3.30 |
| Ar            |     3.42 |
| O2            |     3.46 |
| Kr            |     3.60 |
| H2S           |     3.60 |
| N2            |     3.64 |
| CO            |     3.76 |
| CH4           |     3.80 |
|---------------+----------|
| CH4           |      3.8 |
| C2H6          |      --- |
| C2H4          |      3.9 |
| C3H8          |      4.3 |
| n-C4H10       |      4.3 |
| C3H6          |      4.5 |
| i-C4H10       |        6 |
|---------------+----------|
| Benzene       |     5.85 |
| Toluene       |     5.85 |
| p-xylene      |     5.85 |
| Ethyl-benzene |     6.00 |
| Cyclohexane   |      6.0 |
| o-xylene      |     6.80 |
| m-xylene      |     6.80 |

**** References
Kinetic diameter
- He, H2S, CO: [[https://en.wikipedia.org/wiki/Kinetic_diameter][Wiki]]
- CO2, O2, N2, H2O, CH4, H2: cite:ismail-2015-fundam-gas p14
- CO2, CO, CH4: cite:li-2010-two-dimen-polyp
- NH3: cite:blankenburg-2010-porous-graph 
- Ne, Ar: [[http://www.kayelaby.npl.co.uk/general_physics/2_2/2_2_4.html][NPL]]
- Kr: [[https://smartech.gatech.edu/handle/1853/50383][Crawford-2013]]
- He, H2, O2, N2, CO, CO2, CH4, C2H6, C2H4, C3H8, C3H6, n-C4H10, i-C4H10: cite:matteucci-2006-trans-gases Has L-J parameters in same table
- benz, tol, eth-benz, xylene: cite:baertsch-1996-permeat-aromat
- cyclohexane: cite:sing-2004-use-molec

*** 2D materials

Structure
| Material | Stack | Lattice      |
|          |       | Constant [Å] |
|----------+-------+--------------|
| Graphene | Mono  | 2.460        |
|          |       |              |


Stability
| Material | Stack | Production | Temperature   | Ref                       |
|          |       |            | Stability [K] |                           |
|----------+-------+------------+---------------+---------------------------|
| Graphene | Mono  | CVD        | 2600          | cite:kim-2010-high-temper |



| Material | Features | Pore     |
|          |          | Size (Å) |
|----------+----------+----------|
| Graphene | Pristine |          |
| PG       |          | 2.48     |
| PG-ES1   |          |          |
| PG-ES2   |          |          |
| PG-ES3   |          |          |
| hBN      |          |          |

**** References

Structure
- Lattice constant
  - Graphene mono: cite:partoens-2006-from-graph

Pore size
- Graphene, Pristine: 
- PG: cite:li-2010-two-dimen-polyp
** Separations

Materials to research
- Graphene Monolayer
- Graphene Bilayer
- Graphene oxide
- Boron nitride monolayer
- Boron nitride bilayer

*** Master Table

Table legend:
- 2D Material:
  - hBN: hexagonal boron nitride
  - PG: Polyphenylene (porous graphene)
  - PG-ES1: Porous Graphene-E-Stilbene-1
- Features: Distinctive variations of the material.
  - Porous: Intentially engineered pores
  - Defects: Naturally occuring defects from the production process.
- Func. Groups: Functional groups attached around a pore.
  - CNT: Carbon nanotubes
- Methods:
  - DFT: Density functional theory
  - Exp: Experimental
  - MD: Molecular dynamics simulation
  - TST: Transition state theory
- Molecules: Numbers denote separation groups. Members of "a" can be separated from "b" and both can be separated from "c". Additionally, "a" transfers across the barrier before "b".

#+caption: Table of separation selectivity groupings found in literature with molecule columns ordered by kinetic diameter.
#+name: tab:separations-common_gases
| Reference                          | Methods  | 2D             | Stack   | Features | Func.  | He | H2O | Ne | H2 | NH3 | CO2 | Ar | O2 | N2 | Kr | H2S | CO | CH4 | Note |
|                                    |          | Material       |         |          | Groups |    |     |    |    |     |     |    |    |    |    |     |    |     |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:jiang-2009-porous-graph       | DFT, MD  | Graphene       | Mono    | Porous   | N/H, H |    |     |    | a  |     |     |    |    |    |    |     |    | b   |      |
| cite:wesołowski-2011-pillar-graph  | MD       | Graphene       | Multi   | Porous   | CNT    | c  |     |    |    |     |     | b  |    |    | a  |     |    |     |      |
| cite:du-2011-separ-hydrog          | MD       | Graphene       | Mono    | Porous   |        |    |     |    | a  |     |     |    |    | b  |    |     |    |     |      |
| cite:koenig-2012-selec-molec       | Exp      | Graphene       | Bilayer | Porous   |        |    |     |    | a  |     | a   | b  |    | b  |    |     |    | b   |      |
| cite:kim-2013-selec-gas            | Exp      | Graphene       | Multi   | Defects  |        |    |     |    |    |     |     |    | a  | b  |    |     |    |     |      |
| cite:celebi-2014-ultim-permeat     | Exp      | Graphene       | Bilayer | Porous   |        |    |     |    | a  |     | b   |    |    |    |    |     |    |     |      |
| cite:lei-2014-separ-hydrog         | DFT      | Graphene       | Mono    | Porous   |        |    |     |    |    |     |     |    |    |    |    | a   |    | b   |    3 |
| cite:liu-2015-selec-trend          | MD       | Graphene       | Mono    | Porous   | N/H    |    |     |    | a  |     | a   | b  |    | b  |    |     |    | b   |      |
| cite:sun-2015-applic-nanop         | MD       | Graphene       | Mono    | Porous   | N/H    |    |     |    |    |     | a   |    |    | a  |    | a   |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:blankenburg-2010-porous-graph | DFT, MD  | PG             | Mono    |          |        | a  |     | a  | a  | c   | b   | d  | b  | c  |    |     | c  |     |      |
| cite:li-2010-two-dimen-polyp       | DFT      | PG             | Mono    |          |        |    |     |    | a  |     | b   |    |    |    |    |     | b  | b   |      |
| cite:huang-2014-improv-permeab     | DFT, MD  | PG             | Bilayer |          |        |    |     |    | a  |     |     |    |    |    |    |     |    | b   |      |
| cite:schrier-2012-carbon-dioxid    | MD       | PG-ES1         | Mono    |          |        |    |     |    |    |     | a   |    | b  | b  |    |     |    |     |      |
| cite:brockway-2013-noble-gas       | DFT, MD  | PG-ES1         | Mono    |          |        | a  |     | a  |    |     | b   | b  | b  | b  |    |     |    | c   |      |
| cite:tao-2014-tunab-hydrog         | DFT, MD  | PG-ES1         | Mono    |          |        |    |     |    | a  |     | b   |    |    | b  |    |     |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:nair-2012-unimp-permeat       | Exp, MD  | Graphene oxide | 1 µm    |          |        | b  | a   |    | b  |     |     | b  |    | b  |    |     |    |     |      |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 2-18 nm |          |        |    |     |    | a  |     | b   |    |    |    |    |     |    |     |      |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 2-18 nm |          |        |    |     |    | a  |     |     |    |    | b  |    |     |    |     |      |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 18 nm   |          |        | a  |     |    | a  |     | b   |    | b  | b  |    |     | b  | b   |    1 |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide | 3-7 nm  |          |        |    |     |    | a  |     | b   |    |    |    |    |     |    |     |    2 |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide | 3-7 nm  |          |        | b  |     |    | b  |     | a   |    | b  | b  |    |     |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:zhang-2015-hexag-boron        | DFT, MD  | hBN            | Mono    | Porous   | N/H    |    |     |    | a  |     |     |    |    |    |    |     |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:jiao-2011-graph               | DFT, TST | Graphdiyne     | Mono    |          |        |    |     |    | a  |     | b   |    |    |    |    |     |    | b   |      |
| cite:zhu-2015-c-n                  | DFT      | C2N            | Mono    |          |        | a  | b   | b  |    |     | b   | b  | b  | b  |    | b   |    | b   |      |
| cite:li-2015-effic-helium          | DFT, MD  | g-C3N4         | Mono    |          |        | a  |     | b  | b  |     | b   | b  |    | b  |    |     | b  | b   |      |

Notes:
1. Extrapolated from single-gas permeation results.
2. Long time scale ~1 hr. At short time scales <0.1 hr, the permeance rate is reversed.
3. Pore carbons had negative charge (-0.241 e).

*** Atmospheric separations
N2, O2, Ar, CO2, Ne, He, CH4 

| Reference                          | Methods | 2D             | Stack   | Features | Func.  | N2 | O2 | Ar | CO2 | Ne | He | CH4 |
|                                    |         | Material       |         |          | Groups |    |    |    |     |    |    |     |
|------------------------------------+---------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:koenig-2012-selec-molec       | Exp     | Graphene       | Bilayer | Porous   |        | b  |    | b  | a   |    |    | b   |
| cite:kim-2013-selec-gas            | Exp     | Graphene       | Multi   | Defects  |        | b  | a  |    |     |    |    |     |
| cite:liu-2015-selec-trend          | MD      | Graphene       | Mono    | Porous   | N/H    | b  |    | b  | a   |    |    | b   |
| cite:sun-2015-applic-nanop         | MD      | Graphene       | Mono    | Porous   | N/H    | a  |    |    | a   |    |    | b   |
|------------------------------------+---------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:blankenburg-2010-porous-graph | DFT, MD | PG             | Mono    |          |        | c  | b  | d  | b   | a  | a  |     |
| cite:schrier-2012-carbon-dioxid    | MD      | PG-ES1         | Mono    |          |        | b  | b  |    | a   |    |    |     |
| cite:brockway-2013-noble-gas       | DFT, MD | PG-ES1         | Mono    |          |        | b  | b  | b  | b   | a  | a  | c   |
|------------------------------------+---------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:li-2013-ultrat-molec          | Exp     | Graphene oxide | 18 nm   |          |        | b  | b  |    | b   |    | a  | b   |
| cite:kim-2013-selec-gas            | Exp     | Graphene oxide | 3-7 nm  |          |        | b  | b  |    | a   |    | b  | b   |
|------------------------------------+---------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:zhu-2015-c-n                  | DFT     | C2N            | Mono    |          |        | b  | b  | b  | b   | b  | a  | b   |
| cite:li-2015-effic-helium          | DFT, MD | g-C3N4         | Mono    |          |        | b  |    | b  | b   | b  | a  | b   |

*** Water-gas shift
CO + H2O -> CO2 + H2

| Reference                          | Methods  | 2D             | CO | H2O | CO2 | H2 |
|                                    |          | Material       |    |     |     |    |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:celebi-2014-ultim-permeat     | Exp      | Graphene       |    |     | b   | a  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:blankenburg-2010-porous-graph | DFT      | PG             | c  |     | b   | a  |
| cite:li-2010-two-dimen-polyp       | DFT      | PG             | b  |     | b   | a  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:tao-2014-tunab-hydrog         | DFT, MD  | PG-ES1         |    |     | b   | a  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:nair-2012-unimp-permeat       | Exp, MD  | Graphene oxide |    | a   |     | b  |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide |    |     | b   | a  |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | b  |     | b   | a  |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide |    |     | b   | a  |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide |    |     | a   | b  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:jiao-2011-graph               | DFT, TST | Graphdiyne     |    |     | b   | a  |

*** Nobel gas separation
He, Ne, Ar, Kr

| Reference                          | Methods | 2D       | He | Ne | Ar | Kr |
|                                    |         | Material |    |    |    |    |
|------------------------------------+---------+----------+----+----+----+----|
| cite:wesołowski-2011-pillar-graph  | MD      | Graphene | c  |    | b  | a  |
|------------------------------------+---------+----------+----+----+----+----|
| cite:blankenburg-2010-porous-graph | DFT     | PG       | a  | a  | d  |    |
|------------------------------------+---------+----------+----+----+----+----|
| cite:zhu-2015-c-n                  | DFT     | C2N      | a  | b  | b  |    |
| cite:li-2015-effic-helium          | DFT, MD | g-C3N4   | a  | b  | b  |    |

** TODO H2 transport comparison
Use the following works to generate a table with comparisons of H2 transport
- cite:koenig-2012-selec-molec 
- cite:jiang-2009-porous-graph 
- cite:blankenburg-2010-porous-graph

* Scripts
** 2016-03-07: Remote copying
*Note 2016-05-18* - Copying is better done by maintaining the git repo. 

To Gilgamesh:
#+BEGIN_SRC sh
scp ~/Google_Drive/projects/hydrogen2D/hydrogen2D.org devonw@gilgamesh.cheme.cmu.edu:projects/hydrogen2D
#+END_SRC

#+RESULTS:

To host:
#+BEGIN_SRC sh
scp devonw@gilgamesh.cheme.cmu.edu:projects/hydrogen2D/hydrogen2D.org ~/Google_Drive/projects/hydrogen2D
#+END_SRC

To update buffer
#+BEGIN_SRC 
M-x revert-buffer
#+END_SRC

** 2016-05-10: Tramp remote execution
This is a way to run code on a remote server while maintaining the code locally. It works for basic things that have text output. It doesn't work for things like ASE's view, which spawns a gui, and I haven't tried it for running vasp codes (not sure how directories would work out exactly -> may need to use absolute paths).

Check tramp works
#+begin_src sh :dir /devonw@gilgamesh.cheme.cmu.edu: :results output
echo "Executed by `whoami` on `hostname` in `pwd`"
#+end_srC

#+RESULTS:
: Executed by devonw on gilgamesh.cheme.cmu.edu in /home-guest/devonw

Test what $PATH is defined as. May need to copy the remote's path to the tramp path (Don't know why they'd want this to be different except for speed(?)).
#+begin_src sh :dir /ssh:devonw@gilgamesh.cheme.cmu.edu: :results output
#source ~/.bash_profile
#echo $PATH
#source .bash_profile
echo $PATH
#+end_src

#+RESULTS:
: /opt/kitchingroup/vasp-5.3.5/vtstscripts-914:/home-research/jkitchin/bin:/opt/vtk/bin:/opt/kitchingroup/vasp-5.3.5/ase-s16/tools:/opt/kitchingroup/vasp-5.3.5/jasp-s16/jasp/bin:/opt/kitchingroup/vasp-5.3.5/bin:/usr/mpi/intel/openmpi-1.4-qlc/bin:/opt/kitchingroup/CANOPY/Canopy_64bit/User/bin:/opt/maui/bin:/opt/fav/bin:/usr/local/texlive/2012/bin/x86_64-linux:/opt/intel/Compiler/11.1/072/bin/intel64:/opt/intel/impi/4.0.0.028/intel64/bin:/usr/lib64/qt-3.3/bin:/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/usr/share/pvm3/lib:/sbin:/usr/sbin:/usr/local/sbin

Modules are used to load in python code (?). Weird that this doesn't print what it does in shell.
#+begin_src sh :dir /devonw@gilgamesh.cheme.cmu.edu: :results output
source ~/.bash_profile
module list
#+end_src

#+RESULTS:

Test remote execution of a python file. The import statements working is the important part.
#+BEGIN_SRC python :results output :dir /devonw@gilgamesh.cheme.cmu.edu:
import os
from ase import Atoms
import numpy as np
from jasp import *
a = 5
print(a)
#+END_SRC

#+RESULTS:
: 5

Local python test. Unless you've installed ase and jasp locally, this shouln't work but the previous block should have.
#+BEGIN_SRC python :results output
import numpy as np
from ase import Atoms
from jasp import *
a = 5
print(a)
#+END_SRC

#+RESULTS:

** 2016-05-23: Test vasp is working on the server

#+BEGIN_SRC python
import sys

from ase import Atoms, Atom
from ase.structure import molecule
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
JASPRC['queue.walltime'] = '00:30:00'

atoms = molecule('C2H6')
atoms.center(vacuum=4)

ENCUTS = [300]
energies_en = []
forces_en = []
ready = True
for en in ENCUTS:
    job_name = '~/tmp/vasp_test/molecules/c2h6-en-{0}'.format(en)
    with jasp(job_name,
              encut=en,
              xc='PBE',
              atoms=atoms) as calc:
        try:
            energies_en.append(atoms.get_potential_energy())
            forces_en.append(atoms.get_forces())
        except (VaspSubmitted, VaspQueued):
            ready = False
            print("Still processing: {}".format(job_name))

if not ready:
    import sys; sys.exit()

print("{0:5s}    {1:7s}    {2:9s}".format("ENCUT", "Energy", "Max force"))
print("{0:5s}    {1:7s}    {2:9s}".format("", "[eV]", "[eV/Ang]"))
print("-----------------------------")
for i, energy, force in zip(ENCUTS, energies_en, forces_en):
    print("{0:5d}    {1:7.3f}    {2:9.3f}".format(i, energy, force.max()))
#+END_SRC

#+RESULTS:
: Still processing: ~/tmp/vasp_test/molecules/c2h6-en-300

** 2016-05-31: View atoms
#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
    
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]

def view_atoms(name):
    images = []
    for i, h in enumerate(heights):
	with jasp('./dft/' + name + '/d={0:0.2f}'.format(h)) as calc:
	    atoms = calc.get_atoms()
	    images.append(atoms)
    view(images)

base_name = 'transport/g-mono/3x3/pore=1/molec=CO2/'

name_free = base_name + 'linear-unconst_all'
#view_atoms(name_free)

name_uncon = base_name + 'linear-unconst_G'
#view_atoms(name_uncon)

name_con = base_name + 'linear-const'
view_atoms(name_con)
#+END_SRC

#+RESULTS:

** TODO 2016-06-02: Improve energy resolution at curves
Suggest more points to improve the resolution of a total energy curve for a transporting molecule through a 2D material plane.

#+BEGIN_SRC python


#+END_SRC

** 2016-07-07: ASE Neighbors

#+BEGIN_SRC python
from ase.neighborlist import NeighborList

import twodee as td


atoms = td.create_base("graphene", size=5)
nblist = NeighborList([0.75 for i in range(len(atoms))],
                      bothways=True,
                      self_interaction=False)
nblist.update(atoms)

nbs = nblist.get_neighbors(11)[0]
td.paint_atoms(atoms, nbs)
td.bp(atoms)
td.bp(nbs)
#+END_SRC

#+RESULTS:
: (array([12, 20, 10]), array([[0, 0, 0],
:        [0, 0, 0],
:        [0, 0, 0]]))

** 2016-07-07: Making better .gif's with ImageMagick
Currently, the following command leaves a lot of unwanted artifacts in .gif's of the pore candidate selection algorithm.

#+BEGIN_SRC sh :results silent
cd ./img/scripts/20160707-imagemagick/size=3/pore=5/
convert -delay 30 -loop 0 *.png ../../bad_example.gif
#+END_SRC

Output: [[file+sys:./img/scripts/20160707-imagemagick/bad_example.gif]]

Issues:
- Red dots have grey outline from previous carbons.
- Entire image occasionally goes grey.

Below are new attempts using different imagemagick command line arguments.

White background:
#+BEGIN_SRC sh :results silent
cd ./img/scripts/20160707-imagemagick/size=3/pore=5/
convert -delay 30 *.png -loop 0 -background white -alpha remove ../../white_bg.gif
#+END_SRC

Transparent background (*not working*):
#+BEGIN_SRC sh :results silent
cd ./img/scripts/20160707-imagemagick/size=3/pore=5/
convert -delay 30 *.png -loop 0 -background white -alpha remove ../../tmp.gif
convert ../../tmp.gif -fuzz 50% -transparent white ../../transparent_bg.gif
#+END_SRC

Other arguments tried:
#+BEGIN_EXAMPLE
-layers optimize  # messed up colors halfway through
-dither FloydSteinberg
#+END_EXAMPLE

** 2016-07-08: Collect png's from subdirectories for a gif

#+BEGIN_SRC python
def convert_subdirectories(path, delay=30, name=None):
    from subprocess import call
    import os

    path = os.path.dirname(path)
    walk = os.walk(path)
    subdirs = sorted(next(walk)[1])

    for s in subdirs:
        cwd = os.path.join(path, s)
        pngs = os.path.join(cwd, "*.png")
        gif = os.path.join(path, s + ".gif")
        cmd_convert = "convert -delay {2} {0} -loop 0 -background white -alpha remove {1}".format(pngs, gif, delay)
        call(cmd_convert, shell=True)

    combined = ""
    for s in subdirs:
        combined += os.path.join(path, s + ".gif ")
    if name is None:
        name = os.path.basename(path) + ".gif"
    name = os.path.join(path, name)
    cmd_combine = "convert " + combined + name
    call(cmd_combine, shell=True)


path = "./img/scripts/20160707-imagemagick/size=3/"  # directory in front of subdirectories containing .png's
print(convert_subdirectories(path))
#+END_SRC

#+RESULTS:
: None

** 2016-07-08: candidates with islands

#+BEGIN_SRC python :results drawer
from sets import Set

import twodee as td


graphene_cutoff = 1.5 # Angstrom. Should put this somewhere more permanent.

def candidates(atoms, layers, exclude=None, depth=None):
    pos_center = td.center_layer(atoms, layers[0])
    center_atom = td.closest_atom(atoms, pos_center)
    can = [center_atom]
    cans = [can]

    indices = [a.index for a in atoms if a.index not in exclude] #TODO devon: There's a cleaner way to do this. Need something for layers here?

    candidates_loop(atoms, indices, can, cans, center_atom, depth)

    return cans


def candidates_loop(atoms, indices, can, cans, index, depth, step=1):
    layer = [i for i in indices] #TODO devon: Clean up get_neighbors.
    neighbors = td.get_neighbors(atoms, index, layer, graphene_cutoff)

    if len(neighbors) == 1:
        n = neighbors[0]
        if depth is None or step + 1 < depth:
            candidates_loop(atoms, indices, can, cans, n, depth, step+1)
    
    neighbors = [n for n in neighbors if len(neighbors) > 1 and  n not in can]
    for n in neighbors:
        c = [i for i in can]
        c.append(n)
        c.sort()
        if c not in cans:
            cans.append(c)
            if depth is None or step + 1 < depth:
                candidates_loop(atoms, indices, c, cans, n, depth, step+1)
            

unitcell = td.create_base("graphene", layers=1)
size = 3
atoms = td.create_base("graphene", layers=1, size=size)
#td.bp(atoms)
layers = td.layers(atoms)
edges = td.edges(atoms, unitcell)#
cans = candidates(atoms, layers, exclude=edges)

td.bp([cans])
images = []
td.paint_atoms(atoms, edges)
for i, c in enumerate(cans):
    a = atoms.copy()
    td.paint_atoms(a, c, sym="O")
    td.write_image('movies/candidates-islands/size={1}/{0:0>4}'.format(i, size), a)

td.bp()
td.bp(cans)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 [[9], [8, 9], [9, 10], [9, 10, 11], [9, 10, 11, 16], [9, 10, 11, 15, 16], [9, 10, 11, 14, 15, 16], [9, 10, 11, 16, 17], [9, 14], [9, 14, 15], [9, 14, 15, 16], [9, 11, 14, 15, 16], [9, 14, 15, 16, 17]]

 :END:


 #+BEGIN_SRC python
A = [1, 2, 3, 4, 5]
for a in A:    
    if a == 2 or a == 6 and len(A) < 10:
        A.append(6)
print A
 #+END_SRC

 #+RESULTS:
 : [1, 2, 3, 4, 5, 6, 6, 6, 6, 6]

*** from twodee

#+BEGIN_SRC python
def candidates(atoms, edge=None, size=None):
    """Return candidate pore indices combinations."""
    from itertools import combinations

    cans = []
    indices = [a.index for a in atoms if a.index not in edge]

    nblist = NeighborList([graphene_cutoff for i in range(len(atoms))],
                          bothways=True,
                          self_interaction=False)
    nblist.update(atoms)

    def constraint_check(pores):
        for pore in pores:
            remains = [a.index for a in atoms if a.index not in pore]
            if is_connected(nblist, remains) and is_connected(nblist, pore):
                cans.append(pore)

    if size is not None:
        pores = combinations(indices, size)
        constraint_check(pores)
    else:
        for i in range(1, len(indices)):
            pores = combinations(indices, i)
            constraint_check(pores)

    return cans
#+END_SRC

** 2016-07-13: Kill duplicate jobs

*Warning*: This is unsafe since there is no specification of the user. If someone else submits a job in the middle of your batch, you could end up deleting their job.

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from vasp import Vasp
from vasp.vasprc import VASPRC
import numpy as np
VASPRC['queue.walltime'] = '24:00:00'

import twodee as td


#import inspect
#td.bp(inspect.getfile(Vasp))
a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])


name = 'tmp/script/duplicates-kpts={}'
calcs = [Vasp(name.format(k),
            xc='PBE',          # GGA functional type
            encut=520,
            kpts=[k,k,1],
            nsw=0,            # max number of steps to relax
            atoms=atoms)
         for k in np.arange(10,15,2)]

[c.calculate() for c in calcs]

td.bp()
nrg = [calc.potential_energy for calc in calcs]

print('energy = {0} eV'.format(atoms.get_potential_energy()))
td.print_image(name, atoms)
#+END_SRC

#+RESULTS:
:RESULTS:
/home-guest/devonw/hydrogen2D/tmp/script/duplicates-kpts=10 submitted: 1424259.gilgamesh.cheme.cmu.edu
/home-guest/devonw/hydrogen2D/tmp/script/duplicates-kpts=10 submitted: 1424260.gilgamesh.cheme.cmu.edu
/home-guest/devonw/hydrogen2D/tmp/script/duplicates-kpts=12 submitted: 1424261.gilgamesh.cheme.cmu.edu
/home-guest/devonw/hydrogen2D/tmp/script/duplicates-kpts=12 submitted: 1424262.gilgamesh.cheme.cmu.edu
/home-guest/devonw/hydrogen2D/tmp/script/duplicates-kpts=14 submitted: 1424263.gilgamesh.cheme.cmu.edu
/home-guest/devonw/hydrogen2D/tmp/script/duplicates-kpts=14 submitted: 1424264.gilgamesh.cheme.cmu.edu
:END:


#+BEGIN_SRC python
from subprocess import call

start = 1423042
end = 1423147

cmd = "qdel"
for i in range(start, end+1):
    if i % 2 == 1:
        cmd += " {}".format(i)
print(cmd)
#call(cmd, shell=True)
#+END_SRC

#+RESULTS:
: qdel 1423043 1423045 1423047 1423049 1423051 1423053 1423055 1423057 1423059 1423061 1423063 1423065 1423067 1423069 1423071 1423073 1423075 1423077 1423079 1423081 1423083 1423085 1423087 1423089 1423091 1423093 1423095 1423097 1423099 1423101 1423103 1423105 1423107 1423109 1423111 1423113 1423115 1423117 1423119 1423121 1423123 1423125 1423127 1423129 1423131 1423133 1423135 1423137 1423139 1423141 1423143 1423145 1423147

** 2016-07-13: Stats with a loop
From pycon 2016 https://www.youtube.com/watch?v=Iq9DzN6mvYA

#+BEGIN_SRC python
from numpy.random import randint

M = 0
for i in range(50000):
    trials = randint(2, size=30)
    if (trials.sum() >= 22):
        M += 1
p = M / 50000.
print(p)
#+END_SRC

#+RESULTS:
: 0.0085

** 2016-07-19: Walk a directory and create/update an ase-db

My calculations are stored in the vasp/ directory of this project. Let's make a script to collect all calculations and put them into an ase database.

#+BEGIN_SRC python
from ase.db import connect
import os
from vasp import Vasp
from vasp.vasprc import VASPRC
VASPRC['mode'] = None

import twodee as td


def db_update(db_path, dft_path, delete=False, silent=False):
    db = connect(db_path)
    old_size = sum(1 for _ in db.select())

    db_paths = []
    for d in db.select():
        db_paths.append(d.data.path)

    for path in td.calc_paths(dft_path):
        if os.path.abspath(path) in db_paths:
            continue
        calc = Vasp(path)

        if not calc.in_queue() and calc.potential_energy is None:
            for output_file in td.calc_output_files(path):
                dead_file = os.path.join(path, output_file)
                if delete:
                    os.remove(dead_file)
                if not silent:
                    print("Dead output file: {}. Deleted: {}".format(dead_file, delete))
        else:
            calc.write_db(db_path, parser='=',
                        overwrite=False,
                        data={'ctime': calc.get_elapsed_time()})
            if not silent:
                print("Added calc to DB: {}".format(path))

    new_size = sum(1 for _ in db.select())
    added = new_size - old_size
    if not silent:
        print("{} total entries. {} new entries added.".format(new_size, added))

db_update('scripts/2016-07-19/script-20160719-4.db', 'vasp/type=base')
#+END_SRC

#+RESULTS:
: 2 total entries. 0 new entries added.

** DONE 2016-07-19: Graphene equation of state (amp-tutorial)
Build a neural network around the equation of state for graphene in the style of Jake's [[https://github.com/jboes/amp-tutorial][amp-tutorial]].

*** Build the database.

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
import matplotlib.pyplot as plt
from vasp import Vasp

import twodee as td

A = np.linspace(2, 3, 50)
format_name = 'vasp/type=eos/mat=graphene/layers=1/size=1/pore=0/lc={0:0.3f}'
calcs = [Vasp(format_name.format(a)) for a in A]

[calc.write_db('./scripts/2016-07-19/eos.db', parser='=',
               overwrite=False, keys={'dbkey': 0},
               data={'ctime': calc.get_elapsed_time(),
                     'lattice': a})
 for (calc, a) in zip(calcs, A)]
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

*** Plot EOS using the database.

#+BEGIN_SRC python :results drawer
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np

import twodee as td

lc, nrg = [], []
with connect('scripts/2016-07-19/eos.db') as db:
    for d in db.select('dbkey=0'):
        natoms = [d.natoms]
        lc += [d.data.lattice]
        nrg += [d.energy]
lc = np.array(lc)
nrg = np.array(nrg)
nrg_atom = nrg / natoms

plt.plot(lc, nrg_atom)
plt.xlabel('Lattice constant ($\AA$)')
plt.ylabel('Energy (eV/atom)')
plt.title('Graphene Equation of State')
file_path = './tmp/img/vasp/eos/mat=graphene_layers=1_pore=0_eos.png'
td.print_image(file_path, plt)
#+END_SRC

#+RESULTS:
:RESULTS:
[[./img/./tmp/img/vasp/eos/mat=graphene_layers=1_pore=0_eos.png]]
:END:

*** Designate training data

Leave 10% of calculations for testing later.
#+BEGIN_SRC python :results drawer
from ase.db import connect
import random
import numpy as np

db = connect('scripts/2016-07-19/eos.db')

n_ids = []
for d in db.select('dbkey=0'):
    n_ids += [d.id]

n = len(n_ids)
n_train = int(round(n * 0.9))

random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

print("Done")
#+END_SRC

#+RESULTS:
:RESULTS:
Done
:END:

*** Build the network

Generate an initial guess for the parameters to build the neural networks.
#+BEGIN_SRC python :exports none
from amp import Amp
from amp.descriptor import Behler
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing
import os

db = connect('scripts/2016-07-19/eos.db')

images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

for n in [4, 5]:
    wd = 'networks/db=eos0/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)

    calc = Amp(label=wd,
               dblabel='networks/',
               descriptor=Behler(cutoff=6.5),
               regression=NeuralNetwork(hiddenlayers=(2, n)))

    calc.train(images=images,
               data_format='db',
               cores=1,
               energy_goal=10,
               force_goal=None,
               global_search=SimulatedAnnealing(temperature=70,
                                                steps=50),
               extend_variables=False) # Do not use this feature

    os.unlink(os.path.join(wd, 'train-log.txt'))  # TODO devon: was just 'log.txt'
    os.unlink(os.path.join(wd, 'trained-parameters.json'))
#+END_SRC

#+RESULTS:

Build the networks using the previous initial guess.
#+BEGIN_SRC python :results drawer
from amp import Amp
from ase.db import connect
import os

db = connect('scripts/2016-07-19/eos.db')

images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

for n in [4, 5]:
    wd = 'networks/db=eos0/{0}-{0}/'.format(n)

    calc = Amp(load=os.path.join(wd, 'initial-parameters.json'),
               label=wd,
               dblabel='networks/')

    calc.train(images=images,
               data_format='db',
               cores=1,
               energy_goal=1e-3,  # The default energy training goal
               force_goal=None,  # There are no forces in the training data
               global_search=None,  # Already have a good starting point
               extend_variables=False) # Do not use this feature
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

*** Convergence
    
Check for convergence.
#+BEGIN_SRC python :results drawer
import os
import json

print('|Hidden layers|Iteration|Time|Cost Function|Energy RMSE|')
print('|-')

for r, d, f in os.walk('networks/db=eos0/'):
    if 'train-log.txt' in f:
        with open(os.path.join(r, 'train-log.txt'), 'r') as fi:
            v = fi.readlines()[-3].split()

    if 'trained-parameters.json' in f:
        with open(os.path.join(r, 'trained-parameters.json'), 'r') as fi:
            p = json.load(fi)
        n = p['hiddenlayers']
        print('|{}|{}|{}|{}|{}|'.format(n, v[0], v[1], v[2], v[3]))
#+END_SRC

#+RESULTS:
:RESULTS:
| Hidden layers  | Iteration | Time                | Cost Function | Energy RMSE |
|----------------+-----------+---------------------+---------------+-------------|
| {u'C': [2, 4]} |       163 | 2016-07-18T15:57:52 |     4.354e-05 |   9.836e-04 |
| {u'C': [2, 5]} |       222 | 2016-07-18T15:58:01 |     4.444e-05 |   9.937e-04 |
:END:

*** Add to db

Add the neural network results to the database.
#+BEGIN_SRC python :results drawer
from ase.db import connect
from amp import Amp

db = connect('scripts/2016-07-19/eos.db')

calc4 = Amp('./networks/db=eos0/4-4/')
calc5 = Amp('./networks/db=eos0/5-5/')

for d in db.select():
    atoms = db.get_atoms(d.id)

    atoms.set_calculator(calc4)
    e0 = atoms.get_potential_energy()

    atoms.set_calculator(calc5)
    e1 = atoms.get_potential_energy()

    db.update(d.id, nn0=e0, nn1=e1)
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

*** Residual analysis

#+BEGIN_SRC python :results drawer
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

import twodee as td


db = connect('scripts/2016-07-19/eos.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([4, 5]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('dbkey=0')):
	E += [d.energy / d.natoms]
	nnE += [d['nn{}'.format(i)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(5, -0.0075,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(5, -0.009,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.01, 0.01)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./tmp/residuals-1.png')
print("[[" + './tmp/residuals-1.png' + "]]")
#+END_SRC

#+RESULTS:
:RESULTS:
[[./tmp/residuals-1.png]]
:END:

*** Recreate equation of state

#+BEGIN_SRC python :results drawer
import numpy as np
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.db import connect
from amp import Amp
import os
import json
import time
from ase.units import kJ

db = connect('scripts/2016-07-19/eos.db')

for r, d, f in os.walk('./networks/db=eos0/'):
    if 'trained-parameters.json' in f:
        calc = Amp(load=r + '/')

        with open(os.path.join(r, 'trained-parameters.json'), 'r') as fi:
            p = json.load(fi)
        n = p['hiddenlayers'].values()[0]

        nrg, vol, t, lc = [], [], [], []
        for d in db.select(['dbkey=0']):
            atoms = db.get_atoms(d.id)
            atoms.set_calculator(calc)

            time1 = time.time()
            energy = atoms.get_potential_energy()
            time2 = time.time()

            nrg += [energy]
            lc += [d.data.lattice]
            vol += [d.volume]
            t += [(time2 - time1) * 1000]

        vol = np.array(vol)
        nrg = np.array(nrg)
        t = np.array(t)
        lc = np.array(lc)

        # Fit the data to SJEOS
        eos = EquationOfState(vol, nrg)
        v0, e0, B = eos.fit()

        x = np.linspace(vol.min(), vol.max(), 250)

        fig, ax = plt.subplots(figsize=(6, 4))
        ax.scatter(vol, nrg, color='b')
        ax.plot(x, eos.fit0(x**-(1.0 / 3)), 'k-')

        ax.set_xlim(vol.min(), vol.max())
        ax.set_xlabel('Lattic constant [$\AA$]')
        ax.set_ylabel('Potential energy (eV)')

        ax.text(vol.max() - 20, nrg.max(),
                 'V$_{0}$={1:1.1f}'.format('{min}', v0),
                 va='center', ha='left')
        ax.text(vol.max() - 20, nrg.max() - 1,
                 'E$_{0}$={1:1.3f}'.format('{min}', e0),
                 va='center', ha='left')
        ax.text(vol.max() - 20, nrg.max() - 2,
                 'B={0:1.0f}'.format(B  / kJ * 1.0e24),
                 va='center', ha='left')

        plt.tight_layout()
        plt.savefig('./tmp/eos-NN{}.png'.format(n[1]))
        print('[[' + './tmp/eos-NN{}.png'.format(n[1]) + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
[[./tmp/eos-NN4.png]]
[[./tmp/eos-NN5.png]]
:END:

My equation of state comparison
#+BEGIN_SRC python :results drawer
from amp import Amp
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
import os
import json

import twodee as td


# DFT
natoms, lc_dft, nrg_dft = [], [], []
with connect('scripts/2016-07-19/eos.db') as db:
    for d in db.select('dbkey=0'):
        natoms += [d.natoms]
        lc_dft += [d.data.lattice]
        nrg_dft += [d.energy]
lc_dft = np.array(lc_dft)
nrg_dft = np.array(nrg_dft)
nrg_dft_atom = nrg_dft / natoms


# NN
db = connect('scripts/2016-07-19/eos.db')
for r, d, f in os.walk('./networks/db=eos0/'):
    if 'trained-parameters.json' in f:
        calc = Amp(load=r + '/')

        with open(os.path.join(r, 'trained-parameters.json'), 'r') as fi:
            p = json.load(fi)
        n = p['hiddenlayers'].values()[0]

        natoms, lc_nn, nrg_nn = [], [], []
        for d in db.select(['dbkey=0']):
            atoms = db.get_atoms(d.id)
            atoms.set_calculator(calc)

            energy = atoms.get_potential_energy()

            natoms += [d.natoms]
            lc_nn += [d.data.lattice]
            nrg_nn += [energy]

        lc_nn = np.array(lc_nn)
        nrg_nn = np.array(nrg_nn)
        nrg_nn_atom = nrg_nn / natoms


# Plot
plt.plot(lc_dft, nrg_dft_atom, "k--", label="DFT")
plt.plot(lc_nn, nrg_nn_atom, "bo", label="NN")
plt.xlabel('Lattice constant ($\AA$)')
plt.ylabel('Energy (eV/atom)')
plt.title('Graphene Equation of State')
plt.legend()
plt.xlim([min(lc_dft), max(lc_dft)])
file_path = './tmp/img/vasp/eos/mat=graphene_layers=1_pore=0_eos.png'
td.print_image(file_path, plt)
#+END_SRC

#+RESULTS:
:RESULTS:
[[./img/./tmp/img/vasp/eos/mat=graphene_layers=1_pore=0_eos.png]]
:END:

Extrapolation
#+BEGIN_SRC python :results silent :exports none
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
from ase import Atoms, Atom
import matplotlib.pyplot as plt
import collections

D = {}
for calc in ['./networks/db=eos0/4-4/',
             './networks/db=eos0/5-5/']:

    D[calc[-2]] = collections.OrderedDict()
    for x in np.linspace(0.5, 4.0, 1000.):

        a1 = x * np.array([3.0**0.5/2., -1./2., 0.])
        a2 = x * np.array([3.0**0.5/2., 1./2., 0.])
        a3 = np.array([0., 0., 16.])

        atoms = Atoms([Atom('C', 1./2. * a3),
                        Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                        cell=[a1, a2, a3])

        atoms.set_calculator(Amp(calc))

        D[calc[-2]][x] = atoms.get_potential_energy()

res = abs(np.array(D['5'].values()) - np.array(D['4'].values()))

f, ax = plt.subplots(2, 1, sharex=True)
ax[0].plot(D['4'].keys(), D['4'].values(), 'b', lw=2, label='4-4')
ax[0].plot(D['5'].keys(), D['5'].values(), 'r', lw=2, label='5-5')
ax[0].plot([0.85, 0.85], [2, -6], 'k--')
ax[0].plot([2.1, 2.1], [2, -6], 'k--')
ax[0].set_ylabel('Potential energy (eV)')
ax[0].set_xlim(0.6, 2.5)
ax[0].legend(loc='best')

ax[1].plot([0.85, 0.85], [0, 0.5], 'k--')
ax[1].plot([2.07, 2.1], [0, 0.5], 'k--')
ax[1].plot(D['4'].keys(), res, 'k', lw=2)
ax[1].set_ylabel('NN energy difference (eV)')
ax[1].set_ylim(0, 0.5)
ax[1].set_xlabel('Strain/stretch factor (%)')
plt.tight_layout(w_pad=0.0)
plt.savefig('./tmp/app-eos.png')
#+END_SRC

[[./tmp/app-eos.png]]

** 2016-07-21: Make twodee and td a module named twodee

Move utility code into the [[file+sys:./twodee/][twodee module]].

#+BEGIN_SRC python
print(list(globals()))

import twodee as td

print("")
print(list(globals()))

print("")
td.bp("Test")
#+END_SRC


#+RESULTS:
: ['__builtins__', '__name__', '__file__', '__doc__', '__package__']
: 
: ['__builtins__', '__file__', '__package__', 'GInitiallyUnowned', '__name__', 'td', '__doc__']
: 
: Test

** 2016-07-21: Check for duplicate entries in ase-db

Eliminate any duplicate entries in an ase-db.

Some light dictionary learning:
#+BEGIN_SRC python :results drawer
dic = {'Name1': 'Zara', 'Age': 7, 'Name2': 'Zara'}

keep = {}
for key, value in dic.items():
    if value not in keep.values():
        keep[key] = value

for key in dic.keys():
    if key not in keep:
        del dic[key]

for key in dic.keys():
    print(key)
for key in dic.values():
    print(key)

print(dic)
print(keep)
#+END_SRC

#+RESULTS:
:RESULTS:
Age
Name2
7
Zara
{'Age': 7, 'Name2': 'Zara'}
{'Age': 7, 'Name2': 'Zara'}
:END:

The main show:
#+BEGIN_SRC python
from ase.db import connect

import twodee as td


def db_duplicates(db_path, delete=False, reverse=False, silent=False):
    """Return duplicate IDs based on calculation paths."""
    db = connect(db_path)
    old_size = sum(1 for _ in db.select())

    db_paths = {}
    for d in db.select():
        db_paths[d.id] = d.data.path

    keep = {}
    items = reversed(db_paths.items()) if reverse else db_paths.items()
    for key, value in items:
        if value not in keep.values():
            keep[key] = value

    dup_keys = []
    for key in db_paths.keys():
        if key not in keep:
            if not silent:
                print("Duplicate: id={}: value={}".format(key, db_paths[key]))
            dup_keys.append(key)

    if delete: 
        db.delete(dup_keys)

    new_size = sum(1 for _ in db.select())
    deleted =  old_size - new_size
    if not silent:
        print("{} total entries. {} new entries deleted.".format(new_size, deleted))

    return dup_keys

db_duplicates('database/script-20160719.db', delete=False, reverse=False, silent=False)
#+END_SRC

#+RESULTS:
: 519 total entries. 0 new entries deleted.
: []

** 2016-07-21: Find a broken Vasp file in a directory

Find broken calculations in a nested directory.

#+BEGIN_SRC python :results drawer
import os
import re
import shutil
import sys
from vasp import Vasp
from vasp.vasprc import VASPRC
VASPRC['mode'] = None

import twodee as td

def broken_calcs(dft_path, delete=False, silent=False):
    """Return a list of broken calculation paths."""

    # Don't print to stdout for awhile. Vasp() prints error traces.
    stdout = sys.stdout
    f = open(os.devnull, 'w')
    sys.stdout = f

    broken_dirs = []
    for path in td.calc_paths(dft_path):
        try:
            calc = Vasp(path)
        except:
            broken_dirs.append(pwd[0])

    sys.stdout = stdout
    if not silent:
        if broken_dirs:
            print("Broken directories:")
            for b in broken_dirs:
                print("    {}".format(b))
        else:
            print("No broken directories found.")

    # Recursively delete the broken directories
    if delete:
        for b in broken_dirs:
            shutil.rmtree(b)
    
    return broken_dirs

td.bp(broken_calcs('vasp/type=point/mat=graphene/layers=1/size=4/pore=4', silent=False))
#+END_SRC

#+RESULTS:
:RESULTS:
No broken directories found.
[]
:END:

** 2016-07-22: candidates with json

#+BEGIN_SRC python :results drawer
import json
import os.path
from pprint import pprint
import time

import twodee as td

def candidates(mat='graphene', layers=1, size=1, pores=None,
               json_path='data/candidates.json', silent=False, overwrite=False):
    """Return candidate pore indices combinations for all pores."""
    if os.path.isfile(str(json_path)) and not overwrite:
        with open(json_path) as data_file:
            data = json.load(data_file)
    else:
        overwrite = True
        data = {'calculated': []}
    calculated = data['calculated']

    unitcell = td.create_base(mat, layers=layers)
    atoms = td.create_base(mat, layers=layers, size=size)

    edges = td.edges(atoms, unitcell)
    indices = [a.index for a in atoms if a.index not in edges]
    if pores is None:
        pores = range(len(indices)+1)

    def is_calculated(calculated, size, pore):
        for c in calculated:
            if c['size'] == size and c['pore'] == pore:
                return [c['candidates'], c['time']]
        return [None, None]

    times = []
    cans = []
    retrievals = []
    for pore in pores:
        if not overwrite:
            (c, t) = is_calculated(calculated, size, pore)
        else:
            c = None

        if c:
            cans.append(c)
            times.append(t)
            retrievals.append("From file")
            continue
        else:
            start = time.time()
            can = td.candidates2(atoms, edge=edges, pore_size=pore)
            end = time.time()

            cans.append(can)
            times.append(end - start)
            retrievals.append("Calculated")
            calc = {'mat': mat,
                    'layers': layers,
                    'size': size,
                    'pore': pore,
                    'candidates': can,
                    'time': times[-1]}
            calculated.append(calc)

    if json_path is not None:
        json.dumps({'calculated': [calculated]})
        with open(json_path, 'w') as data_file:
            json.dump(data, data_file)

    if not silent:
        print("| Graphene size | Pore size | # of candidates | Algo. time | Retrieval |")
        print("| (unitcell repititions) | (# carbons) | | (seconds) | |")
        print("|-----")
        for (p, c, t, r) in zip(pores, cans, times, retrievals):
            print("| {} | {} | {} | {:0.2f} | {} |".format(size, p, len(c), t, r)) 

        tot_num = 0
        tot_time = 0
        for (c, t) in zip(cans, times):
            tot_num += len(c)
            tot_time += t
        print("Total number of candidates: {}. Total time: {:0.2f} sec".format(tot_num, tot_time))
    
    return cans

candidates(mat='graphene', layers=1, size=4, pores=None,
           silent=False, overwrite=False)
#+END_SRC

 #+RESULTS:
 :RESULTS:
 |          Graphene size |   Pore size | # of candidates | Algo. time | Retrieval |
 | (unitcell repititions) | (# carbons) |                 |  (seconds) |           |
 |------------------------+-------------+-----------------+------------+-----------|
 |                      4 |           0 |               1 |       0.05 | From file |
 |                      4 |           1 |              18 |       0.09 | From file |
 |                      4 |           2 |              21 |       0.38 | From file |
 |                      4 |           3 |              32 |       1.75 | From file |
 |                      4 |           4 |              54 |       5.95 | From file |
 |                      4 |           5 |             102 |      15.78 | From file |
 |                      4 |           6 |             183 |      32.88 | From file |
 |                      4 |           7 |             310 |      52.57 | From file |
 |                      4 |           8 |             502 |      67.40 | From file |
 |                      4 |           9 |             730 |      68.57 | From file |
 |                      4 |          10 |             954 |      58.29 | From file |
 |                      4 |          11 |            1102 |      39.15 | From file |
 |                      4 |          12 |            1061 |      21.29 | From file |
 |                      4 |          13 |             808 |       9.89 | From file |
 |                      4 |          14 |             460 |       3.35 | From file |
 |                      4 |          15 |             186 |       0.90 | From file |
 |                      4 |          16 |              53 |       0.22 | From file |
 |                      4 |          17 |              10 |       0.07 | From file |
 |                      4 |          18 |               1 |       0.05 | From file |
 Total number of candidates: 6588. Total time: 378.64 sec
 :END:

** 2016-07-22: Run python script from queue

Script 1 (super basic) to run on queue:
#+BEGIN_SRC python :tangle ./queue/script-20160722-1.py
#!/usr/bin/env python

a = 4 + 2
print(a)
#+END_SRC

Script 2 to run:
#+BEGIN_SRC python :tangle ./queue/script-20160722-2.py
#!/usr/bin/env python
import twodee as td

#atoms = td.create_base('graphene', layers=1, size=3)
cans = td.candidates(mat='graphene', layers=1, size=3, pores=None, silent=False)
#+END_SRC


Queue caller:
#+BEGIN_SRC python
import os
import subprocess
import time

import twodee as td


def qsub(file_path):
    cwd = os.getcwd()
    wd = os.path.dirname(os.path.realpath(file_path))
    file_name = os.path.basename(file_path)
    os.chmod(file_path, 0777)

    cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -o {0}
#PBS -e {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=2GB
#PBS -joe
cd $PBS_O_WORKDIR
{1}
#end'''.format(wd, file_path)

    submit_path = os.path.join(wd, 'submit.sh')
    with open(submit_path, 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', submit_path])
    time.sleep(5)
    os.remove(submit_path)


qsub('./queue/script-20160722-2.py')
#+END_SRC

#+RESULTS:
: 1428308.gilgamesh.cheme.cmu.edu

** 2016-07-23: Queue candidate algorithm

#+BEGIN_SRC python
import twodee as td

sizes = [5]#, 6, 7]
for s in sizes:
    path = "./queue/candidates/{0}/cans={0}.py".format(s)
    prog= '''#!/usr/bin/env python
import twodee as td


unitcell = td.create_base("graphene", layers=1)
size = {}
atoms = td.create_base("graphene", layers=1, size=size)

edges = td.edges(atoms, unitcell)
indices = [a.index for a in atoms if a.index not in edges]

# Get pore candidates
pore_sizes = range(len(indices)+1)
for p in pore_sizes:
    cans = td.candidates(mat="graphene", layers=1, size=size, pores=[p], json_path="data/candidates.json", write=True)
'''.format(s)

    with open(path, 'w') as f:
        f.write(prog)
    td.qsub(path)
#+END_SRC

#+RESULTS:
: 1440203.gilgamesh.cheme.cmu.edu

** 2016-07-24: Get source code to queue submit file

#+BEGIN_SRC python
import re
import inspect

def test_func():
    """Testing..."""
    #!/usr/bin/env python
    import twodee as td

    #print("hello")
    return 1
#    cans = td.candidates(mat='graphene', layers=1, size=3,
#                         pores=None, silent=False)

#me = test_func()
#print(__file__)
print(test_func)
print(inspect.getsource(test_func))
#+END_SRC

#+RESULTS:

** TODO 2016-07-24: Create a plot that shows neural network quality

Thinking a 3 plot subplot in a 2x2 grid. The top row will be occupied by the errors of network vs training and test.
1. Errors against training and test data
2. 

#+BEGIN_SRC python

#+END_SRC

** 2016-07-27: qsub decorator

Incomplete

#+BEGIN_SRC python :tangle tester.py
#!/usr/bin/env python

import ast, inspect
import dis
#from dill.source import getsource # didn't work with babel. worked with python -i. reads from interactive history.
import compiler
from functools import wraps
import sys

def qsub(path):
    def qsub_decorator(script):
        @wraps(script)
        def wrapper(*args, **kwargs):
            print("Submit to: " + path)
            print("#!/usr/bin/env python")
            print(script(*args, **kwargs))
            # stuck here. how to turn script into a submittable file?
            return
        return wrapper
    return qsub_decorator



@qsub("my_path/submit.py")
def add(x, y):
    """My docstring."""
    return x + y

    
add(2, 3)
#+END_SRC

#+RESULTS:
: 91
: Submit to: my_path/submit.py
: #!/usr/bin/env python
: 5

** 2016-07-28: Jinja2 template queue submission
*** DONE Toy template example
Add "/foobar" to a printed string.

#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/template_toy.py
#!/usr/bin/env python
print("{{ path }}" + "/foobar")
#+END_SRC


#+BEGIN_SRC python :results output org drawer
from jinja2 import Environment, FileSystemLoader
import os

pwd = os.path.dirname(os.path.abspath(__file__))
env = Environment(loader=FileSystemLoader(pwd))
template_path = 'scripts/2016-07-28/template_toy.py'
template = env.get_template(template_path)

exec(template.render(path=pwd))
#+END_SRC

#+RESULTS:
:RESULTS:
/home-guest/devonw/hydrogen2D/foobar
:END:

*** DONE Iteration 0: Amp runner template

#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/template_amp.py
#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Behler
from amp.regression import NeuralNetwork
from ase.db import connect
import os

db_path = "{{ db_path }}"
nn_dir = "{{ nn_dir }}"
nn_dir = os.path.join(nn_dir, "")
select = "{{ select }}"
cutoff = {{ cutoff }}
h_layers = {{ h_layers }}

db = connect(db_path)

images = []
for d in db.select(select):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

desc = Behler(cutoff=cutoff)
reg = NeuralNetwork(hiddenlayers=h_layers)
calc = Amp(label=nn_dir,
           descriptor=desc,
           regression=reg)

calc.train(images=images,
           data_format='db',
           cores=1,
           energy_goal=1e-3,
           force_goal=None,
           global_search=None,
           extend_variables=False)

print("Training completed")
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python :results output org drawer
from jinja2 import Environment, FileSystemLoader
import os
import twodee as td

pwd = os.path.dirname(os.path.abspath(__file__))
env = Environment(loader=FileSystemLoader(pwd))
template_path = 'scripts/2016-07-28/template_amp.py'
template = env.get_template(template_path)

db_path = 'scripts/2016-07-28/test_db.db'
select = 'train_set=True'
cutoff = 6.5
h_layers = [2, 3]
nodes = [2, 3]

for h in h_layers:
    for n in nodes:
        db_dir = os.path.dirname(db_path)
        framework = tuple([n]*h)
        framework_str = "-".join([str(f) for f in framework])
        nn_dir = os.path.join(db_dir, framework_str)

        if os.path.exists(os.path.join(nn_dir, 'submit.py')):
            print('{0} already submitted.'.format(framework_str))
            continue
        if not os.path.exists(nn_dir):
            os.makedirs(nn_dir)

        code = template.render(db_path=db_path, nn_dir=nn_dir,
                               select=select, cutoff=cutoff,
                               h_layers=framework)

        submit_file = os.path.join(nn_dir, 'submit.py')
        with open(submit_file, 'w') as f:
            f.write(code)

        td.qsub(submit_file, walltime="10:00:00")
        print('{0} submitted.'.format(framework_str))
#+END_SRC

#+RESULTS:
:RESULTS:
1432761.gilgamesh.cheme.cmu.edu
1432762.gilgamesh.cheme.cmu.edu
1432763.gilgamesh.cheme.cmu.edu
1432764.gilgamesh.cheme.cmu.edu
2-2 submitted.
3-3 submitted.
2-2-2 submitted.
3-3-3 submitted.
:END:

**** Example sybmit.py output
It's useful to grab the completed template and see if it runs without errors.

#+BEGIN_SRC python :results output org drawer
#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Behler
from amp.regression import NeuralNetwork
from ase.db import connect
import os
import twodee as td

db_path = "scripts/2016-07-28/test_validation.db"
nn_dir = "scripts/2016-07-28/8-8"
nn_dir = os.path.join(nn_dir, "")
select = "train_set=True"
cutoff = 6.5
h_layers = (8, 8)

db = connect(db_path)

images = []
for d in db.select(select):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

desc = Behler(cutoff=cutoff)
reg = NeuralNetwork(hiddenlayers=h_layers)
calc = Amp(label=nn_dir,
           descriptor=desc,
           regression=reg)

calc.train(images=images,
           data_format='db',
           cores=1,
           energy_goal=1e-3,
           force_goal=None,
           global_search=None,
           extend_variables=False)

print("Done")
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

*** DONE Iteration 1: More generic Amp runner template

#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/template_amp_generic1.py
#!/usr/bin/env python
from amp import Amp
from ase.db import connect

db_path = "{{ db_path }}"
select = "{{ select }}"

db = connect(db_path)

images = []
for d in db.select(select):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

from amp.descriptor import {{ desc_type }}
desc = {{ desc_type }}(**{{ desc_args }})

from amp.regression import {{ reg_type }}
reg = {{ reg_type }}(**{{ reg_args }})

calc = Amp(descriptor=desc,
           **{{ amp_args }})

calc.train(images=images,
           **{{ train_args }})

print("Training completed")
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python :results output org drawer
from jinja2 import Environment, FileSystemLoader
import os
import twodee as td

pwd = os.path.dirname(os.path.abspath(__file__))
env = Environment(loader=FileSystemLoader(pwd))
template_path = 'scripts/2016-07-28/template_amp_generic1.py'
template = env.get_template(template_path)

db_path = 'scripts/2016-07-28/test_db.db'
select = 'train_set=True'
cutoff = 6.5
h_layers = [2, 3]
nodes = [2, 3]

for h in h_layers:
    for n in nodes:
        db_dir = os.path.dirname(db_path)
        framework = tuple([n]*h)
        framework_str = "-".join([str(f) for f in framework])
        nn_dir = os.path.join(db_dir, "generic1", framework_str, "")

        if os.path.exists(os.path.join(nn_dir, 'submit.py')):
            print('{0} already submitted.'.format(framework_str))
            continue
        if not os.path.exists(nn_dir):
            os.makedirs(nn_dir)

        desc_type = "Behler"
        desc_args = {"cutoff": 6.5}
        reg_type = "NeuralNetwork"
        reg_args = {"hiddenlayers": framework}
        amp_args = {"label": nn_dir}
        train_args = {"data_format": 'db',
                      "cores": 1,
                      "energy_goal": 1e-3,
                      "force_goal": None,
                      "global_search": None,
                      "extend_variables": False}

        code = template.render(db_path=db_path, select=select,
                               desc_type=desc_type, desc_args=desc_args,
                               reg_type=reg_type, reg_args=reg_args,
                               amp_args=amp_args, train_args=train_args)

        submit_file = os.path.join(nn_dir, 'submit.py')
        with open(submit_file, 'w') as f:
            f.write(code)

        td.qsub(submit_file, walltime="10:00:00")
        print('{0} submitted.'.format(framework_str))
#+END_SRC

#+RESULTS:
:RESULTS:
1432765.gilgamesh.cheme.cmu.edu
1432766.gilgamesh.cheme.cmu.edu
1432767.gilgamesh.cheme.cmu.edu
1432768.gilgamesh.cheme.cmu.edu
2-2 submitted.
3-3 submitted.
2-2-2 submitted.
3-3-3 submitted.
:END:

*** DONE Iteration 2: Combining template

Header subtemplate
#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/templates/header.py
#!/usr/bin/env python
#+END_SRC

Footer subtemplate
#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/templates/footer.py
print({{ output }})
print("End of script reached successfully.")
#+END_SRC

Database subtemplate
#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/templates/ase_db_get.py
from ase.db import connect

db_path = "{{ db_path }}"
select = "{{ select }}"

db = connect(db_path)

images = []
for d in db.select(select):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]
#+END_SRC

Amp subtemplate has dependency on variable name for images
#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/templates/amp.py
from amp import Amp
from amp.descriptor import {{ desc_type }}
from amp.regression import {{ reg_type }}

desc = {{ desc_type }}(**{{ desc_args }})

reg = {{ reg_type }}(**{{ reg_args }})

calc = Amp(descriptor=desc,
           **{{ amp_args }})
#+END_SRC

Training subtemplate
#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/templates/amp_train.py
train_args = {{ train_args }}

{% if gs_type %}
# Define global search
from amp import {{ gs_type }}
gs = {{ gs_type }}(**{{ gs_args }})
train_args['global_search'] = gs

{% endif %}
calc.train(images=images,
           **train_args)
#+END_SRC

Remove params subtemplate
I think theres room for improvement here.
#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/templates/amp_remove_params.py
import os
wd = "{{ workdir }}"
os.unlink(os.path.join(wd, 'train-log.txt'))
os.unlink(os.path.join(wd, 'trained-parameters.json'))
#+END_SRC


Runner
#+BEGIN_SRC python :results output org drawer
from jinja2 import Environment, FileSystemLoader
import os
import twodee as td

pwd = os.path.dirname(os.path.abspath(__file__))
env = Environment(loader=FileSystemLoader(pwd))
template_path = 'scripts/2016-07-28/templates'
header = env.get_template(os.path.join(template_path, "header.py"))
footer = env.get_template(os.path.join(template_path, "footer.py"))
ase_db_get = env.get_template(os.path.join(template_path, "ase_db_get.py"))
amp = env.get_template(os.path.join(template_path, "amp.py"))
amp_train = env.get_template(os.path.join(template_path, "amp_train.py"))
amp_remove_params = env.get_template(os.path.join(template_path, "amp_remove_params.py"))

db_path = 'scripts/2016-07-28/test_db.db'
select = 'train_set=True'
cutoff = 6.5
h_layers = [2, 3]
nodes = [2, 3]

for h in h_layers:
    for n in nodes:
        db_dir = os.path.dirname(db_path)
        framework = tuple([n]*h)
        framework_str = "-".join([str(f) for f in framework])
        nn_dir = os.path.join(db_dir, "generic2", framework_str, "")

        if os.path.exists(os.path.join(nn_dir, 'submit.py')):
            print('{0} already submitted.'.format(framework_str))
            continue
        if not os.path.exists(nn_dir):
            os.makedirs(nn_dir)

        desc_type = "Behler"
        desc_args = {"cutoff": 6.5}
        reg_type = "NeuralNetwork"
        reg_args = {"hiddenlayers": framework}
        amp_args = {"label": nn_dir}

        gs_type = "SimulatedAnnealing"
        gs_args = {"temperature": 70, "steps": 50}
        train_args1 = {"data_format": 'db',
                       "cores": 1,
                       "energy_goal": 10,
                       "force_goal": None,
                       "extend_variables": False}

        train_args2 = {"data_format": 'db',
                       "cores": 1,
                       "energy_goal": 1e-3,
                       "force_goal": None,
                       "extend_variables": False}
        output = "\"Training completed.\""

        codes = []
        codes.append(header.render())
        codes.append(ase_db_get.render(db_path=db_path, select=select))
        codes.append(amp.render(desc_type=desc_type,
                                desc_args=desc_args,
                                reg_type=reg_type,
                                reg_args=reg_args,
                                amp_args=amp_args))
        codes.append(amp_train.render(train_args=train_args1,
                                      gs_type=gs_type,
                                      gs_args=gs_args))
        codes.append(amp_remove_params.render(workdir=nn_dir))
        codes.append(amp_train.render(train_args=train_args2))
        codes.append(footer.render(output=output))
        code = "\n\n".join(codes)

        submit_file = os.path.join(nn_dir, 'submit.py')
        with open(submit_file, 'w') as f:
            f.write(code)

        td.qsub(submit_file, walltime="10:00:00")
        print('{0} submitted.'.format(framework_str))
#+END_SRC

#+RESULTS:
:RESULTS:
1432779.gilgamesh.cheme.cmu.edu
1432780.gilgamesh.cheme.cmu.edu
1432781.gilgamesh.cheme.cmu.edu
1432782.gilgamesh.cheme.cmu.edu
2-2 submitted.
3-3 submitted.
2-2-2 submitted.
3-3-3 submitted.
:END:

*** TODO Iteration 3: Moving functions into twodee
** TODO 2016-08-03: LAMMPS calculation setup

#+BEGIN_SRC python :results output org drawer
import lammps

#+END_SRC

#+RESULTS:
:RESULTS:
:END:

** TODO 2016-08-04: Select non-degenerate calculations from the db

#+BEGIN_SRC python :results output org drawer
from ase.db import connect
from ase.calculators.emt import EMT
import twodee as td


atoms = td.create_base("graphene", layers=1, size=5)


nrgs = set()
a = td.make_pore(atoms, [14, 15])
a.set_calculator(EMT())
nrg = round(a.get_potential_energy(), 4)
print(nrg)

a = td.make_pore(atoms, [21, 22])
a.set_calculator(EMT())
nrg = round(a.get_potential_energy(), 4)
atoms.set_calculator(SinglePointCalculator(atoms, energy=nrg))
print(nrg)
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

** 2016-08-10: Add estimate_4.db into master

#+BEGIN_SRC python :results output org drawer :tangle ./scripts/2016-08-10/merge_dbs.py
from ase.db import connect
import os
import shutil
import twodee as td

wd = "/home-guest/devonw/hydrogen2D/"
master = os.path.join(wd, 'database/master.db')
temp_master = os.path.join(wd, 'tmp/test_master.db')
shutil.copyfile(master, temp_master)

estimate = os.path.join(wd, 'scripts/2016-08-10/estimate_4.db')
temp_estimate = os.path.join(wd, 'tmp/test_estimate.db')
shutil.copyfile(estimate, temp_estimate)

db_master = connect(temp_master)
db_estimate = connect(temp_estimate)

num_calcs = sum([1 for d in db_master.select()])
print("Master: {}".format(num_calcs))

n = 0
for de in db_estimate.select():
    atoms = db_estimate.get_atoms(de.id)
    keys = de.key_value_pairs
    db_master.write(atoms, **keys)
    n += 1
    if n % 500 == 0:
        print("... " + str(n) + " added in total.")

num_calcs = sum([1 for d in db_master.select()])
print("Master: {}".format(num_calcs))
#+END_SRC

#+RESULTS:
:RESULTS:
Master: 745
...4added.
:END:

* Twodee

Module to help me write code in this project. This header serves as a testing ground for the module.

** ase_utils
*** candidates
    
#+BEGIN_SRC python :results drawer
import twodee as td

cans = td.candidates(mat='graphene', layers=1, size=4, pores=None,
                     json_path='data/candidates.json', silent=False,
                     write=True, overwrite_file=False)
#+END_SRC

#+RESULTS:
*** candidates_combos

 #+BEGIN_SRC python :results drawer
import twodee as td
import time

unitcell = td.create_base("graphene", layers=1)
size = 4
atoms = td.create_base("graphene", layers=1, size=size)

edges = td.edges(atoms, unitcell)
indices = [a.index for a in atoms if a.index not in edges]

#pore_sizes = range(len(indices)+1)
#pore_sizes = [0, 1, 2, 3, 4, 5]
pore_sizes = [0, 1, 2, 3, 4, 5]
times = []
cans = []
for pore_size in pore_sizes:
    start = time.time()
    cans.append(td.candidates(mat='graphene',
                              layers=1,
                              size=4,
                              pores=[pore_size]))
    end = time.time()
    times.append(end - start)

# Image generator for .gifs
#    images = []
#    td.paint_atoms(atoms, edges)
#    for i, c in enumerate(cans):
#        a = atoms.copy()
#        td.paint_atoms(a, c, sym="O")
#        file_name = 'tmp/size={1}/pore={2}/{0:0>4}'
#        file_name = file_name.format(i, size, pore_size)
#        td.write_image(file_name, a)


print("| Graphene size | Pore size | # of candidates | Algo. time |")
print("| (unitcell repititions) | (# carbons) | | (seconds) |")
for (p, c, t) in zip(pore_sizes, cans, times):
    print("| {} | {} | {} | {:0.2f} |".format(size, p, len(c), t)) 

tot_num = 0
tot_time = 0
for (c, t) in zip(cans, times):
    tot_num += len(c)
    tot_time += t
print("Total number of candidates: {}. Total time: {:0.2f} sec".format(tot_num, tot_time))
 #+END_SRC

#+RESULTS:
:RESULTS:
1
18
153
816
3060
8568
|          Graphene size |   Pore size | # of candidates | Algo. time |
| (unitcell repititions) | (# carbons) |                 |  (seconds) |
|                      4 |           0 |               1 |       0.53 |
|                      4 |           1 |               1 |       0.57 |
|                      4 |           2 |               1 |       0.86 |
|                      4 |           3 |               1 |       2.40 |
|                      4 |           4 |               1 |       6.53 |
|                      4 |           5 |               1 |      16.77 |
Total number of candidates: 6. Total time: 27.66 sec
:END:
 

 |          Graphene size |   Pore size | Old algo. time | New algo. time |
 | (unitcell repititions) | (# carbons) |      (seconds) |      (seconds) |
 |------------------------+-------------+----------------+----------------|
 |                      3 |           0 |                |           0.03 |
 |                      3 |           1 |            0.1 |           0.03 |
 |                      3 |           2 |            0.3 |           0.05 |
 |                      3 |           3 |            0.5 |           0.07 |
 |                      3 |           4 |            0.6 |           0.07 |
 |                      3 |           5 |            0.5 |           0.06 |
 |                      3 |           6 |            0.2 |           0.04 |
 |                      3 |           7 |            0.1 |           0.03 |
 |                      3 |           8 |                |           0.03 |
 |                      4 |           0 |                |           0.05 |
 |                      4 |           1 |            0.7 |           0.09 |
 |                      4 |           2 |            5.3 |           0.37 |
 |                      4 |           3 |           26.9 |           1.69 |
 |                      4 |           4 |           95.1 |           5.87 |
 |                      4 |           5 |                |          15.58 |



**** Results - size=2

 |          Graphene size |   Pore size | # of candidates | Algo. time |
 | (unitcell repititions) | (# carbons) |                 |  (seconds) |
 |                      2 |           0 |               1 |       0.01 |
 |                      2 |           1 |               2 |       0.01 |
 |                      2 |           2 |               1 |       0.01 |
 Total number of candidates: 4. Total time: 0.04 sec

**** Results - size=3

 |          Graphene size |   Pore size | # of candidates | Algo. time |
 | (unitcell repititions) | (# carbons) |                 |  (seconds) |
 |                      3 |           0 |               1 |       0.03 |
 |                      3 |           1 |               8 |       0.03 |
 |                      3 |           2 |               8 |       0.05 |
 |                      3 |           3 |              10 |       0.07 |
 |                      3 |           4 |              12 |       0.07 |
 |                      3 |           5 |              14 |       0.06 |
 |                      3 |           6 |              13 |       0.04 |
 |                      3 |           7 |               6 |       0.03 |
 |                      3 |           8 |               1 |       0.03 |
 Total number of candidates: 73. Total time: 0.41 sec

**** Results - size=4

 |          Graphene size |   Pore size | # of candidates | Algo. time |
 | (unitcell repititions) | (# carbons) |                 |  (seconds) |
 |                      4 |           0 |               1 |       0.05 |
 |                      4 |           1 |              18 |       0.09 |
 |                      4 |           2 |              21 |       0.38 |
 |                      4 |           3 |              32 |       1.70 |
 |                      4 |           4 |              54 |       5.97 |
 |                      4 |           5 |             102 |      15.69 |
 |                      4 |           6 |             183 |      32.08 |
 |                      4 |           7 |             310 |      51.44 |
 |                      4 |           8 |             502 |      66.04 |
 |                      4 |           9 |             730 |      67.64 |
 |                      4 |          10 |             954 |      57.04 |
 |                      4 |          11 |            1102 |      38.68 |
 |                      4 |          12 |            1061 |      21.33 |
 |                      4 |          13 |             808 |       9.32 |
 |                      4 |          14 |             460 |       3.28 |
 |                      4 |          15 |             186 |       0.89 |
 |                      4 |          16 |              53 |       0.22 |
 |                      4 |          17 |              10 |       0.07 |
 |                      4 |          18 |               1 |       0.05 |
 Total number of candidates: 6588. Total time: 371.95 sec

*** candidates_submit

#+BEGIN_SRC python :results output org drawer
import twodee as td

cans = td.candidates(mat='graphene', layers=1, size=5, pores=[15],
                     json_path='data/candidates.json', silent=False,
                     write=True, overwrite_file=False)
#+END_SRC

#+RESULTS:
:RESULTS:
| Graphene size          | Pore size   | # of candidates | Algo. time | Retrieval |
| (unitcell repititions) | (# carbons) |                 | (seconds)  |           |
|------------------------+-------------+-----------------+------------+-----------|
| 5                      | 10          |            9819 | 231889.80  | From file |
Total number of candidates: 9819. Total time: 231889.80 sec
:END:




#+BEGIN_SRC python :results code
from jinja2 import Environment, PackageLoader
import os
import shutil

import twodee as td

size = 5
mat = "graphene"
layers = 1

env = Environment(loader=PackageLoader('twodee', 'templates'))
template = env.get_template("candidates.py")

unitcell = td.create_base(mat, layers=layers)
atoms = td.create_base(mat, layers=layers, size=size)

edge = td.edges(atoms, unitcell)
indices = [a.index for a in atoms if a.index not in edge]

#pore_sizes = range(10, len(indices)+1)
pore_sizes = range(13, 19+1)
for ps in pore_sizes:
    # Make submission directory
    queue_path = 'queue/candidates/size={0}-pore={1}/'.format(size, ps)
    if not os.path.exists(queue_path):
        os.makedirs(queue_path)

    # Copy json file
    json_path = os.path.join(queue_path, 'size={0}-pore={1}.json'.format(size, ps))
    shutil.copyfile('data/candidates.json', json_path)

    args = {'work_dir': os.getcwd(),
            'json_path': json_path,
            'size': size,
            'pore_size': [ps]}

    code = template.render(**args)

    submit_file = os.path.join(queue_path, 'cand-size={0}-pore={1}.py'.format(size, ps))

    with open(submit_file, 'w') as f:
        f.write(code)

    td.qsub(submit_file, mem="4GB")
    print('{0} submitted.'.format(submit_file))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC python
1447009.gilgamesh.cheme.cmu.edu
1447010.gilgamesh.cheme.cmu.edu
1447011.gilgamesh.cheme.cmu.edu
1447012.gilgamesh.cheme.cmu.edu
1447013.gilgamesh.cheme.cmu.edu
1447014.gilgamesh.cheme.cmu.edu
1447015.gilgamesh.cheme.cmu.edu
Job submitted.
queue/candidates/size=5-pore=13/cand-size=5-pore=13.py submitted.
Job submitted.
queue/candidates/size=5-pore=14/cand-size=5-pore=14.py submitted.
Job submitted.
queue/candidates/size=5-pore=15/cand-size=5-pore=15.py submitted.
Job submitted.
queue/candidates/size=5-pore=16/cand-size=5-pore=16.py submitted.
Job submitted.
queue/candidates/size=5-pore=17/cand-size=5-pore=17.py submitted.
Job submitted.
queue/candidates/size=5-pore=18/cand-size=5-pore=18.py submitted.
Job submitted.
queue/candidates/size=5-pore=19/cand-size=5-pore=19.py submitted.
#+END_SRC


*** candidates - leaves islands

 #+BEGIN_SRC python :results drawer
from sets import Set

import twodee as td


graphene_cutoff = 1.5 # Angstrom. Should put this somewhere more permanent.

def candidates(atoms, layers, exclude=None, depth=None):
    pos_center = td.center_layer(atoms, layers[0])
    center_atom = td.closest_atom(atoms, pos_center)
    can = [center_atom]
    cans = [can]

    indices = [a.index for a in atoms if a.index not in exclude] #TODO devon: There's a cleaner way to do this. Need something for layers here?

    candidates_loop(atoms, indices, can, cans, center_atom, depth)

    return cans


def candidates_loop(atoms, indices, can, cans, index, depth, step=1):
    layer = [i for i in indices] #TODO devon: Clean up get_neighbors.
    neighbors = td.get_neighbors(atoms, index, layer, graphene_cutoff)

    if len(neighbors) == 1:
        n = neighbors[0]
        if depth is None or step + 1 < depth:
            candidates_loop(atoms, indices, can, cans, n, depth, step+1)
    
    neighbors = [n for n in neighbors if len(neighbors) > 1 and  n not in can]
    for n in neighbors:
        c = [i for i in can]
        c.append(n)
        c.sort()
        if c not in cans:
            cans.append(c)
            if depth is None or step + 1 < depth:
                candidates_loop(atoms, indices, c, cans, n, depth, step+1)
            

unitcell = td.create_base("graphene", layers=1)
size = 3
atoms = td.create_base("graphene", layers=1, size=size)
#td.bp(atoms)
layers = td.layers(atoms)
edges = td.edges(atoms, unitcell)#
cans = candidates(atoms, layers, exclude=edges)

td.bp([cans])
images = []
td.paint_atoms(atoms, edges)
for i, c in enumerate(cans):
    a = atoms.copy()
    td.paint_atoms(a, c, sym="O")
    td.write_image('movies/candidates-islands/size={1}/{0:0>4}'.format(i, size), a)

td.bp()
td.bp(cans)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 [[9], [8, 9], [9, 10], [9, 10, 11], [9, 10, 11, 16], [9, 10, 11, 15, 16], [9, 10, 11, 14, 15, 16], [9, 10, 11, 16, 17], [9, 14], [9, 14, 15], [9, 14, 15, 16], [9, 11, 14, 15, 16], [9, 14, 15, 16, 17]]

 :END:


 #+BEGIN_SRC python
A = [1, 2, 3, 4, 5]
for a in A:    
    if a == 2 or a == 6 and len(A) < 10:
        A.append(6)
print A
 #+END_SRC

 #+RESULTS:
 : [1, 2, 3, 4, 5, 6, 6, 6, 6, 6]

*** center_layer

 #+BEGIN_SRC python :results drawer
import twodee as td

atoms = td.create_base("graphene", layers=2, size=4)
layers = td.layers(atoms)
center1 = td.center_layer(atoms, layers[0])
center2 = td.center_layer(atoms, layers[1])
c1 = td.closest_atom(atoms, center1)
c2 = td.closest_atom(atoms, center2)
td.paint_atoms(atoms, [c1, c2])
td.bp(atoms)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 :END:

*** create_base

 #+BEGIN_SRC python :results drawer
import twodee as td

atoms = td.create_base("graphene", size=5)

td.bp(atoms)
 #+END_SRC

 #+RESULTS:

*** db_update

#+BEGIN_SRC python
import twodee as td

td.db_update('database/master.db', 'vasp')
#+END_SRC

#+RESULTS:
: 670 total entries. 0 new entries added.

*** edges

 #+BEGIN_SRC python :results drawer
import twodee as td

unitcell = td.create_base("graphene", layers=2)
atoms = td.create_base("graphene", layers=2, size=5)

e = td.edges(atoms, unitcell)
td.paint_atoms(atoms, e)
td.bp(atoms)
td.bp([e])
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 :END:

*** is_connected

 #+BEGIN_SRC python
import twodee as td
import time


graphene_cutoff = 1.5 # Angstrom. Should put this somewhere more permanent.


def candidates(atoms, edge=None, size=None):
    """Return candidate pore indices combinations."""
    from itertools import combinations

    cans = []
    indices = [a.index for a in atoms if a.index not in edge]

    nblist = NeighborList([graphene_cutoff for i in range(len(atoms))],
                          bothways=True,
                          self_interaction=False)
    nblist.update(atoms)


    def constraint_check(pores):
        for pore in pores:
            remains = [a.index for a in atoms if a.index not in pore]
            if is_connected(nblist, remains) and is_connected(nblist, pore):
                cans.append(pore)

    if size is not None:
        pores = combinations(indices, size)
        constraint_check(pores)
    else:
        for i in range(1, len(indices)):
            pores = combinations(indices, i)
            constraint_check(pores)

    return cans

unitcell = td.create_base("graphene", layers=1)
size = 3
atoms = td.create_base("graphene", layers=1, size=size)

edges = td.edges(atoms, unitcell)#

#td.bp(atoms)
start = time.time()
print(td.is_connected(atoms, [8, 9, 10]))
end = time.time()
print(end-start)
start = time.time()
print(td.is_connected_working(atoms, [8, 9, 10]))
end = time.time()
print(end-start)
print(td.is_connected_working(atoms, [8, 9, 10]))
print(td.is_connected(atoms, [8, 10, 14]))
print(td.is_connected(atoms, [9]))
td.bp()
 #+END_SRC

 #+RESULTS:
 : True
 : 0.0273470878601
 : False
 : 0.00108289718628
 : False
 : True

*** get_neighbors

 Presentation: show layers[0] and layers[1]

 #+BEGIN_SRC python
import twodee as td

atoms = td.create_base("graphene", layers=2, size=5)
index = 45
layers = td.layers(atoms)
neighbors = td.get_neighbors(atoms, index, layers[0], cutoff=1.5)
td.paint_atoms(atoms, [index])
td.paint_atoms(atoms, neighbors, sym='O')
td.bp(atoms)
 #+END_SRC

** amp_utils
** utils
*** bp - breakpoint

#+BEGIN_SRC python
import twodee as td

atoms = td.create_base("graphene", layers=1, size=3)
#td.bp(atoms)

tester = [0, 1, 2]
#td.bp(tester)
td.bp([tester])
#+END_SRC

#+RESULTS:
: [0, 1, 2]
: 

*** qsub

#+BEGIN_SRC python :tangle ./queue/candidates/7/cans=7.py
import twodee as td
sizes = [5, 6, 7]
path = "./queue/candidates/".format
prog= '''#!/usr/bin/env python
import twodee as td

cans = td.candidates(mat="graphene", layers=1, size=7, pores=None, silent=False)
'''
#+END_SRC

#+BEGIN_SRC python
import twodee as td

td.qsub("./queue/candidates/7/cans=7.py")
#+END_SRC

#+RESULTS:
: 1428315.gilgamesh.cheme.cmu.edu

* References
bibliographystyle:unsrt
bibliography:references.bib

