#+title: MS Research Project
#+author: Devon Walker
#+email: devonw@andrew.cmu.edu
#+TODO: TODO(t) INPROGRESS(w) | DONE(d) CANCELED(c)
#+STARTUP: hideblocks

* Meetings
** DONE 2016-03-08 4pm
   CLOSED: [2016-03-09 Wed 09:26] DEADLINE: <2016-03-08 Tue 16:00>
*** Questions
quantum mechanics:
- can we adsorb molecules to the surface which impart favorable changes to the electron density around diffusion sites?

neural network:
- can we use a neural network to address properties that dft doesn't model well, such as charging the material with a potential?

org-ref:
- can you later attach a pdf?
- duplicate current bibliography into default bibliography?
- do you highlight pdfs or just type into the notes file?

*** Actions
1. Table outlining separation data

** DONE 2016-04-15 11am
   CLOSED: [2016-05-11 Wed 16:02] DEADLINE: <2016-04-15 Fri 11:00>
*** Final project suggestion
- develop a suggestion related to research
- look into what jasp is lacking

*** Neural networks
Behler-Parrinello paper from 2007
- inputs are atom positions
- questions
  - how is it not overfit with an 8200 optimizing set and 800 test set?
  - is there a way to use different inputs or generalize them? (ie. an input could be the position or presence of a functional group)

** DONE 2016-05-12 11am
*** Final project feedback
[[file:~/techela/s16-06640/final-project/final-project.org::*Transport of carbon dioxide]]

*** Correct constraints for a molecule

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.constraints import FixAtoms, Hookean
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
import sys

JASPRC['queue.walltime'] = '10:00:00'

def print_converged(i, energy, time):
#    print(i, energy, time)
    print("CO2 Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("CO2 Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("CO2 Distance: {:5.2f}. Did not converge.".format(i))


# Height of the fixed atom
heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]


# Build base images
with jasp('graphene/G-c-final') as calc:
    G_defect = calc.get_atoms()
def_pos = np.array([5.681, 0., 5.]) # defect position

# http://en.wikipedia.org/wiki/Carbon_dioxide_(data_page)
CO_bond = 1.16 # Ang. C=O bond length in CO2

atoms =  [Atoms(G_defect) for i in range(len(heights))]
for i, h in enumerate(heights):
    CO2 = Atoms([Atom('O', def_pos + (0., 0., h - CO_bond)),
                 Atom('C', def_pos + (0., 0., h)),
                 Atom('O', def_pos + (0., 0., h + CO_bond))])

    atoms[i].extend(CO2)

# Constraint - fix all carbons (including the CO2 carbon)
carbon_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Hookean constraint
# Values for constants rt [Ang] and k [eV/Ang^-2] are from https://wiki.fysik.dtu.dk/ase/ase/constraints.html for a C=O bond
for atom in atoms[0]:
    if atom.symbol == 'O':
        hook_constraint = [Hookean(a1=atom.index, a2=atom.index+1, rt=1.58, k=10.),
                           Hookean(a1=atom.index+1, a2=atom.index+2, rt=1.58, k=10.)]
        break

ready = True

# Constrained graphene, constrained carbon in CO2
print('Unconstrained graphene, constrained carbon in CO2:')

atoms_yy = [Atoms(atoms[i]) for i in range(len(heights))]
#for i in range(len(heights)):
#    atoms_yy[i].set_constraint(carbon_constraint)





with jasp('transport/G-c-CO2-transport-no-yes-d=1.00a'.format(h),
                encut=450,         # From convergence check
                kpts=(6,6,1),      # From convergence check
                xc='PBE',          # GGA functional type. Important for the defect.
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms_yy[i]) as calc:
        try:
            calc.calculate()
            energy = atoms_yy[i].get_potential_energy()
            print_converged(h, energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            print_inprogress(h)
            ready = False
            pass
sys.exit()





TE_yy = []
BO_yy = [[], []]
for i, h in enumerate(heights):
    with jasp('transport/G-c-CO2-transport-no-yes-d={0:0.2f}'.format(h),
                encut=450,         # From convergence check
                kpts=(6,6,1),      # From convergence check
                xc='PBE',          # GGA functional type. Important for the defect.
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms_yy[i]) as calc:
        try:
            calc.calculate()
            energy = atoms_yy[i].get_potential_energy()
            TE_yy.append(energy)
            BO_yy[0].append(atoms_yy[i].get_distance(17,18))
            BO_yy[1].append(atoms_yy[i].get_distance(18,19))
            print_converged(h, energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            print_inprogress(h)
            ready = False
            pass


# Constrained graphene, constrained carbon in CO2 + Hookean oxygen
print('')
print('Unconstrained graphene, constrained carbon + Hookean oxygen:')

atoms_yh = [Atoms(atoms[i]) for i in range(len(heights))]
#for i in range(len(heights)):
#    atoms_yh[i].set_constraint(carbon_constraint + hook_constraint)

TE_yh = []
BO_yh = [[], []]
for i, h in enumerate(heights):
    with jasp('transport/G-c-CO2-transport-no-hook-d={0:0.2f}'.format(h),
                encut=450,         # From convergence check
                kpts=(6,6,1),      # From convergence check
                xc='PBE',          # GGA functional type. Important for the defect.
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms_yh[i]) as calc:
        try:
            calc.calculate()
            energy = atoms_yh[i].get_potential_energy()
            TE_yh.append(energy)
            BO_yh[0].append(atoms_yh[i].get_distance(17,18))
            BO_yh[1].append(atoms_yh[i].get_distance(18,19))
            print_converged(h, energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            print_inprogress(h)
            ready = False
            pass

if not ready:
    import sys; sys.exit()

import matplotlib.pyplot as plt

# Consider the change in energy from lowest energy state
TE_yy = np.array(TE_yy)
TE_yh = np.array(TE_yh)
TE_yy -= min(TE_yy)
TE_yh -= min(TE_yh)

print('')
print('Comparison of constraint techniques:')
file_path = './img/G-c-C-linear.png'
plt.figure(0)
plt.plot(heights, TE_yy, label='O uconstrained')
plt.plot(heights, TE_yh, label='Hookean constraint')
plt.xlabel('Height (Ang)')
plt.ylabel('$\Delta$ Energy (eV)')
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#view(atoms_yy)
#view(atoms_yh)
#+END_SRC

#+RESULTS:
: Unconstrained graphene, constrained carbon in CO2:
: CO2 Distance: -3.00. In progress.

*** Bilayer / Trilayer graphene
**** Bilayer

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys

def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

layer_dist = 3.32
b1 = a1
b2 = a * np.array([1./2., 3.0**0.5/2., 0.])
b3 = a3 - 2 * np.array([0., 0., layer_dist])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3),
                  Atom('C', 1./2. * b3),
                  Atom('C', 1./3. * b1 + 1./3. * b2 + 1./2. * b3)],
                  cell=[a1, a2, a3])


atoms = unitcell
#atoms = unitcell.repeat((3,3,1))
view(atoms)
sys.exit()

defect_pos = atoms[9].position
del atoms[9]

ready = True
with jasp('graphene/G-c-final',
            encut=450,         # From convergence check
            kpts=(6,6,1),      # From convergence check
            xc='PBE',          # GGA functional type. Important for the defect.
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

if not ready:
    sys.exit()

print('')
print('Defect position: {}'.format(defect_pos))

print('')
file_path = './img/bilayer.png'
#file_path = './img/G-c-final-repeat-present.png'
#atoms = atoms.repeat((3,3,1))
#atoms.rotate('x', -np.pi/4)
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
view(atoms)
#+END_SRC

#+RESULTS:
** DONE 2016-06-10 3pm Group meeting presentation
   CLOSED: [2016-06-15 Wed 09:44] DEADLINE: <2016-06-10 Fri 3pm>

*** Presentation
**** 06-640 Final project
***** Concept movie

 #+BEGIN_SRC python
from jasp import *
from ase.visualize import view

fp_dir = '~/techela/s16-06640/final-project/' # Directory of final project.

heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]

images_h2 = []
images_co2 = []

for h in heights:

    with jasp(fp_dir + 'transport/G-c-HHc-constraints-yes-hook-d={0:0.2f}'.format(h)) as calc:
        images_h2.append(calc.get_atoms())

    with jasp(fp_dir + 'transport/G-c-CO2-transport-yes-hook-d={0:0.2f}'.format(h)) as calc:
        images_co2.append(calc.get_atoms())

view(images_co2)
#view(images_h2) 
 #+END_SRC

 #+RESULTS:

 Limitations:
 - Graphene layer consisted of a 3x3 repeated monolayer in the x and y directions. Not large enough to say pores do not have an effect on one another.
 - Carbon atoms in graphene plane are fixed
 - One atom in each molecule is chosen to be fixed, with other atoms constrained with a Hookean constraint
   - Preserved molecule structure
   - Introduced new error (empirical correction)
     - If the atoms within a molecule got beyond a certain distance, an artificial energy penalty would be imposed to persuade the geometry relaxation to maintain the integrity of the molecule's structure.

***** Bond length change
 [[./img/final-project/G-bond-length.png]]

***** Barrier energy

 [[./img/final-project/total_energy-comparison.png]]


 Energy barriers:
     H2:  1.879 eV
     CO2: 4.643 eV

 Significantly large energy barrier, even for H2.

 Literature comparison: cite:jiang-2009-porous-graph
     H2: 0.22 eV
     6x6 repeated graphene monolayer.
     Pore = 10 removed carbons. H passivated.
 [[./img/ref/jiang-2009-h2passivated.png]]
 [[./img/material/g-mono/3x3/pore=1/final.png]]

**** Vacuum distance for convergence

 #+CAPTION: Vaccuum distance convergence. Height represents distance between the molecule's closest atom and the graphene plane.
 #+NAME: fig:vaccuum-molecule-distance
 [[./img/results/convergence-vaccuum-pore=1.png]]


 Converged distance appears to be around 4 Å.

 cite:sun-2014-mechan-molec reports between 5-6 Å is the distance of non-interaction for these molecules. They used classical MD with LJ potentials.

 Final project max distance for both molecules was 3 Å. CO2 calculations probably affected since the minimum should have been lower, meaning the barrier energy would be higher.

**** Monolayer graphene pore distance convergence

 Ideally, we could model a pore placed on an infinite graphene sheet. The energy per atom of this structure would aproach a pristine graphene sheet.

 #+CAPTION: The effect of distance between pores on energy and calculation time.
 #+NAME: fig:g-mono-energy_vs_pore_distance
 [[./img/results/monolayer-energy_vs_pore_distance.png]]
***** Structures

 Distance = 4.92. Structure = 2x2
 [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=2.png]]
 Distance = 7.38. Structure = 3x3
 [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=3.png]]
 Distance = 9.84. Structure = 4x4
 [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=4.png]]
 Distance = 12.3. Structure = 5x5
 [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=5.png]]
 Distance = 14.76. Structure = 6x6
 [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=6.png]]


***** Pore=10 comparison

 Note that the 4x4 structure is the smallest possible size for a pore with 10 removed carbon atoms.

 Distance = 9.84. Structure = 4x4
 [[./img/results/monolayer-energy_vs_pore_distance-pore=10-size=4.png]]
 Distance = 12.3. Structure = 5x5
 [[./img/results/monolayer-energy_vs_pore_distance-pore=10-size=5.png]]
 Distance = 14.76. Structure = 6x6
 [[./img/results/monolayer-energy_vs_pore_distance-pore=10-size=6.png]]
 #+CAPTION: The effect of distance between pores on energy and calculation time.
 #+NAME: fig:g-mono-energy_vs_pore_distance
 [[./img/results/monolayer-energy_vs_pore_distance-pore=10.png]]

**** Bilayer graphene neural network sidebar
 Proposed project: Use a neural network trained on different bilayer graphene pore structures to 

 Sidebar: Determine minimum energy structures of different pore configurations for smaller structures first. Use this information to inform the larger structures.

 Motivation:
 - DFT relaxations bilayer graphene with significant pore size would take too long.
 - Current etching of pores does not allow for the geometric accuracy. (cite:koenig-2012-selec-molec: heavily cited experimental graphene transport paper uses bilayer graphene but didn't determine exact pore structure after etching.)
 - Graphene was found to reknit itself, so minimum energy pore structures are important. cite:zan-2012-graph-reknit
 [[./img/ref/zan-2012-reknit.png]]
 - This smaller project can be done on monolayer graphene at the same time with minimal effort and faster speeds.

 Where I'm at with this:
 - Created a function for determining candidates for etching based on current index.
 - Working on the structure for managing all the calculations and removing duplicates.

 get_neighbors example:
 #+BEGIN_SRC python
from jasp import *
from ase import Atoms, Atom
import twodee as td

with jasp('dft/material/g-bi/final') as calc:
    atoms = calc.get_atoms()
i = 3
atoms = atoms.repeat([i,i,1])

#td.bp(atoms)
struct = td.structure(atoms, layers=2)
index = 16
neighbors = td.get_neighbors(atoms, index, struct['layers'][0])
neighbors.append(index)
td.paint_atoms(atoms, neighbors, layers=struct['layers'])
td.bp(atoms)
 #+END_SRC

** DONE 2016-06-24 3pm Group meeting
   CLOSED: [2016-07-06 Wed 13:22]
** DONE 2016-07-06 3pm Group meeting presentation
   CLOSED: [2016-07-18 Mon 16:40]
*** 2D structure module - twodee
For mainting helper functions for manipulating 2D materials
[[./twodee.py]]

**** Tests
Tests maintained in this file at [[twodee tests]].

***** create_base

Plan to incorporate into ASE DB.

   #+BEGIN_SRC python :results drawer
import twodee as td

atoms = td.create_base("graphene", size=5)

td.bp(atoms)
   #+END_SRC

   #+RESULTS:

***** center_layer

   #+BEGIN_SRC python :results drawer
import twodee as td

atoms = td.create_base("graphene", layers=2, size=4)
layers = td.layers(atoms)
center1 = td.center_layer(atoms, layers[0])
center2 = td.center_layer(atoms, layers[1])
c1 = td.closest_atom(atoms, center1)
c2 = td.closest_atom(atoms, center2)
td.paint_atoms(atoms, [c1, c2])
td.bp(atoms)
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   :END:

***** edges

   #+BEGIN_SRC python :results drawer
import twodee as td

unitcell = td.create_base("graphene", layers=2)
atoms = td.create_base("graphene", layers=2, size=5)

e = td.edges(atoms, unitcell)
td.paint_atoms(atoms, e)
td.bp(atoms)
td.bp([e])
   #+END_SRC

   #+RESULTS:
   :RESULTS:
   :END:

***** get_neighbors

Show layers[0] and layers[1]

#+BEGIN_SRC python
import twodee as td

atoms = td.create_base("graphene", layers=2, size=5)
index = 45
layers = td.layers(atoms)
neighbors = td.get_neighbors(atoms, index, layers[0], cutoff=1.5)
td.paint_atoms(atoms, [index])
td.paint_atoms(atoms, neighbors, sym='O')
td.bp(atoms)
#+END_SRC

***** is_connected

   #+BEGIN_SRC python
import twodee as td

graphene_cutoff = 1.5 # Angstrom. Should put this somewhere more permanent.

unitcell = td.create_base("graphene", layers=1)
size = 3
atoms = td.create_base("graphene", layers=1, size=size)

edges = td.edges(atoms, unitcell)#

td.bp(atoms)
print(td.is_connected(atoms, [8, 9, 10]))
print(td.is_connected(atoms, [8, 10, 14]))
print(td.is_connected(atoms, [9]))
td.bp()
   #+END_SRC

   #+RESULTS:
   : True
   : False
   : True

*** Pore candidate selection algorithm
**** Constraints
1. The pore may not appear to break the structure of the graphene plane.
[[./img/presentation/group-meeting-20160706/edges.png]]

2. "Islands" of carbon atoms are not allowed.
[[./img/presentation/group-meeting-20160706/island.png]]

3. Removed carbons must be neighbors.
[[./img/presentation/group-meeting-20160706/bad_pore.png]]

Example pics:
#+BEGIN_SRC python :results silent
import twodee as td

unitcell = td.create_base("graphene", layers=1)
size = 4
atoms = td.create_base("graphene", layers=1, size=size)
edges = td.edges(atoms, unitcell)
island = [13, 14, 15, 20, 22, 23, 28, 29, 30, 19, 26, 27]
bad_pore = [10, 11, 12, 23, 30, 31]

a = atoms.copy()
td.paint_atoms(a, edges)
td.print_image('presentation/group-meeting-20160706/edges', a)

a = atoms.copy()
td.paint_atoms(a, edges)
td.paint_atoms(a, island, sym="O")
td.print_image('presentation/group-meeting-20160706/island', a)

a = atoms.copy()
td.paint_atoms(a, edges)
td.paint_atoms(a, bad_pore, sym="O")
td.print_image('presentation/group-meeting-20160706/bad_pore', a)
#+END_SRC


*Why constraints?*
The amount of combinations for pores will be very large, even with constraints. It will be more useful to look at "more likely" pore candidates for our calculations. However, this does not address the possibility that the material would prefer one of the structures that are being disregarded.

**** First pass - Tree branching
[[~/hydrogen2D/img/movies/candidates-islands/size=3.gif]]
[[~/hydrogen2D/img/movies/candidates-islands/size=4.gif]]
[[~/hydrogen2D/img/movies/candidates-islands/size=5.gif]]

Issue: Creates islands

Possible solution: Manipulate the algorithm to step farther back within its recursion loop to start a new tree branch.

- Difficult to conceptualize
- Even harder to prove it accurately captures all combinations

**** Second pass - Exclusion from all combinations

[[~/hydrogen2D/img/movies/candidates/candidates-size=3.gif]]

Notes:
1. Show a comparison of how the two algorithms move by showing the gifs side-by-side. Draw diagrams.
2. Show td.is_connected() loop structure

|          Graphene size |   Pore size | Calculation time |
| (unitcell repititions) | (# carbons) |        (seconds) |
|------------------------+-------------+------------------|
|                      3 |           1 |              0.1 |
|                      3 |           2 |              0.3 |
|                      3 |           3 |              0.5 |
|                      3 |           4 |              0.6 |
|                      3 |           5 |              0.5 |
|                      3 |           6 |              0.2 |
|                      3 |           7 |              0.1 |
|                      4 |           1 |              0.7 |
|                      4 |           2 |              5.3 |
|                      4 |           3 |             26.9 |
|                      4 |           4 |             95.1 |

**** Third pass - Improvements
1. Speed increases: Storing larger lists, instead of calling functions like get_neighbors each time (moves from O(n^2) to O(n)).

2. Reliability: Write a method for determiniing if all combinations meeting the constraints are accounted for (more difficult).

**** Future
How to select the best structures for DFT calculations and training a neural network?
1. Start with a hand-curated set that are often found in literature.
2. Use the previous algorith to determine all combinations. Select from a group that have been shown to have the most promise from a faster calculation type (MD).

** DONE 2016-07-15 3pm Group meeting
   CLOSED: [2016-07-18 Mon 16:40]
** 2016-08-12 3pm Group meeting presentation
*** Scimax issues
- [ ] src block coloring
- [ ] checkbox coloring
- [ ] auto-completion. especially in lisp

* Research
** Literature
*** Graphene
**** cite:novoselov-2005-two-dimen
**** cite:partoens-2006-from-graph graphene structure unitcell
**** cite:geim-2009-graph
**** *cite:jiang-2009-porous-graph DFT porous graphene separation of H2/CH4
 Selectivity results
 | Graphene monolayer porous N/H functionalized |  10^8 |
 | Graphene monolayer porous H functionalized   | 10^23 |
 | Traditional polymer / silica membranes       |  10^8 |
**** cite:pontes-2009-barrier-free DFT HCN production with substitutional doping using boron
**** DONE cite:du-2011-separ-hydrog DFT H2/N2 separation
     CLOSED: [2016-06-01 Wed 14:59]
**** DONE *cite:koenig-2012-selec-molec Experimental separation of common gases
     CLOSED: [2016-06-01 Wed 14:59]
**** cite:shan-2012-influen-chemic CO2/N2 separation using cite:jiang-2009-porous-graph funcitonalized groups
**** DONE cite:drahushuk-2012-mechan-gas MD H2/N2 separation. Explains mechanisms for gases crossing the membrane
     CLOSED: [2016-06-01 Wed 14:59]
**** cite:kim-2013-selec-gas  Exp O2/N2. Most work done on GO.
**** cite:miao-2013-first-princ DFT proton/H separation
**** cite:qin-2013-graph-with H2&He separation from air. Octogon pore + secondary small pore.
**** cite:ambrosetti-2014-gas-separ Water filtration through porous graphene. No permeation/selectivity data.
**** cite:celebi-2014-ultim-permeat Exp separation of H2/CO2 with bilayer G. Also a water permeance comparison to Goretex.
**** cite:tsetseris-2014-graph DFT Boron can pass through pristine graphene under moderate annealing conditions
**** cite:sun-2015-applic-nanop DFT separation for gases in natural gas processing
**** cite:wen-2015-inhib-effec Inhibition effect of non-permeating components
**** cite:achtyl-2015-aqueous-proton Exp/DFT Defect detection. Aqueous proton transfer

*** Polyphenylene (Porous Graphene (PG))
**** cite:bieri-2009-porous-graph Synthesis of PG
**** *cite:blankenburg-2010-porous-graph Selectivity study of common gases with DFT
 [[./img/blankenburg-2010-porous-graph-3.png]]
**** cite:schrier-2010-helium-separ Helium isotope separation
**** cite:li-2010-two-dimen-polyp H2 separation from CO2, CO, CH4
**** cite:lu-2014-promis-monol DFT O2 separation from harmful gases
**** cite:huang-2014-improv-permeab Bilayer porous graphene. H2/CH4 separation. High permeance and selectivity
**** cite:tao-2014-tunab-hydrog DFT PG-ESX study on hydrogen purification
 | Molecule |     Kinetic |
 |          | Diam. (Ang) |
 |----------+-------------|
 | H2       |         2.9 |
 | N2       |        3.64 |
 | CO       |        3.76 |
 | CH4      |         3.8 |
 Note: Agrees with common molecules table.

**** *cite:brockway-2013-noble-gas DFT PG-ESX study similar to Blankenberg's
**** Notes 
 High temperatures required for permeance of H2 and He would destroy a PG monolayer. cite:huang-2014-improv-permeab
*** hexagonal Boron Nitride (hBN)
**** cite:corso-2004-boron-nitrid-nanom Boron nitride nanomesh
 Hole in mesh: size 20 Å
 - 'likely driven by the lattice mismatch of the film and the rhodium substrate'
**** cite:jin-2009-fabric-frees monolayer fabrication with electron irradiation
**** cite:nag-2010-graph-analog-bn properties of hBN compared to graphene
**** cite:hu-2014-proton-trans proton transport of graphene, hBN, MoS2
**** *cite:zhang-2015-hexag-boron H2/CH4 separation. Triangular pores.
 Drahushuk, L. W.; Strano, M. S. Mechanisms of Gas Permeation
 through Single Layer Graphene. Langmuir 2012, 28, 16671−16678.
*** Graphene oxide
**** *cite:kim-2013-selec-gas
**** *cite:li-2013-ultrat-molec
**** cite:yoo-2013-graph-graph
*** Molybdenum disulphide (MoS2)
**** cite:hong-2015-explor-atomic 
*** Quantum mechanics
**** Lennard-Jones potential
 [[http://chemwiki.ucdavis.edu/Core/Physical_Chemistry/Physical_Properties_of_Matter/Atomic_and_Molecular_Properties/Intermolecular_Forces/Specific_Interactions/Lennard-Jones_Potential][ChemWiki - UC Davis]]

**** van der Waals radius
 [[http://chemwiki.ucdavis.edu/Core/Theoretical_Chemistry/Chemical_Bonding/General_Principles_of_Chemical_Bonding/Covalent_Bond_Distance%2C_Radius_and_van_der_Waals_Radius][ChemWiki - UC Davis]]
*** Neural networks
**** *cite:behler-2007-gener-neural
**** TODO cite:behler-2008-press-induc
**** TODO cite:behler-2011-neural-networ
**** TODO cite:behler-2014-repres-poten
*** Review articles
**** cite:yoo-2013-graph-graph Graphene and graphene oxide uses as barriers
*** Patents
**** TODO Aperture
 http://www.google.com/patents/US20140263035
*** Non-pertinent
**** TODO cite:britnell-2012-elect-tunnel hBN as a dielectric
*** To Read
**** TODO cite:elstner-1998-self-consis
**** TODO cite:zhu-2006-permean-shoul
**** TODO cite:zhang-2012-tunab-hydrog
**** TODO cite:drahushuk-2012-mechan-gas
**** TODO cite:nieszporek-2015-alkan-separ
**** TODO cite:liu-2014-mechan-proper
**** TODO cite:tao-2014-tunab-hydrog
**** TODO cite:wang-2014-trans-metal
**** TODO cite:bunch-2008-imper-atomic
**** TODO cite:leeuwen-1994-deriv-stock Derivation of L-J lengths of liquids.
**** TODO cite:hauser-2012-methan-selec Methane transfer through graphene, DFT
** Questions
** Are the kinetic diameters used in Blankenberg correct?
cite:blankenburg-2010-porous-graph uses cite:leeuwen-1994-deriv-stock for kinetic diameter of ammonia, even though they're stated for liquids.
cite:tsuru-2010-permeat-proper shows that certain kinetic diameter calculations may not apply to certain separations.
** What is the unit GPU?
Gas permeance unit
1 GPU = 0.33 mol/(m^2*s*Pa)
** What's a dispersion correction in dft?
Dipoles occur as a molecule passes through the membrane. They need to be accounted for in the energy calculations.
** Ryd compared to eV?
Stands for Rydberg constant.
1 eV = 7.350e-2 Ryd
300 eV = 22.096 Ryd
** TODO Best way to calculate a pore's diameter?
** What should I compare H2 transport with?
- cite:koenig-2012-selec-molec 
- cite:jiang-2009-porous-graph 
- cite:blankenburg-2010-porous-graph

** Properties
*** Bond lengths

| Molecule | Bond | Bond Length (Å) |
| H2       | H-H  |            0.74 |
| CO2      | C=O  |            1.21 |
| N2       | N=-N |            1.13 |

**** References
CO2 C=O, H2, N2: CRC Handbook, Section 9, Characteristic Bond Lengths in Free Molecules

*** Common molecules
Useful numbers:
- Average energy of a gas particle at room temperature: ~0.037 eV (need cite)
  - calculated as $E=(3/2)kT$, where $k$ is the Boltzmann constant

#+caption: Properties of common industrial gases.
#+name: tab:properties-common_gases
| Molecule      |  Kinetic |
|               | diameter |
|               |      (Å) |
|---------------+----------|
| He            |     2.60 |
| H2O           |     2.65 |
| Ne            |     2.79 |
| H2            |     2.89 |
| NH3           |     3.26 |
| CO2           |     3.30 |
| Ar            |     3.42 |
| O2            |     3.46 |
| Kr            |     3.60 |
| H2S           |     3.60 |
| N2            |     3.64 |
| CO            |     3.76 |
| CH4           |     3.80 |
|---------------+----------|
| CH4           |      3.8 |
| C2H6          |      --- |
| C2H4          |      3.9 |
| C3H8          |      4.3 |
| n-C4H10       |      4.3 |
| C3H6          |      4.5 |
| i-C4H10       |        6 |
|---------------+----------|
| Benzene       |     5.85 |
| Toluene       |     5.85 |
| p-xylene      |     5.85 |
| Ethyl-benzene |     6.00 |
| Cyclohexane   |      6.0 |
| o-xylene      |     6.80 |
| m-xylene      |     6.80 |

**** References
Kinetic diameter
- He, H2S, CO: [[https://en.wikipedia.org/wiki/Kinetic_diameter][Wiki]]
- CO2, O2, N2, H2O, CH4, H2: cite:ismail-2015-fundam-gas p14
- CO2, CO, CH4: cite:li-2010-two-dimen-polyp
- NH3: cite:blankenburg-2010-porous-graph 
- Ne, Ar: [[http://www.kayelaby.npl.co.uk/general_physics/2_2/2_2_4.html][NPL]]
- Kr: [[https://smartech.gatech.edu/handle/1853/50383][Crawford-2013]]
- He, H2, O2, N2, CO, CO2, CH4, C2H6, C2H4, C3H8, C3H6, n-C4H10, i-C4H10: cite:matteucci-2006-trans-gases Has L-J parameters in same table
- benz, tol, eth-benz, xylene: cite:baertsch-1996-permeat-aromat
- cyclohexane: cite:sing-2004-use-molec

*** 2D materials

Structure
| Material | Stack | Lattice      |
|          |       | Constant [Å] |
|----------+-------+--------------|
| Graphene | Mono  | 2.460        |
|          |       |              |


Stability
| Material | Stack | Production | Temperature   | Ref                       |
|          |       |            | Stability [K] |                           |
|----------+-------+------------+---------------+---------------------------|
| Graphene | Mono  | CVD        | 2600          | cite:kim-2010-high-temper |



| Material | Features | Pore     |
|          |          | Size (Å) |
|----------+----------+----------|
| Graphene | Pristine |          |
| PG       |          | 2.48     |
| PG-ES1   |          |          |
| PG-ES2   |          |          |
| PG-ES3   |          |          |
| hBN      |          |          |

**** References

Structure
- Lattice constant
  - Graphene mono: cite:partoens-2006-from-graph

Pore size
- Graphene, Pristine: 
- PG: cite:li-2010-two-dimen-polyp
** Separations

Materials to research
- Graphene Monolayer
- Graphene Bilayer
- Graphene oxide
- Boron nitride monolayer
- Boron nitride bilayer

*** Master Table

Table legend:
- 2D Material:
  - hBN: hexagonal boron nitride
  - PG: Polyphenylene (porous graphene)
  - PG-ES1: Porous Graphene-E-Stilbene-1
- Features: Distinctive variations of the material.
  - Porous: Intentially engineered pores
  - Defects: Naturally occuring defects from the production process.
- Func. Groups: Functional groups attached around a pore.
  - CNT: Carbon nanotubes
- Methods:
  - DFT: Density functional theory
  - Exp: Experimental
  - MD: Molecular dynamics simulation
  - TST: Transition state theory
- Molecules: Numbers denote separation groups. Members of "a" can be separated from "b" and both can be separated from "c". Additionally, "a" transfers across the barrier before "b".

#+caption: Table of separation selectivity groupings found in literature with molecule columns ordered by kinetic diameter.
#+name: tab:separations-common_gases
| Reference                          | Methods  | 2D             | Stack   | Features | Func.  | He | H2O | Ne | H2 | NH3 | CO2 | Ar | O2 | N2 | Kr | H2S | CO | CH4 | Note |
|                                    |          | Material       |         |          | Groups |    |     |    |    |     |     |    |    |    |    |     |    |     |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:jiang-2009-porous-graph       | DFT, MD  | Graphene       | Mono    | Porous   | N/H, H |    |     |    | a  |     |     |    |    |    |    |     |    | b   |      |
| cite:wesołowski-2011-pillar-graph  | MD       | Graphene       | Multi   | Porous   | CNT    | c  |     |    |    |     |     | b  |    |    | a  |     |    |     |      |
| cite:du-2011-separ-hydrog          | MD       | Graphene       | Mono    | Porous   |        |    |     |    | a  |     |     |    |    | b  |    |     |    |     |      |
| cite:koenig-2012-selec-molec       | Exp      | Graphene       | Bilayer | Porous   |        |    |     |    | a  |     | a   | b  |    | b  |    |     |    | b   |      |
| cite:kim-2013-selec-gas            | Exp      | Graphene       | Multi   | Defects  |        |    |     |    |    |     |     |    | a  | b  |    |     |    |     |      |
| cite:celebi-2014-ultim-permeat     | Exp      | Graphene       | Bilayer | Porous   |        |    |     |    | a  |     | b   |    |    |    |    |     |    |     |      |
| cite:lei-2014-separ-hydrog         | DFT      | Graphene       | Mono    | Porous   |        |    |     |    |    |     |     |    |    |    |    | a   |    | b   |    3 |
| cite:liu-2015-selec-trend          | MD       | Graphene       | Mono    | Porous   | N/H    |    |     |    | a  |     | a   | b  |    | b  |    |     |    | b   |      |
| cite:sun-2015-applic-nanop         | MD       | Graphene       | Mono    | Porous   | N/H    |    |     |    |    |     | a   |    |    | a  |    | a   |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:blankenburg-2010-porous-graph | DFT, MD  | PG             | Mono    |          |        | a  |     | a  | a  | c   | b   | d  | b  | c  |    |     | c  |     |      |
| cite:li-2010-two-dimen-polyp       | DFT      | PG             | Mono    |          |        |    |     |    | a  |     | b   |    |    |    |    |     | b  | b   |      |
| cite:huang-2014-improv-permeab     | DFT, MD  | PG             | Bilayer |          |        |    |     |    | a  |     |     |    |    |    |    |     |    | b   |      |
| cite:schrier-2012-carbon-dioxid    | MD       | PG-ES1         | Mono    |          |        |    |     |    |    |     | a   |    | b  | b  |    |     |    |     |      |
| cite:brockway-2013-noble-gas       | DFT, MD  | PG-ES1         | Mono    |          |        | a  |     | a  |    |     | b   | b  | b  | b  |    |     |    | c   |      |
| cite:tao-2014-tunab-hydrog         | DFT, MD  | PG-ES1         | Mono    |          |        |    |     |    | a  |     | b   |    |    | b  |    |     |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:nair-2012-unimp-permeat       | Exp, MD  | Graphene oxide | 1 µm    |          |        | b  | a   |    | b  |     |     | b  |    | b  |    |     |    |     |      |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 2-18 nm |          |        |    |     |    | a  |     | b   |    |    |    |    |     |    |     |      |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 2-18 nm |          |        |    |     |    | a  |     |     |    |    | b  |    |     |    |     |      |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 18 nm   |          |        | a  |     |    | a  |     | b   |    | b  | b  |    |     | b  | b   |    1 |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide | 3-7 nm  |          |        |    |     |    | a  |     | b   |    |    |    |    |     |    |     |    2 |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide | 3-7 nm  |          |        | b  |     |    | b  |     | a   |    | b  | b  |    |     |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:zhang-2015-hexag-boron        | DFT, MD  | hBN            | Mono    | Porous   | N/H    |    |     |    | a  |     |     |    |    |    |    |     |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:jiao-2011-graph               | DFT, TST | Graphdiyne     | Mono    |          |        |    |     |    | a  |     | b   |    |    |    |    |     |    | b   |      |
| cite:zhu-2015-c-n                  | DFT      | C2N            | Mono    |          |        | a  | b   | b  |    |     | b   | b  | b  | b  |    | b   |    | b   |      |
| cite:li-2015-effic-helium          | DFT, MD  | g-C3N4         | Mono    |          |        | a  |     | b  | b  |     | b   | b  |    | b  |    |     | b  | b   |      |

Notes:
1. Extrapolated from single-gas permeation results.
2. Long time scale ~1 hr. At short time scales <0.1 hr, the permeance rate is reversed.
3. Pore carbons had negative charge (-0.241 e).

*** Atmospheric separations
N2, O2, Ar, CO2, Ne, He, CH4 

| Reference                          | Methods | 2D             | Stack   | Features | Func.  | N2 | O2 | Ar | CO2 | Ne | He | CH4 |
|                                    |         | Material       |         |          | Groups |    |    |    |     |    |    |     |
|------------------------------------+---------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:koenig-2012-selec-molec       | Exp     | Graphene       | Bilayer | Porous   |        | b  |    | b  | a   |    |    | b   |
| cite:kim-2013-selec-gas            | Exp     | Graphene       | Multi   | Defects  |        | b  | a  |    |     |    |    |     |
| cite:liu-2015-selec-trend          | MD      | Graphene       | Mono    | Porous   | N/H    | b  |    | b  | a   |    |    | b   |
| cite:sun-2015-applic-nanop         | MD      | Graphene       | Mono    | Porous   | N/H    | a  |    |    | a   |    |    | b   |
|------------------------------------+---------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:blankenburg-2010-porous-graph | DFT, MD | PG             | Mono    |          |        | c  | b  | d  | b   | a  | a  |     |
| cite:schrier-2012-carbon-dioxid    | MD      | PG-ES1         | Mono    |          |        | b  | b  |    | a   |    |    |     |
| cite:brockway-2013-noble-gas       | DFT, MD | PG-ES1         | Mono    |          |        | b  | b  | b  | b   | a  | a  | c   |
|------------------------------------+---------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:li-2013-ultrat-molec          | Exp     | Graphene oxide | 18 nm   |          |        | b  | b  |    | b   |    | a  | b   |
| cite:kim-2013-selec-gas            | Exp     | Graphene oxide | 3-7 nm  |          |        | b  | b  |    | a   |    | b  | b   |
|------------------------------------+---------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:zhu-2015-c-n                  | DFT     | C2N            | Mono    |          |        | b  | b  | b  | b   | b  | a  | b   |
| cite:li-2015-effic-helium          | DFT, MD | g-C3N4         | Mono    |          |        | b  |    | b  | b   | b  | a  | b   |

*** Water-gas shift
CO + H2O -> CO2 + H2

| Reference                          | Methods  | 2D             | CO | H2O | CO2 | H2 |
|                                    |          | Material       |    |     |     |    |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:celebi-2014-ultim-permeat     | Exp      | Graphene       |    |     | b   | a  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:blankenburg-2010-porous-graph | DFT      | PG             | c  |     | b   | a  |
| cite:li-2010-two-dimen-polyp       | DFT      | PG             | b  |     | b   | a  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:tao-2014-tunab-hydrog         | DFT, MD  | PG-ES1         |    |     | b   | a  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:nair-2012-unimp-permeat       | Exp, MD  | Graphene oxide |    | a   |     | b  |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide |    |     | b   | a  |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | b  |     | b   | a  |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide |    |     | b   | a  |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide |    |     | a   | b  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:jiao-2011-graph               | DFT, TST | Graphdiyne     |    |     | b   | a  |

*** Nobel gas separation
He, Ne, Ar, Kr

| Reference                          | Methods | 2D       | He | Ne | Ar | Kr |
|                                    |         | Material |    |    |    |    |
|------------------------------------+---------+----------+----+----+----+----|
| cite:wesołowski-2011-pillar-graph  | MD      | Graphene | c  |    | b  | a  |
|------------------------------------+---------+----------+----+----+----+----|
| cite:blankenburg-2010-porous-graph | DFT     | PG       | a  | a  | d  |    |
|------------------------------------+---------+----------+----+----+----+----|
| cite:zhu-2015-c-n                  | DFT     | C2N      | a  | b  | b  |    |
| cite:li-2015-effic-helium          | DFT, MD | g-C3N4   | a  | b  | b  |    |

** TODO H2 transport comparison
Use the following works to generate a table with comparisons of H2 transport
- cite:koenig-2012-selec-molec 
- cite:jiang-2009-porous-graph 
- cite:blankenburg-2010-porous-graph

* Scripts
** 2016-03-07: Remote copying
*Note 2016-05-18* - Copying is better done by maintaining the git repo. 

To Gilgamesh:
#+BEGIN_SRC sh
scp ~/Google_Drive/projects/hydrogen2D/hydrogen2D.org devonw@gilgamesh.cheme.cmu.edu:projects/hydrogen2D
#+END_SRC

#+RESULTS:

To host:
#+BEGIN_SRC sh
scp devonw@gilgamesh.cheme.cmu.edu:projects/hydrogen2D/hydrogen2D.org ~/Google_Drive/projects/hydrogen2D
#+END_SRC

To update buffer
#+BEGIN_SRC 
M-x revert-buffer
#+END_SRC

** 2016-05-10: Tramp remote execution
This is a way to run code on a remote server while maintaining the code locally. It works for basic things that have text output. It doesn't work for things like ASE's view, which spawns a gui, and I haven't tried it for running vasp codes (not sure how directories would work out exactly -> may need to use absolute paths).

Check tramp works
#+begin_src sh :dir /devonw@gilgamesh.cheme.cmu.edu: :results output
echo "Executed by `whoami` on `hostname` in `pwd`"
#+end_srC

#+RESULTS:
: Executed by devonw on gilgamesh.cheme.cmu.edu in /home-guest/devonw

Test what $PATH is defined as. May need to copy the remote's path to the tramp path (Don't know why they'd want this to be different except for speed(?)).
#+begin_src sh :dir /ssh:devonw@gilgamesh.cheme.cmu.edu: :results output
#source ~/.bash_profile
#echo $PATH
#source .bash_profile
echo $PATH
#+end_src

#+RESULTS:
: /opt/kitchingroup/vasp-5.3.5/vtstscripts-914:/home-research/jkitchin/bin:/opt/vtk/bin:/opt/kitchingroup/vasp-5.3.5/ase-s16/tools:/opt/kitchingroup/vasp-5.3.5/jasp-s16/jasp/bin:/opt/kitchingroup/vasp-5.3.5/bin:/usr/mpi/intel/openmpi-1.4-qlc/bin:/opt/kitchingroup/CANOPY/Canopy_64bit/User/bin:/opt/maui/bin:/opt/fav/bin:/usr/local/texlive/2012/bin/x86_64-linux:/opt/intel/Compiler/11.1/072/bin/intel64:/opt/intel/impi/4.0.0.028/intel64/bin:/usr/lib64/qt-3.3/bin:/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/usr/share/pvm3/lib:/sbin:/usr/sbin:/usr/local/sbin

Modules are used to load in python code (?). Weird that this doesn't print what it does in shell.
#+begin_src sh :dir /devonw@gilgamesh.cheme.cmu.edu: :results output
source ~/.bash_profile
module list
#+end_src

#+RESULTS:

Test remote execution of a python file. The import statements working is the important part.
#+BEGIN_SRC python :results output :dir /devonw@gilgamesh.cheme.cmu.edu:
import os
from ase import Atoms
import numpy as np
from jasp import *
a = 5
print(a)
#+END_SRC

#+RESULTS:
: 5

Local python test. Unless you've installed ase and jasp locally, this shouln't work but the previous block should have.
#+BEGIN_SRC python :results output
import numpy as np
from ase import Atoms
from jasp import *
a = 5
print(a)
#+END_SRC

#+RESULTS:

** 2016-05-23: Test vasp is working on the server

#+BEGIN_SRC python
import sys

from ase import Atoms, Atom
from ase.structure import molecule
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
JASPRC['queue.walltime'] = '00:30:00'

atoms = molecule('C2H6')
atoms.center(vacuum=4)

ENCUTS = [300]
energies_en = []
forces_en = []
ready = True
for en in ENCUTS:
    job_name = '~/tmp/vasp_test/molecules/c2h6-en-{0}'.format(en)
    with jasp(job_name,
              encut=en,
              xc='PBE',
              atoms=atoms) as calc:
        try:
            energies_en.append(atoms.get_potential_energy())
            forces_en.append(atoms.get_forces())
        except (VaspSubmitted, VaspQueued):
            ready = False
            print("Still processing: {}".format(job_name))

if not ready:
    import sys; sys.exit()

print("{0:5s}    {1:7s}    {2:9s}".format("ENCUT", "Energy", "Max force"))
print("{0:5s}    {1:7s}    {2:9s}".format("", "[eV]", "[eV/Ang]"))
print("-----------------------------")
for i, energy, force in zip(ENCUTS, energies_en, forces_en):
    print("{0:5d}    {1:7.3f}    {2:9.3f}".format(i, energy, force.max()))
#+END_SRC

#+RESULTS:
: Still processing: ~/tmp/vasp_test/molecules/c2h6-en-300

** 2016-05-31: View atoms
#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
    
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]

def view_atoms(name):
    images = []
    for i, h in enumerate(heights):
	with jasp('./dft/' + name + '/d={0:0.2f}'.format(h)) as calc:
	    atoms = calc.get_atoms()
	    images.append(atoms)
    view(images)

base_name = 'transport/g-mono/3x3/pore=1/molec=CO2/'

name_free = base_name + 'linear-unconst_all'
#view_atoms(name_free)

name_uncon = base_name + 'linear-unconst_G'
#view_atoms(name_uncon)

name_con = base_name + 'linear-const'
view_atoms(name_con)
#+END_SRC

#+RESULTS:

** TODO 2016-06-02: Improve energy resolution at curves
Suggest more points to improve the resolution of a total energy curve for a transporting molecule through a 2D material plane.

#+BEGIN_SRC python


#+END_SRC

** 2016-07-07: ASE Neighbors

#+BEGIN_SRC python
from ase.neighborlist import NeighborList

import twodee as td


atoms = td.create_base("graphene", size=5)
nblist = NeighborList([0.75 for i in range(len(atoms))],
                      bothways=True,
                      self_interaction=False)
nblist.update(atoms)

nbs = nblist.get_neighbors(11)[0]
td.paint_atoms(atoms, nbs)
td.bp(atoms)
td.bp(nbs)
#+END_SRC

#+RESULTS:
: (array([12, 20, 10]), array([[0, 0, 0],
:        [0, 0, 0],
:        [0, 0, 0]]))

** 2016-07-07: Making better .gif's with ImageMagick
Currently, the following command leaves a lot of unwanted artifacts in .gif's of the pore candidate selection algorithm.

#+BEGIN_SRC sh :results silent
cd ./img/scripts/20160707-imagemagick/size=3/pore=5/
convert -delay 30 -loop 0 *.png ../../bad_example.gif
#+END_SRC

Output: [[file+sys:./img/scripts/20160707-imagemagick/bad_example.gif]]

Issues:
- Red dots have grey outline from previous carbons.
- Entire image occasionally goes grey.

Below are new attempts using different imagemagick command line arguments.

White background:
#+BEGIN_SRC sh :results silent
cd ./img/scripts/20160707-imagemagick/size=3/pore=5/
convert -delay 30 *.png -loop 0 -background white -alpha remove ../../white_bg.gif
#+END_SRC

Transparent background (*not working*):
#+BEGIN_SRC sh :results silent
cd ./img/scripts/20160707-imagemagick/size=3/pore=5/
convert -delay 30 *.png -loop 0 -background white -alpha remove ../../tmp.gif
convert ../../tmp.gif -fuzz 50% -transparent white ../../transparent_bg.gif
#+END_SRC

Other arguments tried:
#+BEGIN_EXAMPLE
-layers optimize  # messed up colors halfway through
-dither FloydSteinberg
#+END_EXAMPLE

** 2016-07-08: Collect png's from subdirectories for a gif

#+BEGIN_SRC python
def convert_subdirectories(path, delay=30, name=None):
    from subprocess import call
    import os

    path = os.path.dirname(path)
    walk = os.walk(path)
    subdirs = sorted(next(walk)[1])

    for s in subdirs:
        cwd = os.path.join(path, s)
        pngs = os.path.join(cwd, "*.png")
        gif = os.path.join(path, s + ".gif")
        cmd_convert = "convert -delay {2} {0} -loop 0 -background white -alpha remove {1}".format(pngs, gif, delay)
        call(cmd_convert, shell=True)

    combined = ""
    for s in subdirs:
        combined += os.path.join(path, s + ".gif ")
    if name is None:
        name = os.path.basename(path) + ".gif"
    name = os.path.join(path, name)
    cmd_combine = "convert " + combined + name
    call(cmd_combine, shell=True)


path = "./img/scripts/20160707-imagemagick/size=3/"  # directory in front of subdirectories containing .png's
print(convert_subdirectories(path))
#+END_SRC

#+RESULTS:
: None

** 2016-07-08: candidates with islands

#+BEGIN_SRC python :results drawer
from sets import Set

import twodee as td


graphene_cutoff = 1.5 # Angstrom. Should put this somewhere more permanent.

def candidates(atoms, layers, exclude=None, depth=None):
    pos_center = td.center_layer(atoms, layers[0])
    center_atom = td.closest_atom(atoms, pos_center)
    can = [center_atom]
    cans = [can]

    indices = [a.index for a in atoms if a.index not in exclude] #TODO devon: There's a cleaner way to do this. Need something for layers here?

    candidates_loop(atoms, indices, can, cans, center_atom, depth)

    return cans


def candidates_loop(atoms, indices, can, cans, index, depth, step=1):
    layer = [i for i in indices] #TODO devon: Clean up get_neighbors.
    neighbors = td.get_neighbors(atoms, index, layer, graphene_cutoff)

    if len(neighbors) == 1:
        n = neighbors[0]
        if depth is None or step + 1 < depth:
            candidates_loop(atoms, indices, can, cans, n, depth, step+1)
    
    neighbors = [n for n in neighbors if len(neighbors) > 1 and  n not in can]
    for n in neighbors:
        c = [i for i in can]
        c.append(n)
        c.sort()
        if c not in cans:
            cans.append(c)
            if depth is None or step + 1 < depth:
                candidates_loop(atoms, indices, c, cans, n, depth, step+1)
            

unitcell = td.create_base("graphene", layers=1)
size = 3
atoms = td.create_base("graphene", layers=1, size=size)
#td.bp(atoms)
layers = td.layers(atoms)
edges = td.edges(atoms, unitcell)#
cans = candidates(atoms, layers, exclude=edges)

td.bp([cans])
images = []
td.paint_atoms(atoms, edges)
for i, c in enumerate(cans):
    a = atoms.copy()
    td.paint_atoms(a, c, sym="O")
    td.write_image('movies/candidates-islands/size={1}/{0:0>4}'.format(i, size), a)

td.bp()
td.bp(cans)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 [[9], [8, 9], [9, 10], [9, 10, 11], [9, 10, 11, 16], [9, 10, 11, 15, 16], [9, 10, 11, 14, 15, 16], [9, 10, 11, 16, 17], [9, 14], [9, 14, 15], [9, 14, 15, 16], [9, 11, 14, 15, 16], [9, 14, 15, 16, 17]]

 :END:


 #+BEGIN_SRC python
A = [1, 2, 3, 4, 5]
for a in A:    
    if a == 2 or a == 6 and len(A) < 10:
        A.append(6)
print A
 #+END_SRC

 #+RESULTS:
 : [1, 2, 3, 4, 5, 6, 6, 6, 6, 6]

*** from twodee

#+BEGIN_SRC python
def candidates(atoms, edge=None, size=None):
    """Return candidate pore indices combinations."""
    from itertools import combinations

    cans = []
    indices = [a.index for a in atoms if a.index not in edge]

    nblist = NeighborList([graphene_cutoff for i in range(len(atoms))],
                          bothways=True,
                          self_interaction=False)
    nblist.update(atoms)

    def constraint_check(pores):
        for pore in pores:
            remains = [a.index for a in atoms if a.index not in pore]
            if is_connected(nblist, remains) and is_connected(nblist, pore):
                cans.append(pore)

    if size is not None:
        pores = combinations(indices, size)
        constraint_check(pores)
    else:
        for i in range(1, len(indices)):
            pores = combinations(indices, i)
            constraint_check(pores)

    return cans
#+END_SRC

** 2016-07-13: Kill duplicate jobs

*Warning*: This is unsafe since there is no specification of the user. If someone else submits a job in the middle of your batch, you could end up deleting their job.

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from vasp import Vasp
from vasp.vasprc import VASPRC
import numpy as np
VASPRC['queue.walltime'] = '24:00:00'

import twodee as td


#import inspect
#td.bp(inspect.getfile(Vasp))
a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])


name = 'tmp/script/duplicates-kpts={}'
calcs = [Vasp(name.format(k),
            xc='PBE',          # GGA functional type
            encut=520,
            kpts=[k,k,1],
            nsw=0,            # max number of steps to relax
            atoms=atoms)
         for k in np.arange(10,15,2)]

[c.calculate() for c in calcs]

td.bp()
nrg = [calc.potential_energy for calc in calcs]

print('energy = {0} eV'.format(atoms.get_potential_energy()))
td.print_image(name, atoms)
#+END_SRC

#+RESULTS:
:RESULTS:
/home-guest/devonw/hydrogen2D/tmp/script/duplicates-kpts=10 submitted: 1424259.gilgamesh.cheme.cmu.edu
/home-guest/devonw/hydrogen2D/tmp/script/duplicates-kpts=10 submitted: 1424260.gilgamesh.cheme.cmu.edu
/home-guest/devonw/hydrogen2D/tmp/script/duplicates-kpts=12 submitted: 1424261.gilgamesh.cheme.cmu.edu
/home-guest/devonw/hydrogen2D/tmp/script/duplicates-kpts=12 submitted: 1424262.gilgamesh.cheme.cmu.edu
/home-guest/devonw/hydrogen2D/tmp/script/duplicates-kpts=14 submitted: 1424263.gilgamesh.cheme.cmu.edu
/home-guest/devonw/hydrogen2D/tmp/script/duplicates-kpts=14 submitted: 1424264.gilgamesh.cheme.cmu.edu
:END:


#+BEGIN_SRC python
from subprocess import call

start = 1423042
end = 1423147

cmd = "qdel"
for i in range(start, end+1):
    if i % 2 == 1:
        cmd += " {}".format(i)
print(cmd)
#call(cmd, shell=True)
#+END_SRC

#+RESULTS:
: qdel 1423043 1423045 1423047 1423049 1423051 1423053 1423055 1423057 1423059 1423061 1423063 1423065 1423067 1423069 1423071 1423073 1423075 1423077 1423079 1423081 1423083 1423085 1423087 1423089 1423091 1423093 1423095 1423097 1423099 1423101 1423103 1423105 1423107 1423109 1423111 1423113 1423115 1423117 1423119 1423121 1423123 1423125 1423127 1423129 1423131 1423133 1423135 1423137 1423139 1423141 1423143 1423145 1423147

** 2016-07-13: Stats with a loop
From pycon 2016 https://www.youtube.com/watch?v=Iq9DzN6mvYA

#+BEGIN_SRC python
from numpy.random import randint

M = 0
for i in range(50000):
    trials = randint(2, size=30)
    if (trials.sum() >= 22):
        M += 1
p = M / 50000.
print(p)
#+END_SRC

#+RESULTS:
: 0.0085

** 2016-07-19: Walk a directory and create/update an ase-db

My calculations are stored in the vasp/ directory of this project. Let's make a script to collect all calculations and put them into an ase database.

#+BEGIN_SRC python
from ase.db import connect
import os
from vasp import Vasp
from vasp.vasprc import VASPRC
VASPRC['mode'] = None

import twodee as td


def db_update(db_path, dft_path, delete=False, silent=False):
    db = connect(db_path)
    old_size = sum(1 for _ in db.select())

    db_paths = []
    for d in db.select():
        db_paths.append(d.data.path)

    for path in td.calc_paths(dft_path):
        if os.path.abspath(path) in db_paths:
            continue
        calc = Vasp(path)

        if not calc.in_queue() and calc.potential_energy is None:
            for output_file in td.calc_output_files(path):
                dead_file = os.path.join(path, output_file)
                if delete:
                    os.remove(dead_file)
                if not silent:
                    print("Dead output file: {}. Deleted: {}".format(dead_file, delete))
        else:
            calc.write_db(db_path, parser='=',
                        overwrite=False,
                        data={'ctime': calc.get_elapsed_time()})
            if not silent:
                print("Added calc to DB: {}".format(path))

    new_size = sum(1 for _ in db.select())
    added = new_size - old_size
    if not silent:
        print("{} total entries. {} new entries added.".format(new_size, added))

db_update('database/script-20160719-4.db', 'vasp/type=base')
#+END_SRC

#+RESULTS:
: 2 total entries. 0 new entries added.

** 2016-07-21: Make twodee and td a module named twodee

Move utility code into the [[file+sys:./twodee/][twodee module]].

#+BEGIN_SRC python
print(list(globals()))

import twodee as td

print("")
print(list(globals()))

print("")
td.bp("Test")
#+END_SRC


#+RESULTS:
: ['__builtins__', '__name__', '__file__', '__doc__', '__package__']
: 
: ['__builtins__', '__file__', '__package__', 'GInitiallyUnowned', '__name__', 'td', '__doc__']
: 
: Test

** 2016-07-21: Check for duplicate entries in ase-db

Eliminate any duplicate entries in an ase-db.

Some light dictionary learning:
#+BEGIN_SRC python :results drawer
dic = {'Name1': 'Zara', 'Age': 7, 'Name2': 'Zara'}

keep = {}
for key, value in dic.items():
    if value not in keep.values():
        keep[key] = value

for key in dic.keys():
    if key not in keep:
        del dic[key]

for key in dic.keys():
    print(key)
for key in dic.values():
    print(key)

print(dic)
print(keep)
#+END_SRC

#+RESULTS:
:RESULTS:
Age
Name2
7
Zara
{'Age': 7, 'Name2': 'Zara'}
{'Age': 7, 'Name2': 'Zara'}
:END:

The main show:
#+BEGIN_SRC python
from ase.db import connect

import twodee as td


def db_duplicates(db_path, delete=False, reverse=False, silent=False):
    """Return duplicate IDs based on calculation paths."""
    db = connect(db_path)
    old_size = sum(1 for _ in db.select())

    db_paths = {}
    for d in db.select():
        db_paths[d.id] = d.data.path

    keep = {}
    items = reversed(db_paths.items()) if reverse else db_paths.items()
    for key, value in items:
        if value not in keep.values():
            keep[key] = value

    dup_keys = []
    for key in db_paths.keys():
        if key not in keep:
            if not silent:
                print("Duplicate: id={}: value={}".format(key, db_paths[key]))
            dup_keys.append(key)

    if delete: 
        db.delete(dup_keys)

    new_size = sum(1 for _ in db.select())
    deleted =  old_size - new_size
    if not silent:
        print("{} total entries. {} new entries deleted.".format(new_size, deleted))

    return dup_keys

db_duplicates('database/script-20160719.db', delete=False, reverse=False, silent=False)
#+END_SRC

#+RESULTS:
: 519 total entries. 0 new entries deleted.
: []

** 2016-07-21: Find a broken Vasp file in a directory

Find broken calculations in a nested directory.

#+BEGIN_SRC python :results drawer
import os
import re
import shutil
import sys
from vasp import Vasp
from vasp.vasprc import VASPRC
VASPRC['mode'] = None

import twodee as td

def broken_calcs(dft_path, delete=False, silent=False):
    """Return a list of broken calculation paths."""

    # Don't print to stdout for awhile. Vasp() prints error traces.
    stdout = sys.stdout
    f = open(os.devnull, 'w')
    sys.stdout = f

    broken_dirs = []
    for path in td.calc_paths(dft_path):
        try:
            calc = Vasp(path)
        except:
            broken_dirs.append(pwd[0])

    sys.stdout = stdout
    if not silent:
        if broken_dirs:
            print("Broken directories:")
            for b in broken_dirs:
                print("    {}".format(b))
        else:
            print("No broken directories found.")

    # Recursively delete the broken directories
    if delete:
        for b in broken_dirs:
            shutil.rmtree(b)
    
    return broken_dirs

td.bp(broken_calcs('vasp/type=point/mat=graphene/layers=1/size=4/pore=4', silent=False))
#+END_SRC

#+RESULTS:
:RESULTS:
No broken directories found.
[]
:END:

** 2016-07-22: candidates with json

#+BEGIN_SRC python :results drawer
import json
import os.path
from pprint import pprint
import time

import twodee as td

def candidates(mat='graphene', layers=1, size=1, pores=None,
               json_path='data/candidates.json', silent=False, overwrite=False):
    """Return candidate pore indices combinations for all pores."""
    if os.path.isfile(str(json_path)) and not overwrite:
        with open(json_path) as data_file:
            data = json.load(data_file)
    else:
        overwrite = True
        data = {'calculated': []}
    calculated = data['calculated']

    unitcell = td.create_base(mat, layers=layers)
    atoms = td.create_base(mat, layers=layers, size=size)

    edges = td.edges(atoms, unitcell)
    indices = [a.index for a in atoms if a.index not in edges]
    if pores is None:
        pores = range(len(indices)+1)

    def is_calculated(calculated, size, pore):
        for c in calculated:
            if c['size'] == size and c['pore'] == pore:
                return [c['candidates'], c['time']]
        return [None, None]

    times = []
    cans = []
    retrievals = []
    for pore in pores:
        if not overwrite:
            (c, t) = is_calculated(calculated, size, pore)
        else:
            c = None

        if c:
            cans.append(c)
            times.append(t)
            retrievals.append("From file")
            continue
        else:
            start = time.time()
            can = td.candidates2(atoms, edge=edges, pore_size=pore)
            end = time.time()

            cans.append(can)
            times.append(end - start)
            retrievals.append("Calculated")
            calc = {'mat': mat,
                    'layers': layers,
                    'size': size,
                    'pore': pore,
                    'candidates': can,
                    'time': times[-1]}
            calculated.append(calc)

    if json_path is not None:
        json.dumps({'calculated': [calculated]})
        with open(json_path, 'w') as data_file:
            json.dump(data, data_file)

    if not silent:
        print("| Graphene size | Pore size | # of candidates | Algo. time | Retrieval |")
        print("| (unitcell repititions) | (# carbons) | | (seconds) | |")
        print("|-----")
        for (p, c, t, r) in zip(pores, cans, times, retrievals):
            print("| {} | {} | {} | {:0.2f} | {} |".format(size, p, len(c), t, r)) 

        tot_num = 0
        tot_time = 0
        for (c, t) in zip(cans, times):
            tot_num += len(c)
            tot_time += t
        print("Total number of candidates: {}. Total time: {:0.2f} sec".format(tot_num, tot_time))
    
    return cans

candidates(mat='graphene', layers=1, size=4, pores=None,
           silent=False, overwrite=False)
#+END_SRC

 #+RESULTS:
 :RESULTS:
 |          Graphene size |   Pore size | # of candidates | Algo. time | Retrieval |
 | (unitcell repititions) | (# carbons) |                 |  (seconds) |           |
 |------------------------+-------------+-----------------+------------+-----------|
 |                      4 |           0 |               1 |       0.05 | From file |
 |                      4 |           1 |              18 |       0.09 | From file |
 |                      4 |           2 |              21 |       0.38 | From file |
 |                      4 |           3 |              32 |       1.75 | From file |
 |                      4 |           4 |              54 |       5.95 | From file |
 |                      4 |           5 |             102 |      15.78 | From file |
 |                      4 |           6 |             183 |      32.88 | From file |
 |                      4 |           7 |             310 |      52.57 | From file |
 |                      4 |           8 |             502 |      67.40 | From file |
 |                      4 |           9 |             730 |      68.57 | From file |
 |                      4 |          10 |             954 |      58.29 | From file |
 |                      4 |          11 |            1102 |      39.15 | From file |
 |                      4 |          12 |            1061 |      21.29 | From file |
 |                      4 |          13 |             808 |       9.89 | From file |
 |                      4 |          14 |             460 |       3.35 | From file |
 |                      4 |          15 |             186 |       0.90 | From file |
 |                      4 |          16 |              53 |       0.22 | From file |
 |                      4 |          17 |              10 |       0.07 | From file |
 |                      4 |          18 |               1 |       0.05 | From file |
 Total number of candidates: 6588. Total time: 378.64 sec
 :END:

** 2016-07-22: Run python script from queue

Script 1 (super basic) to run on queue:
#+BEGIN_SRC python :tangle ./queue/script-20160722-1.py
#!/usr/bin/env python

a = 4 + 2
print(a)
#+END_SRC

Script 2 to run:
#+BEGIN_SRC python :tangle ./queue/script-20160722-2.py
#!/usr/bin/env python
import twodee as td

#atoms = td.create_base('graphene', layers=1, size=3)
cans = td.candidates(mat='graphene', layers=1, size=3, pores=None, silent=False)
#+END_SRC


Queue caller:
#+BEGIN_SRC python
import os
import subprocess
import time

import twodee as td


def qsub(file_path):
    cwd = os.getcwd()
    wd = os.path.dirname(os.path.realpath(file_path))
    file_name = os.path.basename(file_path)
    os.chmod(file_path, 0777)

    cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -o {0}
#PBS -e {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=2GB
#PBS -joe
cd $PBS_O_WORKDIR
{1}
#end'''.format(wd, file_path)

    submit_path = os.path.join(wd, 'submit.sh')
    with open(submit_path, 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', submit_path])
    time.sleep(5)
    os.remove(submit_path)


qsub('./queue/script-20160722-2.py')
#+END_SRC

#+RESULTS:
: 1428308.gilgamesh.cheme.cmu.edu

** 2016-07-23: Queue candidate algorithm

#+BEGIN_SRC python
import twodee as td

sizes = [5, 6, 7]
for s in sizes:
    path = "./queue/candidates/{0}/cans={0}.py".format(s)
    prog= '''#!/usr/bin/env python
import twodee as td

cans = td.candidates(mat="graphene", layers=1, size={}, pores=None, silent=False)
'''.format(s)

    with open(path, 'w') as f:
        f.write(prog)
    td.qsub(path)
#+END_SRC

#+RESULTS:
: 1428756.gilgamesh.cheme.cmu.edu
: 1428757.gilgamesh.cheme.cmu.edu
: 1428758.gilgamesh.cheme.cmu.edu

Start time: 10:09pm Sunday

** TODO 2016-07-24: Get source code to queue submit file

#+BEGIN_SRC python
import re
import inspect

def test_func():
    """Testing..."""
    #!/usr/bin/env python
    import twodee as td

    #print("hello")
    return 1
#    cans = td.candidates(mat='graphene', layers=1, size=3,
#                         pores=None, silent=False)

#me = test_func()
#print(__file__)
print(test_func)
print(inspect.getsource(test_func))
#+END_SRC

#+RESULTS:

** 2016-07-24: Create a plot that shows neural network quality

Thinking a 3 plot subplot in a 2x2 grid. The top row will be occupied by the errors of network vs training and test.
1. Errors against training and test data
2. 

#+BEGIN_SRC python

#+END_SRC

** 2016-07-27: qsub decorator

Incomplete

#+BEGIN_SRC python :tangle tester.py
#!/usr/bin/env python

import ast, inspect
import dis
#from dill.source import getsource # didn't work with babel. worked with python -i. reads from interactive history.
import compiler
from functools import wraps
import sys

def qsub(path):
    def qsub_decorator(script):
        @wraps(script)
        def wrapper(*args, **kwargs):
            print("Submit to: " + path)
            print("#!/usr/bin/env python")
            print(script(*args, **kwargs))
            # stuck here. how to turn script into a submittable file?
            return
        return wrapper
    return qsub_decorator



@qsub("my_path/submit.py")
def add(x, y):
    """My docstring."""
    return x + y

    
add(2, 3)
#+END_SRC

#+RESULTS:
: 91
: Submit to: my_path/submit.py
: #!/usr/bin/env python
: 5

** 2016-07-28: Jinja2 template queue submission
*** DONE Toy template example
Add "/foobar" to a printed string.

#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/template_toy.py
#!/usr/bin/env python
print("{{ path }}" + "/foobar")
#+END_SRC


#+BEGIN_SRC python :results output org drawer
from jinja2 import Environment, FileSystemLoader
import os

pwd = os.path.dirname(os.path.abspath(__file__))
env = Environment(loader=FileSystemLoader(pwd))
template_path = 'scripts/2016-07-28/template_toy.py'
template = env.get_template(template_path)

exec(template.render(path=pwd))
#+END_SRC

#+RESULTS:
:RESULTS:
/home-guest/devonw/hydrogen2D/foobar
:END:

*** DONE Iteration 0: Amp runner template

#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/template_amp.py
#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Behler
from amp.regression import NeuralNetwork
from ase.db import connect
import os

db_path = "{{ db_path }}"
nn_dir = "{{ nn_dir }}"
nn_dir = os.path.join(nn_dir, "")
select = "{{ select }}"
cutoff = {{ cutoff }}
h_layers = {{ h_layers }}

db = connect(db_path)

images = []
for d in db.select(select):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

desc = Behler(cutoff=cutoff)
reg = NeuralNetwork(hiddenlayers=h_layers)
calc = Amp(label=nn_dir,
           descriptor=desc,
           regression=reg)

calc.train(images=images,
           data_format='db',
           cores=1,
           energy_goal=1e-3,
           force_goal=None,
           global_search=None,
           extend_variables=False)

print("Training completed")
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python :results output org drawer
from jinja2 import Environment, FileSystemLoader
import os
import twodee as td

pwd = os.path.dirname(os.path.abspath(__file__))
env = Environment(loader=FileSystemLoader(pwd))
template_path = 'scripts/2016-07-28/template_amp.py'
template = env.get_template(template_path)

db_path = 'scripts/2016-07-28/test_db.db'
select = 'train_set=True'
cutoff = 6.5
h_layers = [2, 3]
nodes = [2, 3]

for h in h_layers:
    for n in nodes:
        db_dir = os.path.dirname(db_path)
        framework = tuple([n]*h)
        framework_str = "-".join([str(f) for f in framework])
        nn_dir = os.path.join(db_dir, framework_str)

        if os.path.exists(os.path.join(nn_dir, 'submit.py')):
            print('{0} already submitted.'.format(framework_str))
            continue
        if not os.path.exists(nn_dir):
            os.makedirs(nn_dir)

        code = template.render(db_path=db_path, nn_dir=nn_dir,
                               select=select, cutoff=cutoff,
                               h_layers=framework)

        submit_file = os.path.join(nn_dir, 'submit.py')
        with open(submit_file, 'w') as f:
            f.write(code)

        td.qsub(submit_file, walltime="10:00:00")
        print('{0} submitted.'.format(framework_str))
#+END_SRC

#+RESULTS:
:RESULTS:
1432761.gilgamesh.cheme.cmu.edu
1432762.gilgamesh.cheme.cmu.edu
1432763.gilgamesh.cheme.cmu.edu
1432764.gilgamesh.cheme.cmu.edu
2-2 submitted.
3-3 submitted.
2-2-2 submitted.
3-3-3 submitted.
:END:

**** Example sybmit.py output
It's useful to grab the completed template and see if it runs without errors.

#+BEGIN_SRC python :results output org drawer
#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Behler
from amp.regression import NeuralNetwork
from ase.db import connect
import os
import twodee as td

db_path = "scripts/2016-07-28/test_validation.db"
nn_dir = "scripts/2016-07-28/8-8"
nn_dir = os.path.join(nn_dir, "")
select = "train_set=True"
cutoff = 6.5
h_layers = (8, 8)

db = connect(db_path)

images = []
for d in db.select(select):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

desc = Behler(cutoff=cutoff)
reg = NeuralNetwork(hiddenlayers=h_layers)
calc = Amp(label=nn_dir,
           descriptor=desc,
           regression=reg)

calc.train(images=images,
           data_format='db',
           cores=1,
           energy_goal=1e-3,
           force_goal=None,
           global_search=None,
           extend_variables=False)

print("Done")
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

*** DONE Iteration 1: More generic Amp runner template

#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/template_amp_generic1.py
#!/usr/bin/env python
from amp import Amp
from ase.db import connect

db_path = "{{ db_path }}"
select = "{{ select }}"

db = connect(db_path)

images = []
for d in db.select(select):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

from amp.descriptor import {{ desc_type }}
desc = {{ desc_type }}(**{{ desc_args }})

from amp.regression import {{ reg_type }}
reg = {{ reg_type }}(**{{ reg_args }})

calc = Amp(descriptor=desc,
           **{{ amp_args }})

calc.train(images=images,
           **{{ train_args }})

print("Training completed")
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python :results output org drawer
from jinja2 import Environment, FileSystemLoader
import os
import twodee as td

pwd = os.path.dirname(os.path.abspath(__file__))
env = Environment(loader=FileSystemLoader(pwd))
template_path = 'scripts/2016-07-28/template_amp_generic1.py'
template = env.get_template(template_path)

db_path = 'scripts/2016-07-28/test_db.db'
select = 'train_set=True'
cutoff = 6.5
h_layers = [2, 3]
nodes = [2, 3]

for h in h_layers:
    for n in nodes:
        db_dir = os.path.dirname(db_path)
        framework = tuple([n]*h)
        framework_str = "-".join([str(f) for f in framework])
        nn_dir = os.path.join(db_dir, "generic1", framework_str, "")

        if os.path.exists(os.path.join(nn_dir, 'submit.py')):
            print('{0} already submitted.'.format(framework_str))
            continue
        if not os.path.exists(nn_dir):
            os.makedirs(nn_dir)

        desc_type = "Behler"
        desc_args = {"cutoff": 6.5}
        reg_type = "NeuralNetwork"
        reg_args = {"hiddenlayers": framework}
        amp_args = {"label": nn_dir}
        train_args = {"data_format": 'db',
                      "cores": 1,
                      "energy_goal": 1e-3,
                      "force_goal": None,
                      "global_search": None,
                      "extend_variables": False}

        code = template.render(db_path=db_path, select=select,
                               desc_type=desc_type, desc_args=desc_args,
                               reg_type=reg_type, reg_args=reg_args,
                               amp_args=amp_args, train_args=train_args)

        submit_file = os.path.join(nn_dir, 'submit.py')
        with open(submit_file, 'w') as f:
            f.write(code)

        td.qsub(submit_file, walltime="10:00:00")
        print('{0} submitted.'.format(framework_str))
#+END_SRC

#+RESULTS:
:RESULTS:
1432765.gilgamesh.cheme.cmu.edu
1432766.gilgamesh.cheme.cmu.edu
1432767.gilgamesh.cheme.cmu.edu
1432768.gilgamesh.cheme.cmu.edu
2-2 submitted.
3-3 submitted.
2-2-2 submitted.
3-3-3 submitted.
:END:

*** DONE Iteration 2: Combining template

Header subtemplate
#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/templates/header.py
#!/usr/bin/env python
#+END_SRC

Footer subtemplate
#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/templates/footer.py
print({{ output }})
print("End of script reached successfully.")
#+END_SRC

Database subtemplate
#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/templates/ase_db_get.py
from ase.db import connect

db_path = "{{ db_path }}"
select = "{{ select }}"

db = connect(db_path)

images = []
for d in db.select(select):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]
#+END_SRC

Amp subtemplate has dependency on variable name for images
#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/templates/amp.py
from amp import Amp
from amp.descriptor import {{ desc_type }}
from amp.regression import {{ reg_type }}

desc = {{ desc_type }}(**{{ desc_args }})

reg = {{ reg_type }}(**{{ reg_args }})

calc = Amp(descriptor=desc,
           **{{ amp_args }})
#+END_SRC

Training subtemplate
#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/templates/amp_train.py
train_args = {{ train_args }}

{% if gs_type %}
# Define global search
from amp import {{ gs_type }}
gs = {{ gs_type }}(**{{ gs_args }})
train_args['global_search'] = gs

{% endif %}
calc.train(images=images,
           **train_args)
#+END_SRC

Remove params subtemplate
I think theres room for improvement here.
#+BEGIN_SRC python :results silent :tangle scripts/2016-07-28/templates/amp_remove_params.py
import os
wd = "{{ workdir }}"
os.unlink(os.path.join(wd, 'train-log.txt'))
os.unlink(os.path.join(wd, 'trained-parameters.json'))
#+END_SRC


Runner
#+BEGIN_SRC python :results output org drawer
from jinja2 import Environment, FileSystemLoader
import os
import twodee as td

pwd = os.path.dirname(os.path.abspath(__file__))
env = Environment(loader=FileSystemLoader(pwd))
template_path = 'scripts/2016-07-28/templates'
header = env.get_template(os.path.join(template_path, "header.py"))
footer = env.get_template(os.path.join(template_path, "footer.py"))
ase_db_get = env.get_template(os.path.join(template_path, "ase_db_get.py"))
amp = env.get_template(os.path.join(template_path, "amp.py"))
amp_train = env.get_template(os.path.join(template_path, "amp_train.py"))
amp_remove_params = env.get_template(os.path.join(template_path, "amp_remove_params.py"))

db_path = 'scripts/2016-07-28/test_db.db'
select = 'train_set=True'
cutoff = 6.5
h_layers = [2, 3]
nodes = [2, 3]

for h in h_layers:
    for n in nodes:
        db_dir = os.path.dirname(db_path)
        framework = tuple([n]*h)
        framework_str = "-".join([str(f) for f in framework])
        nn_dir = os.path.join(db_dir, "generic2", framework_str, "")

        if os.path.exists(os.path.join(nn_dir, 'submit.py')):
            print('{0} already submitted.'.format(framework_str))
            continue
        if not os.path.exists(nn_dir):
            os.makedirs(nn_dir)

        desc_type = "Behler"
        desc_args = {"cutoff": 6.5}
        reg_type = "NeuralNetwork"
        reg_args = {"hiddenlayers": framework}
        amp_args = {"label": nn_dir}

        gs_type = "SimulatedAnnealing"
        gs_args = {"temperature": 70, "steps": 50}
        train_args1 = {"data_format": 'db',
                       "cores": 1,
                       "energy_goal": 10,
                       "force_goal": None,
                       "extend_variables": False}

        train_args2 = {"data_format": 'db',
                       "cores": 1,
                       "energy_goal": 1e-3,
                       "force_goal": None,
                       "extend_variables": False}
        output = "\"Training completed.\""

        codes = []
        codes.append(header.render())
        codes.append(ase_db_get.render(db_path=db_path, select=select))
        codes.append(amp.render(desc_type=desc_type,
                                desc_args=desc_args,
                                reg_type=reg_type,
                                reg_args=reg_args,
                                amp_args=amp_args))
        codes.append(amp_train.render(train_args=train_args1,
                                      gs_type=gs_type,
                                      gs_args=gs_args))
        codes.append(amp_remove_params.render(workdir=nn_dir))
        codes.append(amp_train.render(train_args=train_args2))
        codes.append(footer.render(output=output))
        code = "\n\n".join(codes)

        submit_file = os.path.join(nn_dir, 'submit.py')
        with open(submit_file, 'w') as f:
            f.write(code)

        td.qsub(submit_file, walltime="10:00:00")
        print('{0} submitted.'.format(framework_str))
#+END_SRC

#+RESULTS:
:RESULTS:
1432779.gilgamesh.cheme.cmu.edu
1432780.gilgamesh.cheme.cmu.edu
1432781.gilgamesh.cheme.cmu.edu
1432782.gilgamesh.cheme.cmu.edu
2-2 submitted.
3-3 submitted.
2-2-2 submitted.
3-3-3 submitted.
:END:

*** TODO Iteration 3: Moving functions into twodee
* twodee

Module to help me write code in this project. This header serves as a testing ground for the module.

** ase_utils
*** candidates

#+BEGIN_SRC python :results drawer
import twodee as td

cans = td.candidates(mat='graphene', layers=1, size=4, pores=None,
                     json_path='data/candidates.json', silent=False,
                     write=True, overwrite_file=False)
#+END_SRC

#+RESULTS:
:RESULTS:
|          Graphene size |   Pore size | # of candidates | Algo. time | Retrieval |
| (unitcell repititions) | (# carbons) |                 |  (seconds) |           |
|------------------------+-------------+-----------------+------------+-----------|
|                      4 |           0 |               1 |       0.05 | From file |
|                      4 |           1 |              18 |       0.09 | From file |
|                      4 |           2 |              21 |       0.38 | From file |
|                      4 |           3 |              32 |       1.75 | From file |
|                      4 |           4 |              54 |       5.95 | From file |
|                      4 |           5 |             102 |      15.78 | From file |
|                      4 |           6 |             183 |      32.88 | From file |
|                      4 |           7 |             310 |      52.57 | From file |
|                      4 |           8 |             502 |      67.40 | From file |
|                      4 |           9 |             730 |      68.57 | From file |
|                      4 |          10 |             954 |      58.29 | From file |
|                      4 |          11 |            1102 |      39.15 | From file |
|                      4 |          12 |            1061 |      21.29 | From file |
|                      4 |          13 |             808 |       9.89 | From file |
|                      4 |          14 |             460 |       3.35 | From file |
|                      4 |          15 |             186 |       0.90 | From file |
|                      4 |          16 |              53 |       0.22 | From file |
|                      4 |          17 |              10 |       0.07 | From file |
|                      4 |          18 |               1 |       0.05 | From file |
Total number of candidates: 6588. Total time: 378.64 sec
:END:

*** candidates_combos

 #+BEGIN_SRC python :results drawer
import twodee as td
import time

unitcell = td.create_base("graphene", layers=1)
size = 4
atoms = td.create_base("graphene", layers=1, size=size)

edges = td.edges(atoms, unitcell)
indices = [a.index for a in atoms if a.index not in edges]

pore_sizes = range(len(indices)+1)
#pore_sizes = [0, 1, 2, 3, 4, 5]
times = []
cans = []
for pore_size in pore_sizes:
    start = time.time()
    cans.append(td.candidates(atoms, edge=edges, size=pore_size))
    end = time.time()
    times.append(end - start)

# Image generator for .gifs
#    images = []
#    td.paint_atoms(atoms, edges)
#    for i, c in enumerate(cans):
#        a = atoms.copy()
#        td.paint_atoms(a, c, sym="O")
#        file_name = 'tmp/size={1}/pore={2}/{0:0>4}'
#        file_name = file_name.format(i, size, pore_size)
#        td.write_image(file_name, a)


print("| Graphene size | Pore size | # of candidates | Algo. time |")
print("| (unitcell repititions) | (# carbons) | | (seconds) |")
for (p, c, t) in zip(pore_sizes, cans, times):
    print("| {} | {} | {} | {:0.2f} |".format(size, p, len(c), t)) 

tot_num = 0
tot_time = 0
for (c, t) in zip(cans, times):
    tot_num += len(c)
    tot_time += t
print("Total number of candidates: {}. Total time: {:0.2f} sec".format(tot_num, tot_time))
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 |          Graphene size |   Pore size | # of candidates | Algo. time |
 | (unitcell repititions) | (# carbons) |                 |  (seconds) |
 |                      4 |           0 |               1 |       0.05 |
 |                      4 |           1 |              18 |       0.09 |
 |                      4 |           2 |              21 |       0.38 |
 |                      4 |           3 |              32 |       1.70 |
 |                      4 |           4 |              54 |       5.97 |
 |                      4 |           5 |             102 |      15.69 |
 |                      4 |           6 |             183 |      32.08 |
 |                      4 |           7 |             310 |      51.44 |
 |                      4 |           8 |             502 |      66.04 |
 |                      4 |           9 |             730 |      67.64 |
 |                      4 |          10 |             954 |      57.04 |
 |                      4 |          11 |            1102 |      38.68 |
 |                      4 |          12 |            1061 |      21.33 |
 |                      4 |          13 |             808 |       9.32 |
 |                      4 |          14 |             460 |       3.28 |
 |                      4 |          15 |             186 |       0.89 |
 |                      4 |          16 |              53 |       0.22 |
 |                      4 |          17 |              10 |       0.07 |
 |                      4 |          18 |               1 |       0.05 |
 Total number of candidates: 6588. Total time: 371.95 sec
 :END:


 |          Graphene size |   Pore size | Old algo. time | New algo. time |
 | (unitcell repititions) | (# carbons) |      (seconds) |      (seconds) |
 |------------------------+-------------+----------------+----------------|
 |                      3 |           0 |                |           0.03 |
 |                      3 |           1 |            0.1 |           0.03 |
 |                      3 |           2 |            0.3 |           0.05 |
 |                      3 |           3 |            0.5 |           0.07 |
 |                      3 |           4 |            0.6 |           0.07 |
 |                      3 |           5 |            0.5 |           0.06 |
 |                      3 |           6 |            0.2 |           0.04 |
 |                      3 |           7 |            0.1 |           0.03 |
 |                      3 |           8 |                |           0.03 |
 |                      4 |           0 |                |           0.05 |
 |                      4 |           1 |            0.7 |           0.09 |
 |                      4 |           2 |            5.3 |           0.37 |
 |                      4 |           3 |           26.9 |           1.69 |
 |                      4 |           4 |           95.1 |           5.87 |
 |                      4 |           5 |                |          15.58 |



**** Results - size=2

 |          Graphene size |   Pore size | # of candidates | Algo. time |
 | (unitcell repititions) | (# carbons) |                 |  (seconds) |
 |                      2 |           0 |               1 |       0.01 |
 |                      2 |           1 |               2 |       0.01 |
 |                      2 |           2 |               1 |       0.01 |
 Total number of candidates: 4. Total time: 0.04 sec

**** Results - size=3

 |          Graphene size |   Pore size | # of candidates | Algo. time |
 | (unitcell repititions) | (# carbons) |                 |  (seconds) |
 |                      3 |           0 |               1 |       0.03 |
 |                      3 |           1 |               8 |       0.03 |
 |                      3 |           2 |               8 |       0.05 |
 |                      3 |           3 |              10 |       0.07 |
 |                      3 |           4 |              12 |       0.07 |
 |                      3 |           5 |              14 |       0.06 |
 |                      3 |           6 |              13 |       0.04 |
 |                      3 |           7 |               6 |       0.03 |
 |                      3 |           8 |               1 |       0.03 |
 Total number of candidates: 73. Total time: 0.41 sec

**** Results - size=4

 |          Graphene size |   Pore size | # of candidates | Algo. time |
 | (unitcell repititions) | (# carbons) |                 |  (seconds) |
 |                      4 |           0 |               1 |       0.05 |
 |                      4 |           1 |              18 |       0.09 |
 |                      4 |           2 |              21 |       0.38 |
 |                      4 |           3 |              32 |       1.70 |
 |                      4 |           4 |              54 |       5.97 |
 |                      4 |           5 |             102 |      15.69 |
 |                      4 |           6 |             183 |      32.08 |
 |                      4 |           7 |             310 |      51.44 |
 |                      4 |           8 |             502 |      66.04 |
 |                      4 |           9 |             730 |      67.64 |
 |                      4 |          10 |             954 |      57.04 |
 |                      4 |          11 |            1102 |      38.68 |
 |                      4 |          12 |            1061 |      21.33 |
 |                      4 |          13 |             808 |       9.32 |
 |                      4 |          14 |             460 |       3.28 |
 |                      4 |          15 |             186 |       0.89 |
 |                      4 |          16 |              53 |       0.22 |
 |                      4 |          17 |              10 |       0.07 |
 |                      4 |          18 |               1 |       0.05 |
 Total number of candidates: 6588. Total time: 371.95 sec

*** candidates - leaves islands

 #+BEGIN_SRC python :results drawer
from sets import Set

import twodee as td


graphene_cutoff = 1.5 # Angstrom. Should put this somewhere more permanent.

def candidates(atoms, layers, exclude=None, depth=None):
    pos_center = td.center_layer(atoms, layers[0])
    center_atom = td.closest_atom(atoms, pos_center)
    can = [center_atom]
    cans = [can]

    indices = [a.index for a in atoms if a.index not in exclude] #TODO devon: There's a cleaner way to do this. Need something for layers here?

    candidates_loop(atoms, indices, can, cans, center_atom, depth)

    return cans


def candidates_loop(atoms, indices, can, cans, index, depth, step=1):
    layer = [i for i in indices] #TODO devon: Clean up get_neighbors.
    neighbors = td.get_neighbors(atoms, index, layer, graphene_cutoff)

    if len(neighbors) == 1:
        n = neighbors[0]
        if depth is None or step + 1 < depth:
            candidates_loop(atoms, indices, can, cans, n, depth, step+1)
    
    neighbors = [n for n in neighbors if len(neighbors) > 1 and  n not in can]
    for n in neighbors:
        c = [i for i in can]
        c.append(n)
        c.sort()
        if c not in cans:
            cans.append(c)
            if depth is None or step + 1 < depth:
                candidates_loop(atoms, indices, c, cans, n, depth, step+1)
            

unitcell = td.create_base("graphene", layers=1)
size = 3
atoms = td.create_base("graphene", layers=1, size=size)
#td.bp(atoms)
layers = td.layers(atoms)
edges = td.edges(atoms, unitcell)#
cans = candidates(atoms, layers, exclude=edges)

td.bp([cans])
images = []
td.paint_atoms(atoms, edges)
for i, c in enumerate(cans):
    a = atoms.copy()
    td.paint_atoms(a, c, sym="O")
    td.write_image('movies/candidates-islands/size={1}/{0:0>4}'.format(i, size), a)

td.bp()
td.bp(cans)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 [[9], [8, 9], [9, 10], [9, 10, 11], [9, 10, 11, 16], [9, 10, 11, 15, 16], [9, 10, 11, 14, 15, 16], [9, 10, 11, 16, 17], [9, 14], [9, 14, 15], [9, 14, 15, 16], [9, 11, 14, 15, 16], [9, 14, 15, 16, 17]]

 :END:


 #+BEGIN_SRC python
A = [1, 2, 3, 4, 5]
for a in A:    
    if a == 2 or a == 6 and len(A) < 10:
        A.append(6)
print A
 #+END_SRC

 #+RESULTS:
 : [1, 2, 3, 4, 5, 6, 6, 6, 6, 6]

*** center_layer

 #+BEGIN_SRC python :results drawer
import twodee as td

atoms = td.create_base("graphene", layers=2, size=4)
layers = td.layers(atoms)
center1 = td.center_layer(atoms, layers[0])
center2 = td.center_layer(atoms, layers[1])
c1 = td.closest_atom(atoms, center1)
c2 = td.closest_atom(atoms, center2)
td.paint_atoms(atoms, [c1, c2])
td.bp(atoms)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 :END:

*** create_base

 #+BEGIN_SRC python :results drawer
import twodee as td

atoms = td.create_base("graphene", size=5)

td.bp(atoms)
 #+END_SRC

 #+RESULTS:

*** db_update

#+BEGIN_SRC python
import twodee as td

td.db_update('database/master.db', 'vasp')
#+END_SRC

#+RESULTS:
: 670 total entries. 0 new entries added.

*** edges

 #+BEGIN_SRC python :results drawer
import twodee as td

unitcell = td.create_base("graphene", layers=2)
atoms = td.create_base("graphene", layers=2, size=5)

e = td.edges(atoms, unitcell)
td.paint_atoms(atoms, e)
td.bp(atoms)
td.bp([e])
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 :END:

*** is_connected

 #+BEGIN_SRC python
import twodee as td
import time


graphene_cutoff = 1.5 # Angstrom. Should put this somewhere more permanent.


def candidates(atoms, edge=None, size=None):
    """Return candidate pore indices combinations."""
    from itertools import combinations

    cans = []
    indices = [a.index for a in atoms if a.index not in edge]

    nblist = NeighborList([graphene_cutoff for i in range(len(atoms))],
                          bothways=True,
                          self_interaction=False)
    nblist.update(atoms)


    def constraint_check(pores):
        for pore in pores:
            remains = [a.index for a in atoms if a.index not in pore]
            if is_connected(nblist, remains) and is_connected(nblist, pore):
                cans.append(pore)

    if size is not None:
        pores = combinations(indices, size)
        constraint_check(pores)
    else:
        for i in range(1, len(indices)):
            pores = combinations(indices, i)
            constraint_check(pores)

    return cans

unitcell = td.create_base("graphene", layers=1)
size = 3
atoms = td.create_base("graphene", layers=1, size=size)

edges = td.edges(atoms, unitcell)#

#td.bp(atoms)
start = time.time()
print(td.is_connected(atoms, [8, 9, 10]))
end = time.time()
print(end-start)
start = time.time()
print(td.is_connected_working(atoms, [8, 9, 10]))
end = time.time()
print(end-start)
print(td.is_connected_working(atoms, [8, 9, 10]))
print(td.is_connected(atoms, [8, 10, 14]))
print(td.is_connected(atoms, [9]))
td.bp()
 #+END_SRC

 #+RESULTS:
 : True
 : 0.0273470878601
 : False
 : 0.00108289718628
 : False
 : True

*** get_neighbors

 Presentation: show layers[0] and layers[1]

 #+BEGIN_SRC python
import twodee as td

atoms = td.create_base("graphene", layers=2, size=5)
index = 45
layers = td.layers(atoms)
neighbors = td.get_neighbors(atoms, index, layers[0], cutoff=1.5)
td.paint_atoms(atoms, [index])
td.paint_atoms(atoms, neighbors, sym='O')
td.bp(atoms)
 #+END_SRC

** amp_utils
** utils
*** bp - breakpoint

#+BEGIN_SRC python
import twodee as td

atoms = td.create_base("graphene", layers=1, size=3)
#td.bp(atoms)

tester = [0, 1, 2]
#td.bp(tester)
td.bp([tester])
#+END_SRC

#+RESULTS:
: [0, 1, 2]
: 

*** qsub

#+BEGIN_SRC python :tangle ./queue/candidates/7/cans=7.py
import twodee as td
sizes = [5, 6, 7]
path = "./queue/candidates/".format
prog= '''#!/usr/bin/env python
import twodee as td

cans = td.candidates(mat="graphene", layers=1, size=7, pores=None, silent=False)
'''
#+END_SRC

#+BEGIN_SRC python
import twodee as td

td.qsub("./queue/candidates/7/cans=7.py")
#+END_SRC

#+RESULTS:
: 1428315.gilgamesh.cheme.cmu.edu

* Vasp

Calculations using the new Vasp().

** Convergence

Tests for energy convergence based on different calculation parameters.

*** DONE mat=graphene/layers=1/size=1/pore=0 - kpts
    CLOSED: [2016-06-22 Wed 10:11]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp

import twodee as td


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

ks = [3, 5, 7, 9, 11, 13, 15, 17]
energies = []
for k in ks:
    atoms = unitcell.copy()
    name = 'vasp/type=conv/mat=graphene/layers=1/size=1/pore=0/kpts={0}'.format(k)
    calc = Vasp(name,
                xc='PBE',          # GGA functional type
                encut=520,
                kpts=[k,k,1],
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms)
    td.result('kpts={0:2.0f} x {0:2.0f} x 1'.format(k), calc)
    energies.append(atoms.get_potential_energy())

plt.plot(ks, energies)
plt.xlabel("k-points (i x i x 1)")
plt.ylabel("Total energy [eV]")
td.print_image(name + '.png', plt)
#+END_SRC

#+RESULTS:
:RESULTS:
kpts= 3 x  3 x 1: Energy = -17.8966. Calc time: 0 min.
kpts= 5 x  5 x 1: Energy = -18.4222. Calc time: 0 min.
kpts= 7 x  7 x 1: Energy = -18.4602. Calc time: 0 min.
kpts= 9 x  9 x 1: Energy = -18.4329. Calc time: 1 min.
kpts=11 x 11 x 1: Energy = -18.4479. Calc time: 1 min.
kpts=13 x 13 x 1: Energy = -18.4494. Calc time: 1 min.
kpts=15 x 15 x 1: Energy = -18.4446. Calc time: 2 min.
kpts=17 x 17 x 1: Energy = -18.4477. Calc time: 1 min.
[[./img/vasp/type=conv/mat=graphene/layers=1/size=1/pore=0/kpts=17.png]]
:END:

An 11x11x1 k-point grid is converged within 10 meV.

*** DONE mat=graphene/layers=1/size=1/pore=0 - ediffg
    CLOSED: [2016-06-22 Wed 10:11]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from vasp import Vasp

import twodee as td


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

ediffgs = [1e-2, 1e-3, 1e-4, -0.1, -0.05, -0.01]

for e in ediffgs:
    atoms = unitcell.copy()
    name = 'vasp/type=conv/mat=graphene/layers=1/size=1/pore=0/ediffg={0}'.format(e)
    calc = Vasp(name,
                xc='PBE',          # GGA functional type
                encut=520,
                kpts=[5,5,1],
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                ediffg=e,
                atoms=atoms)
    td.result('ediffg={0:7.4f}'.format(e), calc)
#+END_SRC

#+RESULTS:
:RESULTS:
ediffg= 0.0100: Energy = -18.4222. Calc time: 1 min.
ediffg= 0.0010: Energy = -18.4222. Calc time: 0 min.
ediffg= 0.0001: Energy = -18.4222. Calc time: 0 min.
ediffg=-0.1000: Energy = -18.4222. Calc time: 0 min.
ediffg=-0.0500: Energy = -18.4222. Calc time: 1 min.
ediffg=-0.0100: Energy = -18.4222. Calc time: 0 min.
:END:

This is a simple unitcell so the time wasn't greatly affected. Would be better to check this against a complicated pore structure.

*** DONE mat=graphene/layers=1/size=1/pore=0 - sigma
    CLOSED: [2016-07-19 Tue 15:02]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from vasp import Vasp

import twodee as td


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

sigmas = [0.01, 0.05, 0.1, 0.15, 0.2, 0.25]

for s in sigmas:
    atoms = unitcell.copy()
    name = 'vasp/type=conv/mat=graphene/layers=1/size=1/pore=0/sigma={0}'.format(s)
    calc = Vasp(name,
                xc='PBE',          # GGA functional type
                encut=520,
                kpts=[9,9,1],
                ismear=0,          # Gaussian smearing
                sigma=s,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms)
    td.result('sigma={0:4.2f}'.format(s), calc)
#+END_SRC

#+RESULTS:
:RESULTS:
sigma=0.01: Energy = -18.4302. Calc time: 1 min.
sigma=0.05: Energy = -18.4308. Calc time: 1 min.
sigma=0.10: Energy = -18.4315. Calc time: 0 min.
sigma=0.15: Energy = -18.4322. Calc time: 0 min.
sigma=0.20: Energy = -18.4329. Calc time: 1 min.
sigma=0.25: Energy = -18.4336. Calc time: 1 min.
:END:

*** DONE mat=graphene/layers=1/size=1/pore=0 - cell size
    CLOSED: [2016-06-22 Wed 10:26]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp

import twodee as td


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

zs = [6, 10, 14, 16, 18, 20, 22, 24, 26]
energies = []
for z in zs:
    atoms = unitcell.copy()
    td.set_vacuum(atoms, z)
    name = 'vasp/type=conv/mat=graphene/layers=1/size=1/pore=0/vac={0}'.format(z)
    calc = Vasp(name,
                xc='PBE',          # GGA functional type
                encut=520,
                kpts=[11,11,1],
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms)
    td.result('vacuum z={0:2d}'.format(z), calc)
    energies.append(atoms.get_potential_energy())

if None not in energies:
    plt.plot(zs, energies)
    plt.xlabel("Vacuum in z-direction [$\AA$]")
    plt.ylabel("Total energy [eV]")
    td.print_image(name + '.png', plt)
#+END_SRC

#+RESULTS:
:RESULTS:
vacuum z= 6: Energy = -18.4281. Calc time: 0 min.
vacuum z=10: Energy = -18.4477. Calc time: 0 min.
vacuum z=14: Energy = -18.4466. Calc time: 0 min.
vacuum z=16: Energy = -18.4471. Calc time: 0 min.
vacuum z=18: Energy = -18.4479. Calc time: 1 min.
vacuum z=20: Energy = -18.4480. Calc time: 1 min.
vacuum z=22: Energy = -18.4480. Calc time: 0 min.
vacuum z=24: Energy = -18.4469. Calc time: 1 min.
vacuum z=26: Energy = -18.4471. Calc time: 1 min.
[[./img/vasp/type=conv/mat=graphene/layers=1/size=1/pore=0/vac=26.png]]
:END:

The structure is converged within 10 meV at a vacuum distance of 16 Å between graphene layers.

*** DONE mat=graphene/layers=1/size=1/pore=0 - ismear
    CLOSED: [2016-07-13 Wed 11:40]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp

import twodee as td


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

ismears = [0, 1]
energies = []
for ismear in ismears:
    atoms = unitcell.copy()
    name = 'vasp/type=conv/mat=graphene/layers=1/size=1/pore=0/ismear={0}'.format(ismear)
    calc = Vasp(name,
                xc='PBE',          # GGA functional type
                encut=520,
                kpts=[11,11,1],
                ismear=ismear,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms)
    td.result('vacuum ismear={0:2d}'.format(ismear), calc)
    energies.append(atoms.get_potential_energy())
#+END_SRC
#+RESULTS:
:RESULTS:
vacuum ismear= 0: Energy = -18.4479. Calc time: 1 min.
vacuum ismear= 1: Energy = -18.4475. Calc time: 1 min.
:END:

*** DONE mat=graphene/layers=1/size=2/pore=1 - kpts
    CLOSED: [2016-07-20 Wed 15:17]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp

import twodee as td


atoms = td.create_base("graphene", layers=1, size=2)
pore = [6]
atoms = td.make_pore(atoms, pore)

ks = [1, 3, 5, 7, 9, 11, 13]
energies = []
for k in ks:
    name = 'vasp/type=conv/mat=graphene/layers=1/size=2/pore=1/kpts={0}'.format(k)
    calc = Vasp(name,
                xc='PBE',
                encut=520,
                kpts=[k,k,1],
                nsw=0,            # max number of steps to relax
                atoms=atoms)

#    calc.calculate()
    td.result('kpts={0:2.0f} x {0:2.0f} x 1'.format(k), calc)
    energies.append(calc.potential_energy)

plt.plot(ks, energies)
plt.xlabel("k-points (i x i x 1)")
plt.ylabel("Total energy [eV]")
td.print_image(name + '.png', plt)
#+END_SRC

#+RESULTS:
:RESULTS:
kpts= 1 x  1 x 1: Energy = -53.5153. Calc time: 1 min.
kpts= 3 x  3 x 1: Energy = -56.9233. Calc time: 1 min.
kpts= 5 x  5 x 1: Energy = -57.2501. Calc time: 2 min.
kpts= 7 x  7 x 1: Energy = -57.2524. Calc time: 3 min.
kpts= 9 x  9 x 1: Energy = -57.2337. Calc time: 5 min.
kpts=11 x 11 x 1: Energy = -57.2349. Calc time: 7 min.
kpts=13 x 13 x 1: Energy = -57.2358. Calc time: 8 min.
[[./img/vasp/type=conv/mat=graphene/layers=1/size=2/pore=1/kpts=13.png]]
:END:

*** DONE mat=graphene/layers=1/size=3/pore=3 - kpts
    CLOSED: [2016-07-18 Mon 16:25]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp

import twodee as td
import twodee as td


atoms = td.create_base("graphene", layers=1, size=3)
pore = [8, 9, 10]
atoms = td.make_pore(atoms, pore)

ks = [1, 3, 5, 7, 9, 11, 13]
energies = []
for k in ks:
    name = 'vasp/type=conv/mat=graphene/layers=1/size=3/pore=3/kpts={0}'.format(k)
    calc = Vasp(name,
                xc='PBE',
                encut=520,
                kpts=[k,k,1],
                nsw=0,            # max number of steps to relax
                atoms=atoms)
    td.result('kpts={0:2.0f} x {0:2.0f} x 1'.format(k), calc)
    energies.append(calc.potential_energy)

plt.plot(ks, energies)
plt.xlabel("k-points (i x i x 1)")
plt.ylabel("Total energy [eV]")
td.print_image(name + '.png', plt)
#+END_SRC

#+RESULTS:
:RESULTS:
kpts= 1 x  1 x 1: Energy = -126.475. Calc time: 5 min.
kpts= 3 x  3 x 1: Energy = -125.671. Calc time: 42 min.
kpts= 5 x  5 x 1: Energy = -125.703. Calc time: 40 min.
kpts= 7 x  7 x 1: Energy = -125.703. Calc time: 86 min.
kpts= 9 x  9 x 1: Energy = -125.702. Calc time: 112 min.
kpts=11 x 11 x 1: Energy = -125.702. Calc time: 166 min.
kpts=13 x 13 x 1: Energy = -125.702. Calc time: 213 min.
[[./img/vasp/type=conv/mat=graphene/layers=1/size=3/pore=3/kpts=13.png]]
:END:

K-points are converged to 10 meV at a grid of 5x5x1.

*** DONE mat=graphene/layers=1/size=4/pore=0,3,4,5 - kpts
    CLOSED: [2016-07-22 Fri 13:51]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp

import twodee as td


size = 4
supercell = td.create_base("graphene", layers=1, size=size)
pores = [[], [10, 11, 12], [10, 11, 12, 18], [10, 11, 12, 13, 18]]

ks = [1, 3, 5, 7, 9]
energies = []
for pore in pores:
    atoms = supercell.copy()
    atoms = td.make_pore(atoms, pore)
    for k in ks:
        name = 'vasp/type=conv/mat=graphene/layers=1/size=4/pore={}/kpts={}'.format(len(pore), k)
        calc = Vasp(name,
                    xc='PBE',
                    encut=520,
                    kpts=[k,k,1],
                    nsw=0,            # max number of steps to relax
                    atoms=atoms)

#        calc.calculate()
#        calc.potential_energy
        td.result('kpts={0:2.0f} x {0:2.0f} x 1'.format(k), calc)
#        energies.append(calc.potential_energy)
#
#td.bp()
#plt.plot(ks, energies)
#plt.xlabel("k-points (i x i x 1)")
#plt.ylabel("Total energy [eV]")
#td.print_image(name + '.png', plt)
#+END_SRC

#+RESULTS:
:RESULTS:
kpts= 1 x  1 x 1: Energy = -295.657. Calc time: 30 min.
kpts= 3 x  3 x 1: Energy = -295.050. Calc time: 122 min.
kpts= 5 x  5 x 1: Energy = -295.164. Calc time: 248 min.
kpts= 7 x  7 x 1: Energy = -295.164. Calc time: 192 min.
kpts= 9 x  9 x 1: Energy = -295.158. Calc time: 284 min.
kpts= 1 x  1 x 1: Energy = -254.750. Calc time: 42 min.
kpts= 3 x  3 x 1: Energy = -254.313. Calc time: 218 min.
kpts= 5 x  5 x 1: Energy = -254.317. Calc time: 209 min.
kpts= 7 x  7 x 1: Energy = -254.317. Calc time: 492 min.
kpts= 9 x  9 x 1: Energy = -254.317. Calc time: 861 min.
kpts= 1 x  1 x 1: Energy = -243.580. Calc time: 68 min.
kpts= 3 x  3 x 1: Energy = -243.175. Calc time: 78 min.
kpts= 5 x  5 x 1: Energy = -243.190. Calc time: 262 min.
kpts= 7 x  7 x 1: Energy = -243.191. Calc time: 301 min.
kpts= 9 x  9 x 1: Energy = -243.190. Calc time: 510 min.
kpts= 1 x  1 x 1: Energy = -232.257. Calc time: 31 min.
kpts= 3 x  3 x 1: Energy = -231.688. Calc time: 243 min.
kpts= 5 x  5 x 1: Energy = -231.691. Calc time: 372 min.
kpts= 7 x  7 x 1: Energy = -231.693. Calc time: 458 min.
kpts= 9 x  9 x 1: Energy = -231.692. Calc time: 1163 min.
:END:

K-points are converged to 10 meV at a grid of 5x5x1.

*** INPROGRESS mat=graphene/layers=1/size=5/pore=0,1,2,3,4,5 - kpts

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp

import twodee as td


size = 5
supercell = td.create_base("graphene", layers=1, size=size)
pores = [[], [12], [12, 13], [12, 13, 14], [12, 13, 14, 22], [12, 13, 14, 22, 15]]

ks = [1, 3, 5, 7]
energies = []
for pore in pores:
    atoms = supercell.copy()
    atoms = td.make_pore(atoms, pore)
    for k in ks:
        name = 'vasp/type=conv/mat=graphene/layers=1/size={}/pore={}/kpts={}'.format(size, len(pore), k)
        calc = Vasp(name,
                    xc='PBE',
                    encut=520,
                    kpts=[k,k,1],
                    nsw=0,            # max number of steps to relax
                    atoms=atoms)

        td.result('kpts={0:2.0f} x {0:2.0f} x 1'.format(k), calc)
#        energies.append(calc.potential_energy)
#Vasp.stop_if(None in energies)
#
#plt.plot(ks, energies)
#plt.xlabel("k-points (i x i x 1)")
#plt.ylabel("Total energy [eV]")
#td.print_image(name + '.png', plt)
#+END_SRC

#+RESULTS:
:RESULTS:
kpts= 1 x  1 x 1: Energy = -460.536. Calc time: 133 min.
kpts= 3 x  3 x 1: Energy = -461.102. Calc time: 228 min.
kpts= 5 x  5 x 1: Energy = -461.195. Calc time: 343 min.
kpts= 7 x  7 x 1: Energy = -461.191. Calc time: 520 min.
kpts= 1 x  1 x 1: Energy = -443.151. Calc time: 185 min.
kpts= 3 x  3 x 1: Energy = -443.708. Calc time: 669 min.
kpts= 5 x  5 x 1: Energy = -443.674. Calc time: 974 min.
kpts= 7 x  7 x 1: Energy = -443.680. Calc time: 1331 min.
kpts= 1 x  1 x 1: Energy = -432.595. Calc time: 158 min.
kpts= 3 x  3 x 1: Energy = -433.043. Calc time: 571 min.
kpts= 5 x  5 x 1: Energy = -433.036. Calc time: 1256 min.
kpts= 7 x  7 x 1: Energy = -433.033. Calc time: 2500 min.
kpts= 1 x  1 x 1: Energy = -419.818. Calc time: 235 min.
kpts= 3 x  3 x 1: Energy = -420.314. Calc time: 847 min.
kpts= 5 x  5 x 1: Energy = -420.308. Calc time: 1839 min.
kpts= 7 x  7 x 1: Energy = -420.308. Calc time: 2596 min.
kpts= 1 x  1 x 1: Energy = -408.860. Calc time: 177 min.
kpts= 3 x  3 x 1: Energy = -409.277. Calc time: 554 min.
kpts= 5 x  5 x 1: Energy = -409.281. Calc time: 694 min.
kpts= 7 x  7 x 1: Energy = -409.280. Calc time: 1131 min.
kpts= 1 x  1 x 1: Energy = -397.284. Calc time: 277 min.
kpts= 3 x  3 x 1: Energy = -397.656. Calc time: 903 min.
/home-guest/devonw/hydrogen2D/vasp/type=conv/mat=graphene/layers=1/size=5/pore=5/kpts=5 submitted: 1430979.gilgamesh.cheme.cmu.edu
kpts= 5 x  5 x 1: Inprogress.
kpts= 7 x  7 x 1: Energy = -397.654. Calc time: 3475 min.
:END:

A k-point grid of 5x5x1 is the lowest grid converged to 10 meV.

*** DONE mat=graphene/layers=1/size=3/pore=3 - kpts relaxed
    CLOSED: [2016-07-18 Mon 16:27]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp

import twodee as td


atoms = td.create_base("graphene", layers=1, size=3)
pore = [8, 9, 10]
atoms = td.make_pore(atoms, pore)

ks = [1, 3, 5, 7, 9, 11]
energies = []
for k in ks:
    name = 'vasp/type=conv/mat=graphene/layers=1/size=3/pore=3/kpts_relax={0}'.format(k)
    calc = Vasp(name,
                xc='PBE',
                encut=520,
                kpts=[k,k,1],
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms)
    td.result('kpts={0:2.0f} x {0:2.0f} x 1'.format(k), calc)
#    calc.calculate()
    energies.append(calc.potential_energy)

#td.bp()
plt.plot(ks, energies)
plt.xlabel("k-points (i x i x 1)")
plt.ylabel("Total energy [eV]")
td.print_image(name + '.png', plt)
#+END_SRC

#+RESULTS:
:RESULTS:
kpts= 1 x  1 x 1: Energy = -128.1060. Calc time: 143 min.
kpts= 3 x  3 x 1: Energy = -126.2168. Calc time: 161 min.
kpts= 5 x  5 x 1: Energy = -126.2441. Calc time: 323 min.
kpts= 7 x  7 x 1: Energy = -126.2423. Calc time: 311 min.
kpts= 9 x  9 x 1: Energy = -126.2426. Calc time: 719 min.
kpts=11 x 11 x 1: Energy = -126.2425. Calc time: 973 min.
[[./img/vasp/type=conv/mat=graphene/layers=1/size=3/pore=3/kpts_relax=11.png]]
:END:

A k-point grid of 5x5x1 is sufficient for convergence of 10 meV.

*** DONE mat=graphene/layers=2/size=1/pore=0 - kpts-z
    CLOSED: [2016-06-22 Wed 11:39]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp

import twodee as td


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

unitcell = Atoms([Atom('C', rA1),
                    Atom('C', rB1),
                    Atom('C', rA2),
                    Atom('C', rB2)],
                    cell=[a1, a2, a3])


ks = [1, 2, 3]
energies = []
for k in ks:
    atoms = unitcell.copy()
    name = 'vasp/type=conv/mat=graphene/layers=2/size=1/pore=0/kptsz={0}'.format(k)
    calc = Vasp(name,
                xc='PBE',          # GGA functional type
                encut=520,
                kpts=[11,11,k],
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms)
    td.result('kptsz={0}'.format(k), calc)
    energies.append(atoms.get_potential_energy())

if None not in energies:
    plt.plot(ks, energies)
    plt.xlabel("k-points (i x i x 1)")
    plt.ylabel("Total energy [eV]")
    td.print_image(name + '.png', plt)
#+END_SRC

#+RESULTS:
:RESULTS:
kptsz=1: Energy = -36.8821. Calc time: 2 min.
kptsz=2: Energy = -36.8820. Calc time: 2 min.
kptsz=3: Energy = -36.8821. Calc time: 9 min.
[[./img/vasp/type=conv/mat=graphene/layers=2/size=1/pore=0/kptsz=3.png]]
:END:

No change, as expected.

** Base structures

Structures for use in building more complex structures.

*** DONE mat=graphene/layers=1
    CLOSED: [2016-06-22 Wed 11:39]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from vasp import Vasp

import twodee as td


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

name = 'vasp/type=base/mat=graphene/layers=1'
calc = Vasp(name,
            xc='PBE',          # GGA functional type
            encut=520,
            kpts=[13,13,1],
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms)

td.result("Final bilayer graphene", calc)
td.print_image(name, atoms)
#+END_SRC

#+RESULTS:
:RESULTS:
Final bilayer graphene: Energy = -18.4493. Calc time: 0 min.
[[./img/vasp/type=base/mat=graphene/layers=1.png]]
:END:

*** DONE mat=graphene/layers=2
    CLOSED: [2016-06-22 Wed 11:39]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from vasp import Vasp

import twodee as td


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])


name = 'vasp/type=base/mat=graphene/layers=2'
calc = Vasp(name,
            xc='PBE',          # GGA functional type
            encut=520,
            kpts=[13,13,1],
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms)

td.result("Final bilayer graphene", calc)
td.print_image(name, atoms)
#+END_SRC

#+RESULTS:
:RESULTS:
Final bilayer graphene: Energy = -36.8838. Calc time: 1 min.
[[./img/vasp/type=base/mat=graphene/layers=2.png]]
:END:

** Equations of state
*** DONE mat=graphene/layers=1/size=1/pore=0
    CLOSED: [2016-07-18 Mon 11:56]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
import matplotlib.pyplot as plt
from vasp import Vasp

import twodee as td

A = np.linspace(2, 3, 50)

energies = []
for a in A:
    a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
    a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
    a3 = np.array([0., 0., 16.])

    atoms = Atoms([Atom('C', 1./2. * a3),
                    Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                    cell=[a1, a2, a3])

    name = 'vasp/type=eos/mat=graphene/layers=1/size=1/pore=0/lc={0:0.3f}'.format(a)
    calc = Vasp(name,
                xc='PBE',          # GGA functional type
                encut=520,
                kpts=[11,11,1],
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                atoms=atoms)

    energy = calc.potential_energy / len(atoms)
    energies.append(energy)

plt.plot(A, energies)
plt.xlabel('Lattice constant ($\AA$)')
plt.ylabel('Energy (eV/atom)')
plt.title('Graphene Equation of State')
file_path = 'eos_graphene.png'
td.print_image(file_path, plt)
#+END_SRC

#+RESULTS:
:RESULTS:
[[./img/eos_graphene.png]]
:END:

*** DONE mat=graphene/layers=1/size=3/pore=3
    CLOSED: [2016-07-18 Mon 11:56]

Should atoms be allowed to relax positions? Don't include these calculation in the neural networks for the time being.

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
import matplotlib.pyplot as plt
from vasp import Vasp

import twodee as td

A = np.linspace(2, 3, 50)

energies = []
for a in A:
    a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
    a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
    a3 = np.array([0., 0., 16.])

    atoms = Atoms([Atom('C', 1./2. * a3),
                    Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                    cell=[a1, a2, a3])
    atoms = atoms.repeat([3, 3, 1])
    pore = [8, 9, 10]
    atoms = td.make_pore(atoms, pore)

    name = 'vasp/type=eos/mat=graphene/layers=1/size=3/pore=3/lc={0:0.3f}'.format(a)
    calc = Vasp(name,
                xc='PBE',          # GGA functional type
                encut=520,
                kpts=[11,11,1],
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                atoms=atoms)

    energy = calc.potential_energy / len(atoms)
    energies.append(energy)

plt.plot(A, energies)
plt.xlabel('Lattice constant ($\AA$)')
plt.ylabel('Energy (eV/atom)')
plt.title('Graphene/size=3/pore=3 Equation of State')
file_path = 'eos_graphene_size=3_pore=3.png'
td.print_image(file_path, plt)
#+END_SRC

#+RESULTS:
:RESULTS:
[[./img/eos_graphene_size=3_pore=3.png]]
:END:

** Point energy calculations
*** DONE mat=graphene/layers=1/size=2/pore=*
    CLOSED: [2016-07-20 Wed 16:21]

#+BEGIN_SRC python :results example
from ase import Atoms, Atom
import numpy as np
import matplotlib.pyplot as plt
from vasp import Vasp

import twodee as td


size = 2
atoms = td.create_base("graphene", layers=1, size=size)
cans = td.candidates(mat='graphene', layers=1, size=size)

energies = []
for c in cans:
    for pore in c:
        a = atoms.copy()
        a = td.make_pore(a, pore)
        pname = td.pore_string(pore)
        name = 'vasp/type=point/mat=graphene/layers=1/size={0}/pore={1}/{2}'.format(size, len(pore), pname)
        calc = Vasp(name,
                    xc='PBE',
                    encut=520,
                    kpts=[9, 9, 1],
                    nsw=0,
                    atoms=a)
#        calc.calculate()
        td.result('pore={0}'.format(pname), calc, per_atom=True)
#+END_SRC

#+RESULTS:
: pore=000: Energy/atom = -9.223. Calc time: 5 min.
: pore=006: Energy/atom = -8.176. Calc time: 5 min.
: pore=007: Energy/atom = -8.176. Calc time: 4 min.
: pore=006007: Energy/atom = -7.738. Calc time: 8 min.

*** DONE mat=graphene/layers=1/size=3/pore=*
    CLOSED: [2016-07-18 Mon 16:23]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
import matplotlib.pyplot as plt
from vasp import Vasp

import twodee as td

size = 3
atoms = td.create_base("graphene", layers=1, size=size)
cans = td.candidates(mat='graphene', layers=1, size=size)

energies = []
for c in cans:
    for pore in c:
        a = atoms.copy()
        a = td.make_pore(a, pore)
        pname = td.pore_string(pore)
        name = 'vasp/type=point/mat=graphene/layers=1/size={0}/pore={1}/{2}'.format(size, len(pore), pname)
        calc = Vasp(name,
                    xc='PBE',
                    encut=520,
                    kpts=[5, 5, 1],
                    nsw=0,
                    atoms=a)
#        calc.calculate()
        td.result('pore={0}'.format(pname), calc, per_atom=True)
#+END_SRC

#+RESULTS:
:RESULTS:
pore=000: Energy/atom = -9.222. Calc time: 49 min.
pore=008: Energy/atom = -8.746. Calc time: 51 min.
pore=009: Energy/atom = -8.746. Calc time: 34 min.
pore=010: Energy/atom = -8.746. Calc time: 52 min.
pore=011: Energy/atom = -8.746. Calc time: 45 min.
pore=014: Energy/atom = -8.746. Calc time: 41 min.
pore=015: Energy/atom = -8.746. Calc time: 33 min.
pore=016: Energy/atom = -8.746. Calc time: 48 min.
pore=017: Energy/atom = -8.746. Calc time: 40 min.
pore=008009: Energy/atom = -8.624. Calc time: 62 min.
pore=009010: Energy/atom = -8.624. Calc time: 40 min.
pore=009014: Energy/atom = -8.624. Calc time: 43 min.
pore=010011: Energy/atom = -8.624. Calc time: 67 min.
pore=011016: Energy/atom = -8.624. Calc time: 60 min.
pore=014015: Energy/atom = -8.624. Calc time: 34 min.
pore=015016: Energy/atom = -8.624. Calc time: 64 min.
pore=016017: Energy/atom = -8.624. Calc time: 44 min.
pore=008009010: Energy/atom = -8.380. Calc time: 50 min.
pore=008009014: Energy/atom = -8.380. Calc time: 51 min.
pore=009010011: Energy/atom = -8.380. Calc time: 59 min.
pore=009010014: Energy/atom = -8.380. Calc time: 54 min.
pore=009014015: Energy/atom = -8.380. Calc time: 72 min.
pore=010011016: Energy/atom = -8.380. Calc time: 30 min.
pore=011015016: Energy/atom = -8.380. Calc time: 28 min.
pore=011016017: Energy/atom = -8.380. Calc time: 53 min.
pore=014015016: Energy/atom = -8.380. Calc time: 27 min.
pore=015016017: Energy/atom = -8.380. Calc time: 29 min.
pore=008009010011: Energy/atom = -8.114. Calc time: 59 min.
pore=008009010014: Energy/atom = -8.162. Calc time: 13 min.
pore=008009014015: Energy/atom = -8.114. Calc time: 35 min.
pore=009010011014: Energy/atom = -8.165. Calc time: 25 min.
pore=009010011016: Energy/atom = -8.165. Calc time: 24 min.
pore=009010014015: Energy/atom = -8.165. Calc time: 46 min.
pore=009014015016: Energy/atom = -8.165. Calc time: 26 min.
pore=010011015016: Energy/atom = -8.165. Calc time: 43 min.
pore=010011016017: Energy/atom = -8.114. Calc time: 111 min.
pore=011014015016: Energy/atom = -8.165. Calc time: 67 min.
pore=011015016017: Energy/atom = -8.162. Calc time: 16 min.
pore=014015016017: Energy/atom = -8.114. Calc time: 32 min.
pore=008009010011014: Energy/atom = -7.975. Calc time: 31 min.
pore=008009010011016: Energy/atom = -7.886. Calc time: 42 min.
pore=008009010014015: Energy/atom = -7.975. Calc time: 64 min.
pore=008009014015016: Energy/atom = -7.886. Calc time: 60 min.
pore=009010011014015: Energy/atom = -7.879. Calc time: 31 min.
pore=009010011014016: Energy/atom = -7.879. Calc time: 45 min.
pore=009010011015016: Energy/atom = -7.879. Calc time: 28 min.
pore=009010011016017: Energy/atom = -7.886. Calc time: 61 min.
pore=009010014015016: Energy/atom = -7.879. Calc time: 48 min.
pore=009011014015016: Energy/atom = -7.879. Calc time: 29 min.
pore=009014015016017: Energy/atom = -7.886. Calc time: 56 min.
pore=010011014015016: Energy/atom = -7.879. Calc time: 35 min.
pore=010011015016017: Energy/atom = -7.975. Calc time: 57 min.
pore=011014015016017: Energy/atom = -7.975. Calc time: 44 min.
pore=008009010011014015: Energy/atom = -7.627. Calc time: 36 min.
pore=008009010011014016: Energy/atom = -7.642. Calc time: 40 min.
pore=008009010011015016: Energy/atom = -7.618. Calc time: 42 min.
pore=008009010011016017: Energy/atom = -7.702. Calc time: 30 min.
pore=008009010014015016: Energy/atom = -7.642. Calc time: 38 min.
pore=008009011014015016: Energy/atom = -7.618. Calc time: 37 min.
pore=008009014015016017: Energy/atom = -7.702. Calc time: 25 min.
pore=009010011014015016: Energy/atom = -7.848. Calc time: 20 min.
pore=009010011014016017: Energy/atom = -7.618. Calc time: 33 min.
pore=009010011015016017: Energy/atom = -7.642. Calc time: 35 min.
pore=009010014015016017: Energy/atom = -7.618. Calc time: 42 min.
pore=009011014015016017: Energy/atom = -7.642. Calc time: 39 min.
pore=010011014015016017: Energy/atom = -7.627. Calc time: 30 min.
pore=008009010011014015016: Energy/atom = -7.598. Calc time: 25 min.
pore=008009010011014016017: Energy/atom = -7.496. Calc time: 31 min.
pore=008009010011015016017: Energy/atom = -7.496. Calc time: 33 min.
pore=008009010014015016017: Energy/atom = -7.496. Calc time: 29 min.
pore=008009011014015016017: Energy/atom = -7.496. Calc time: 26 min.
pore=009010011014015016017: Energy/atom = -7.598. Calc time: 22 min.
pore=008009010011014015016017: Energy/atom = -7.511. Calc time: 17 min.
:END:

*** DONE mat=graphene/layers=1/size=4/pore=3,4,5
    CLOSED: [2016-07-22 Fri 13:49]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
import matplotlib.pyplot as plt
from vasp import Vasp

import twodee as td

size = 4
pore_sizes = [3, 4, 5]
atoms = td.create_base("graphene", layers=1, size=size)
cans = td.candidates(mat='graphene', layers=1, size=size, pores=pore_sizes)

energies = []
for c in cans:
    for pore in c:
        a = atoms.copy()
        a = td.make_pore(a, pore)
        pname = td.pore_string(pore)
        name = 'vasp/type=point/mat=graphene/layers=1/size={0}/pore={1}/{2}'.format(size, len(pore), pname)
        calc = Vasp(name,
                    xc='PBE',
                    encut=520,
                    kpts=[5, 5, 1],
                    nsw=0,
                    atoms=a)
#        calc.calculate()
        td.result('pore={0}'.format(pname), calc)
#+END_SRC

#+RESULTS:
:RESULTS:
pore=010011012: Energy = -254.317. Calc time: 467 min.
pore=010011018: Energy = -254.317. Calc time: 211 min.
pore=011012013: Energy = -254.317. Calc time: 168 min.
pore=011012018: Energy = -254.317. Calc time: 156 min.
pore=011018019: Energy = -254.317. Calc time: 306 min.
pore=012013014: Energy = -254.317. Calc time: 157 min.
pore=012013020: Energy = -254.317. Calc time: 207 min.
pore=013014015: Energy = -254.317. Calc time: 216 min.
pore=013014020: Energy = -254.317. Calc time: 176 min.
pore=013019020: Energy = -254.317. Calc time: 342 min.
pore=013020021: Energy = -254.317. Calc time: 266 min.
pore=014015022: Energy = -254.317. Calc time: 165 min.
pore=015021022: Energy = -254.317. Calc time: 139 min.
pore=015022023: Energy = -254.317. Calc time: 171 min.
pore=018019020: Energy = -254.317. Calc time: 146 min.
pore=018019026: Energy = -254.317. Calc time: 189 min.
pore=019020021: Energy = -254.317. Calc time: 211 min.
pore=019020026: Energy = -254.317. Calc time: 521 min.
pore=019026027: Energy = -254.317. Calc time: 567 min.
pore=020021022: Energy = -254.317. Calc time: 569 min.
pore=020021028: Energy = -254.317. Calc time: 508 min.
pore=021022023: Energy = -254.317. Calc time: 556 min.
pore=021022028: Energy = -254.317. Calc time: 568 min.
pore=021027028: Energy = -254.317. Calc time: 544 min.
pore=021028029: Energy = -254.317. Calc time: 559 min.
pore=022023030: Energy = -254.317. Calc time: 193 min.
pore=023029030: Energy = -254.317. Calc time: 144 min.
pore=023030031: Energy = -254.317. Calc time: 156 min.
pore=026027028: Energy = -254.317. Calc time: 157 min.
pore=027028029: Energy = -254.317. Calc time: 146 min.
pore=028029030: Energy = -254.317. Calc time: 224 min.
pore=029030031: Energy = -254.317. Calc time: 208 min.
pore=010011012013: Energy = -242.197. Calc time: 185 min.
pore=010011012018: Energy = -243.190. Calc time: 82 min.
pore=010011018019: Energy = -242.197. Calc time: 186 min.
pore=011012013014: Energy = -242.197. Calc time: 194 min.
pore=011012013018: Energy = -242.922. Calc time: 151 min.
pore=011012013020: Energy = -242.922. Calc time: 128 min.
pore=011012018019: Energy = -242.922. Calc time: 142 min.
pore=011018019020: Energy = -242.922. Calc time: 151 min.
pore=011018019026: Energy = -242.197. Calc time: 227 min.
pore=012013014015: Energy = -242.197. Calc time: 630 min.
pore=012013014020: Energy = -243.190. Calc time: 404 min.
pore=012013019020: Energy = -242.922. Calc time: 409 min.
pore=012013020021: Energy = -242.197. Calc time: 259 min.
pore=013014015020: Energy = -242.922. Calc time: 431 min.
pore=013014015022: Energy = -242.922. Calc time: 496 min.
pore=013014019020: Energy = -242.197. Calc time: 341 min.
pore=013014020021: Energy = -242.922. Calc time: 188 min.
pore=013018019020: Energy = -242.922. Calc time: 207 min.
pore=013019020021: Energy = -243.190. Calc time: 64 min.
pore=013019020026: Energy = -242.197. Calc time: 261 min.
pore=013020021022: Energy = -242.922. Calc time: 125 min.
pore=013020021028: Energy = -242.197. Calc time: 260 min.
pore=014015021022: Energy = -242.922. Calc time: 138 min.
pore=014015022023: Energy = -242.197. Calc time: 172 min.
pore=015020021022: Energy = -242.922. Calc time: 121 min.
pore=015021022023: Energy = -243.190. Calc time: 64 min.
pore=015021022028: Energy = -242.197. Calc time: 240 min.
pore=015022023030: Energy = -242.197. Calc time: 302 min.
pore=018019020021: Energy = -242.197. Calc time: 207 min.
pore=018019020026: Energy = -243.190. Calc time: 64 min.
pore=018019026027: Energy = -242.197. Calc time: 227 min.
pore=019020021022: Energy = -242.197. Calc time: 437 min.
pore=019020021026: Energy = -242.922. Calc time: 273 min.
pore=019020021028: Energy = -242.922. Calc time: 298 min.
pore=019020026027: Energy = -242.922. Calc time: 288 min.
pore=019026027028: Energy = -242.922. Calc time: 236 min.
pore=020021022023: Energy = -242.197. Calc time: 351 min.
pore=020021022028: Energy = -243.190. Calc time: 184 min.
pore=020021027028: Energy = -242.922. Calc time: 317 min.
pore=020021028029: Energy = -242.197. Calc time: 413 min.
pore=021022023028: Energy = -242.922. Calc time: 330 min.
pore=021022023030: Energy = -242.922. Calc time: 292 min.
pore=021022027028: Energy = -242.197. Calc time: 406 min.
pore=021022028029: Energy = -242.922. Calc time: 353 min.
pore=021026027028: Energy = -242.922. Calc time: 322 min.
pore=021027028029: Energy = -243.190. Calc time: 206 min.
pore=021028029030: Energy = -242.922. Calc time: 328 min.
pore=022023029030: Energy = -242.922. Calc time: 253 min.
pore=022023030031: Energy = -242.197. Calc time: 417 min.
pore=023028029030: Energy = -242.922. Calc time: 322 min.
pore=023029030031: Energy = -243.190. Calc time: 186 min.
pore=026027028029: Energy = -242.197. Calc time: 394 min.
pore=027028029030: Energy = -242.197. Calc time: 441 min.
pore=028029030031: Energy = -242.197. Calc time: 446 min.
pore=010011012013014: Energy = -229.762. Calc time: 356 min.
pore=010011012013018: Energy = -231.691. Calc time: 430 min.
pore=010011012013020: Energy = -230.817. Calc time: 444 min.
pore=010011012018019: Energy = -231.691. Calc time: 417 min.
pore=010011018019020: Energy = -230.817. Calc time: 400 min.
pore=010011018019026: Energy = -229.762. Calc time: 366 min.
pore=011012013014015: Energy = -229.762. Calc time: 318 min.
pore=011012013014018: Energy = -230.817. Calc time: 453 min.
pore=011012013014020: Energy = -231.691. Calc time: 445 min.
pore=011012013018019: Energy = -230.111. Calc time: 294 min.
pore=011012013018020: Energy = -230.111. Calc time: 386 min.
pore=011012013019020: Energy = -230.111. Calc time: 316 min.
pore=011012013020021: Energy = -230.817. Calc time: 414 min.
pore=011012018019020: Energy = -230.111. Calc time: 287 min.
pore=011012018019026: Energy = -230.817. Calc time: 357 min.
pore=011013018019020: Energy = -230.111. Calc time: 369 min.
pore=011018019020021: Energy = -230.817. Calc time: 374 min.
pore=011018019020026: Energy = -231.691. Calc time: 433 min.
pore=011018019026027: Energy = -229.762. Calc time: 340 min.
pore=012013014015020: Energy = -231.691. Calc time: 386 min.
pore=012013014015022: Energy = -230.817. Calc time: 405 min.
pore=012013014019020: Energy = -231.691. Calc time: 467 min.
pore=012013014020021: Energy = -231.691. Calc time: 410 min.
pore=012013018019020: Energy = -230.111. Calc time: 313 min.
pore=012013019020021: Energy = -231.691. Calc time: 411 min.
pore=012013019020026: Energy = -230.817. Calc time: 431 min.
pore=012013020021022: Energy = -230.817. Calc time: 369 min.
pore=012013020021028: Energy = -229.762. Calc time: 354 min.
pore=013014015019020: Energy = -230.817. Calc time: 454 min.
pore=013014015020021: Energy = -230.111. Calc time: 288 min.
pore=013014015020022: Energy = -230.111. Calc time: 382 min.
pore=013014015021022: Energy = -230.111. Calc time: 391 min.
pore=013014015022023: Energy = -230.817. Calc time: 331 min.
pore=013014018019020: Energy = -230.817. Calc time: 447 min.
pore=013014019020021: Energy = -231.691. Calc time: 560 min.
pore=013014019020026: Energy = -229.762. Calc time: 514 min.
pore=013014020021022: Energy = -230.111. Calc time: 649 min.
pore=013014020021028: Energy = -230.817. Calc time: 207 min.
pore=013015020021022: Energy = -230.111. Calc time: 647 min.
pore=013018019020021: Energy = -231.691. Calc time: 336 min.
pore=013018019020026: Energy = -231.691. Calc time: 385 min.
pore=013019020021022: Energy = -231.691. Calc time: 357 min.
pore=013019020021026: Energy = -231.691. Calc time: 265 min.
pore=013019020021028: Energy = -231.691. Calc time: 379 min.
pore=013019020026027: Energy = -230.817. Calc time: 575 min.
pore=013020021022023: Energy = -230.817. Calc time: 405 min.
pore=013020021022028: Energy = -231.691. Calc time: 327 min.
pore=013020021027028: Energy = -230.817. Calc time: 385 min.
pore=013020021028029: Energy = -229.762. Calc time: 383 min.
pore=014015020021022: Energy = -230.111. Calc time: 611 min.
pore=014015021022023: Energy = -231.691. Calc time: 366 min.
pore=014015021022028: Energy = -230.817. Calc time: 547 min.
pore=014015022023030: Energy = -229.762. Calc time: 591 min.
pore=015019020021022: Energy = -230.817. Calc time: 484 min.
pore=015020021022023: Energy = -231.691. Calc time: 451 min.
pore=015020021022028: Energy = -231.691. Calc time: 461 min.
pore=015021022023028: Energy = -231.691. Calc time: 243 min.
pore=015021022023030: Energy = -231.691. Calc time: 390 min.
pore=015021022027028: Energy = -229.762. Calc time: 278 min.
pore=015021022028029: Energy = -230.817. Calc time: 380 min.
pore=015022023029030: Energy = -230.817. Calc time: 411 min.
pore=015022023030031: Energy = -229.762. Calc time: 299 min.
pore=018019020021022: Energy = -229.762. Calc time: 285 min.
pore=018019020021026: Energy = -231.691. Calc time: 315 min.
pore=018019020021028: Energy = -230.817. Calc time: 410 min.
pore=018019020026027: Energy = -231.691. Calc time: 288 min.
pore=018019026027028: Energy = -230.817. Calc time: 347 min.
pore=019020021022023: Energy = -229.762. Calc time: 271 min.
pore=019020021022026: Energy = -230.817. Calc time: 224 min.
pore=019020021022028: Energy = -231.691. Calc time: 355 min.
pore=019020021026027: Energy = -230.111. Calc time: 400 min.
pore=019020021026028: Energy = -230.111. Calc time: 422 min.
pore=019020021027028: Energy = -230.111. Calc time: 268 min.
pore=019020021028029: Energy = -230.817. Calc time: 447 min.
pore=019020026027028: Energy = -230.111. Calc time: 296 min.
pore=019021026027028: Energy = -230.111. Calc time: 415 min.
pore=019026027028029: Energy = -230.817. Calc time: 470 min.
pore=020021022023028: Energy = -231.691. Calc time: 340 min.
pore=020021022023030: Energy = -230.817. Calc time: 219 min.
pore=020021022027028: Energy = -231.691. Calc time: 433 min.
pore=020021022028029: Energy = -231.691. Calc time: 384 min.
pore=020021026027028: Energy = -230.111. Calc time: 327 min.
pore=020021027028029: Energy = -231.691. Calc time: 366 min.
pore=020021028029030: Energy = -230.817. Calc time: 317 min.
pore=021022023027028: Energy = -230.817. Calc time: 352 min.
pore=021022023028029: Energy = -230.111. Calc time: 297 min.
pore=021022023028030: Energy = -230.111. Calc time: 303 min.
pore=021022023029030: Energy = -230.111. Calc time: 265 min.
pore=021022023030031: Energy = -230.817. Calc time: 452 min.
pore=021022026027028: Energy = -230.817. Calc time: 617 min.
pore=021022027028029: Energy = -231.691. Calc time: 332 min.
pore=021022028029030: Energy = -230.111. Calc time: 266 min.
pore=021023028029030: Energy = -230.111. Calc time: 250 min.
pore=021026027028029: Energy = -231.691. Calc time: 395 min.
pore=021027028029030: Energy = -231.691. Calc time: 352 min.
pore=021028029030031: Energy = -230.817. Calc time: 364 min.
pore=022023028029030: Energy = -230.111. Calc time: 305 min.
pore=022023029030031: Energy = -231.691. Calc time: 409 min.
pore=023027028029030: Energy = -230.817. Calc time: 304 min.
pore=023028029030031: Energy = -231.691. Calc time: 360 min.
pore=026027028029030: Energy = -229.762. Calc time: 262 min.
pore=027028029030031: Energy = -229.762. Calc time: 268 min.
:END:

*** DONE mat=graphene/layers=1/size=5/pore=0,3,4#,5
    CLOSED: [2016-07-23 Sat 11:45]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
import matplotlib.pyplot as plt
from vasp import Vasp

import twodee as td


size = 5
pore_sizes = [0, 3, 4]#, 5]
atoms = td.create_base("graphene", layers=1, size=size)
cans = td.candidates(mat='graphene', layers=1, size=size, pores=pore_sizes)

energies = []
for c in cans:
    for pore in c:
        a = atoms.copy()
        a = td.make_pore(a, pore)
        pname = td.pore_string(pore)
        name = 'vasp/type=point/mat=graphene/layers=1/size={0}/pore={1}/{2}'.format(size, len(pore), pname)
        calc = Vasp(name,
                    xc='PBE',
                    encut=520,
                    kpts=[3, 3, 1],
                    nsw=0,
                    atoms=a)
#        calc.calculate()
        td.result('pore={0}'.format(pname), calc)
#+END_SRC

#+RESULTS:
:RESULTS:
pore=000: Energy = -461.102. Calc time: 545 min.
pore=012013014: Energy = -420.314. Calc time: 638 min.
pore=012013022: Energy = -420.314. Calc time: 650 min.
pore=013014015: Energy = -420.314. Calc time: 736 min.
pore=013014022: Energy = -420.314. Calc time: 645 min.
pore=013022023: Energy = -420.314. Calc time: 680 min.
pore=014015016: Energy = -420.314. Calc time: 620 min.
pore=014015024: Energy = -420.314. Calc time: 611 min.
pore=015016017: Energy = -420.314. Calc time: 726 min.
pore=015016024: Energy = -420.314. Calc time: 691 min.
pore=015023024: Energy = -420.314. Calc time: 734 min.
pore=015024025: Energy = -420.314. Calc time: 589 min.
pore=016017018: Energy = -420.314. Calc time: 647 min.
pore=016017026: Energy = -420.314. Calc time: 656 min.
pore=017018019: Energy = -420.314. Calc time: 633 min.
pore=017018026: Energy = -420.314. Calc time: 685 min.
pore=017025026: Energy = -420.314. Calc time: 590 min.
pore=017026027: Energy = -420.314. Calc time: 701 min.
pore=018019028: Energy = -420.314. Calc time: 613 min.
pore=019027028: Energy = -420.314. Calc time: 613 min.
pore=019028029: Energy = -420.314. Calc time: 655 min.
pore=022023024: Energy = -420.314. Calc time: 704 min.
pore=022023032: Energy = -420.314. Calc time: 696 min.
pore=023024025: Energy = -420.314. Calc time: 617 min.
pore=023024032: Energy = -420.314. Calc time: 653 min.
pore=023032033: Energy = -420.314. Calc time: 535 min.
pore=024025026: Energy = -420.314. Calc time: 567 min.
pore=024025034: Energy = -420.314. Calc time: 518 min.
pore=025026027: Energy = -420.314. Calc time: 577 min.
pore=025026034: Energy = -420.314. Calc time: 730 min.
pore=025033034: Energy = -420.314. Calc time: 708 min.
pore=025034035: Energy = -420.314. Calc time: 655 min.
pore=026027028: Energy = -420.314. Calc time: 671 min.
pore=026027036: Energy = -420.314. Calc time: 614 min.
pore=027028029: Energy = -420.314. Calc time: 733 min.
pore=027028036: Energy = -420.314. Calc time: 626 min.
pore=027035036: Energy = -420.314. Calc time: 612 min.
pore=027036037: Energy = -420.314. Calc time: 526 min.
pore=028029038: Energy = -420.314. Calc time: 682 min.
pore=029037038: Energy = -420.314. Calc time: 644 min.
pore=029038039: Energy = -420.314. Calc time: 586 min.
pore=032033034: Energy = -420.314. Calc time: 610 min.
pore=032033042: Energy = -420.314. Calc time: 338 min.
pore=033034035: Energy = -420.314. Calc time: 498 min.
pore=033034042: Energy = -420.314. Calc time: 423 min.
pore=033042043: Energy = -420.314. Calc time: 450 min.
pore=034035036: Energy = -420.314. Calc time: 549 min.
pore=034035044: Energy = -420.314. Calc time: 384 min.
pore=035036037: Energy = -420.314. Calc time: 471 min.
pore=035036044: Energy = -420.314. Calc time: 478 min.
pore=035043044: Energy = -420.314. Calc time: 437 min.
pore=035044045: Energy = -420.314. Calc time: 510 min.
pore=036037038: Energy = -420.314. Calc time: 685 min.
pore=036037046: Energy = -420.314. Calc time: 408 min.
pore=037038039: Energy = -420.314. Calc time: 598 min.
pore=037038046: Energy = -420.314. Calc time: 506 min.
pore=037045046: Energy = -420.314. Calc time: 350 min.
pore=037046047: Energy = -420.314. Calc time: 373 min.
pore=038039048: Energy = -420.314. Calc time: 351 min.
pore=039047048: Energy = -420.314. Calc time: 357 min.
pore=039048049: Energy = -420.314. Calc time: 450 min.
pore=042043044: Energy = -420.314. Calc time: 602 min.
pore=043044045: Energy = -420.314. Calc time: 442 min.
pore=044045046: Energy = -420.314. Calc time: 692 min.
pore=045046047: Energy = -420.314. Calc time: 629 min.
pore=046047048: Energy = -420.314. Calc time: 471 min.
pore=047048049: Energy = -420.314. Calc time: 523 min.
pore=012013014015: Energy = -408.182. Calc time: 439 min.
pore=012013014022: Energy = -409.277. Calc time: 195 min.
pore=012013022023: Energy = -408.182. Calc time: 827 min.
pore=013014015016: Energy = -408.182. Calc time: 856 min.
pore=013014015022: Energy = -408.868. Calc time: 1039 min.
pore=013014015024: Energy = -408.868. Calc time: 997 min.
pore=013014022023: Energy = -408.868. Calc time: 640 min.
pore=013022023024: Energy = -408.868. Calc time: 660 min.
pore=013022023032: Energy = -408.182. Calc time: 1086 min.
pore=014015016017: Energy = -408.182. Calc time: 1198 min.
pore=014015016024: Energy = -409.277. Calc time: 586 min.
pore=014015023024: Energy = -408.868. Calc time: 1032 min.
pore=014015024025: Energy = -408.182. Calc time: 1057 min.
pore=015016017018: Energy = -408.182. Calc time: 1089 min.
pore=015016017024: Energy = -408.868. Calc time: 908 min.
pore=015016017026: Energy = -408.868. Calc time: 1025 min.
pore=015016023024: Energy = -408.182. Calc time: 961 min.
pore=015016024025: Energy = -408.868. Calc time: 897 min.
pore=015022023024: Energy = -408.868. Calc time: 859 min.
pore=015023024025: Energy = -409.277. Calc time: 697 min.
pore=015023024032: Energy = -408.182. Calc time: 1097 min.
pore=015024025026: Energy = -408.868. Calc time: 889 min.
pore=015024025034: Energy = -408.182. Calc time: 1060 min.
pore=016017018019: Energy = -408.182. Calc time: 1034 min.
pore=016017018026: Energy = -409.277. Calc time: 778 min.
pore=016017025026: Energy = -408.868. Calc time: 790 min.
pore=016017026027: Energy = -408.182. Calc time: 1086 min.
pore=017018019026: Energy = -408.868. Calc time: 1061 min.
pore=017018019028: Energy = -408.868. Calc time: 911 min.
pore=017018025026: Energy = -408.182. Calc time: 1123 min.
pore=017018026027: Energy = -408.868. Calc time: 930 min.
pore=017024025026: Energy = -408.868. Calc time: 1086 min.
pore=017025026027: Energy = -409.277. Calc time: 627 min.
pore=017025026034: Energy = -408.182. Calc time: 1204 min.
pore=017026027028: Energy = -408.868. Calc time: 960 min.
pore=017026027036: Energy = -408.182. Calc time: 1014 min.
pore=018019027028: Energy = -408.868. Calc time: 909 min.
pore=018019028029: Energy = -408.182. Calc time: 1302 min.
pore=019026027028: Energy = -408.868. Calc time: 828 min.
pore=019027028029: Energy = -409.277. Calc time: 649 min.
pore=019027028036: Energy = -408.182. Calc time: 1065 min.
pore=019028029038: Energy = -408.182. Calc time: 1129 min.
pore=022023024025: Energy = -408.182. Calc time: 1038 min.
pore=022023024032: Energy = -409.277. Calc time: 769 min.
pore=022023032033: Energy = -408.182. Calc time: 1088 min.
pore=023024025026: Energy = -408.182. Calc time: 1001 min.
pore=023024025032: Energy = -408.868. Calc time: 912 min.
pore=023024025034: Energy = -408.868. Calc time: 957 min.
pore=023024032033: Energy = -408.868. Calc time: 831 min.
pore=023032033034: Energy = -408.868. Calc time: 964 min.
pore=023032033042: Energy = -408.182. Calc time: 1029 min.
pore=024025026027: Energy = -408.182. Calc time: 1058 min.
pore=024025026034: Energy = -409.277. Calc time: 638 min.
pore=024025033034: Energy = -408.868. Calc time: 1002 min.
pore=024025034035: Energy = -408.182. Calc time: 426 min.
pore=025026027028: Energy = -408.182. Calc time: 706 min.
pore=025026027034: Energy = -408.868. Calc time: 383 min.
pore=025026027036: Energy = -408.868. Calc time: 1118 min.
pore=025026033034: Energy = -408.182. Calc time: 1177 min.
pore=025026034035: Energy = -408.868. Calc time: 291 min.
pore=025032033034: Energy = -408.868. Calc time: 319 min.
pore=025033034035: Energy = -409.277. Calc time: 215 min.
pore=025033034042: Energy = -408.182. Calc time: 385 min.
pore=025034035036: Energy = -408.868. Calc time: 294 min.
pore=025034035044: Energy = -408.182. Calc time: 378 min.
pore=026027028029: Energy = -408.182. Calc time: 353 min.
pore=026027028036: Energy = -409.277. Calc time: 205 min.
pore=026027035036: Energy = -408.868. Calc time: 272 min.
pore=026027036037: Energy = -408.182. Calc time: 347 min.
pore=027028029036: Energy = -408.868. Calc time: 332 min.
pore=027028029038: Energy = -408.868. Calc time: 455 min.
pore=027028035036: Energy = -408.182. Calc time: 593 min.
pore=027028036037: Energy = -408.868. Calc time: 472 min.
pore=027034035036: Energy = -408.868. Calc time: 495 min.
pore=027035036037: Energy = -409.277. Calc time: 374 min.
pore=027035036044: Energy = -408.182. Calc time: 749 min.
pore=027036037038: Energy = -408.868. Calc time: 310 min.
pore=027036037046: Energy = -408.182. Calc time: 759 min.
pore=028029037038: Energy = -408.868. Calc time: 553 min.
pore=028029038039: Energy = -408.182. Calc time: 937 min.
pore=029036037038: Energy = -408.868. Calc time: 873 min.
pore=029037038039: Energy = -409.277. Calc time: 422 min.
pore=029037038046: Energy = -408.182. Calc time: 786 min.
pore=029038039048: Energy = -408.182. Calc time: 916 min.
pore=032033034035: Energy = -408.182. Calc time: 752 min.
pore=032033034042: Energy = -409.277. Calc time: 399 min.
pore=032033042043: Energy = -408.182. Calc time: 689 min.
pore=033034035036: Energy = -408.182. Calc time: 930 min.
pore=033034035042: Energy = -408.868. Calc time: 411 min.
pore=033034035044: Energy = -408.868. Calc time: 357 min.
pore=033034042043: Energy = -408.868. Calc time: 361 min.
pore=033042043044: Energy = -408.868. Calc time: 363 min.
pore=034035036037: Energy = -408.182. Calc time: 616 min.
pore=034035036044: Energy = -409.277. Calc time: 439 min.
pore=034035043044: Energy = -408.868. Calc time: 634 min.
pore=034035044045: Energy = -408.182. Calc time: 600 min.
pore=035036037038: Energy = -408.182. Calc time: 706 min.
pore=035036037044: Energy = -408.868. Calc time: 604 min.
pore=035036037046: Energy = -408.868. Calc time: 532 min.
pore=035036043044: Energy = -408.182. Calc time: 708 min.
pore=035036044045: Energy = -408.868. Calc time: 523 min.
pore=035042043044: Energy = -408.868. Calc time: 537 min.
pore=035043044045: Energy = -409.277. Calc time: 427 min.
pore=035044045046: Energy = -408.868. Calc time: 549 min.
pore=036037038039: Energy = -408.182. Calc time: 640 min.
pore=036037038046: Energy = -409.277. Calc time: 405 min.
pore=036037045046: Energy = -408.868. Calc time: 556 min.
pore=036037046047: Energy = -408.182. Calc time: 677 min.
pore=037038039046: Energy = -408.868. Calc time: 546 min.
pore=037038039048: Energy = -408.868. Calc time: 533 min.
pore=037038045046: Energy = -408.182. Calc time: 683 min.
pore=037038046047: Energy = -408.868. Calc time: 456 min.
pore=037044045046: Energy = -408.868. Calc time: 458 min.
pore=037045046047: Energy = -409.277. Calc time: 401 min.
pore=037046047048: Energy = -408.868. Calc time: 450 min.
pore=038039047048: Energy = -408.868. Calc time: 456 min.
pore=038039048049: Energy = -408.182. Calc time: 960 min.
pore=039046047048: Energy = -408.868. Calc time: 411 min.
pore=039047048049: Energy = -409.277. Calc time: 321 min.
pore=042043044045: Energy = -408.182. Calc time: 562 min.
pore=043044045046: Energy = -408.182. Calc time: 566 min.
pore=044045046047: Energy = -408.182. Calc time: 683 min.
pore=045046047048: Energy = -408.182. Calc time: 540 min.
pore=046047048049: Energy = -408.182. Calc time: 586 min.
:END:

** Relaxations
*** DONE mat=graphene/layers=1/size=3/pore=?: 10 relaxed structures of varying pore sizes 
    CLOSED: [2016-07-19 Tue 16:15]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
import matplotlib.pyplot as plt
from vasp import Vasp

import twodee as td

unitcell = td.create_base("graphene", layers=1)
size = 3
atoms = td.create_base("graphene", layers=1, size=size)

edges = td.edges(atoms, unitcell)
indices = [a.index for a in atoms if a.index not in edges]

pore_sizes = range(len(indices)+1)
cans = []
for pore_size in pore_sizes:
    cans.append(td.candidates(atoms, edge=edges, size=pore_size))


# Select 2 pores from candidates for each pore size
energies = []
for c in cans:
    if len(c) <= 1:
        continue
    select = [0, len(c)/2]
    for s in select:
        pore = c[s]
        a = atoms.copy()
        a = td.make_pore(a, pore)
        pname = td.pore_string(pore)
        name = 'vasp/type=relax/mat=graphene/layers=1/size={0}/pore={1}/{2}'.format(size, len(pore), pname)
        calc = Vasp(name,
                    xc='PBE',
                    encut=520,
                    kpts=[5, 5, 1],
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=50,            # max number of steps to relax
                    atoms=a)
        td.result('pore={0}'.format(pname), calc)
#        energy = atoms.get_potential_energy()
#        energies.append(energy)

#+END_SRC

#+RESULTS:
:RESULTS:
pore=008: Energy = -148.9134. Calc time: 63 min.
pore=014: Energy = -148.9134. Calc time: 102 min.
pore=008009: Energy = -138.7491. Calc time: 243 min.
pore=011016: Energy = -138.7491. Calc time: 232 min.
pore=008009010: Energy = -126.2441. Calc time: 228 min.
pore=010011016: Energy = -126.2441. Calc time: 242 min.
pore=008009010011: Energy = -114.7128. Calc time: 351 min.
pore=009014015016: Energy = -115.3673. Calc time: 280 min.
pore=008009010011014: Energy = -104.4789. Calc time: 377 min.
pore=009010011016017: Energy = -104.6957. Calc time: 709 min.
pore=008009010011014015: Energy = -93.6848. Calc time: 216 min.
pore=008009014015016017: Energy = -96.6321. Calc time: 406 min.
pore=008009010011014015016: Energy = -86.3767. Calc time: 391 min.
pore=008009010014015016017: Energy = -88.3831. Calc time: 648 min.
:END:

** Results
*** Pore energy comparison

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
from ase.db import connect
import numpy as np
import matplotlib.pyplot as plt
from vasp import Vasp

import twodee as td

sizes = [3, 4, 5]
db = connect('database/master.db')

for size in sizes:
    energies = {}
    pore_sizes = set()
    for d in db.select(['type=point', 'mat=graphene', 'layers=1',
                        'size={}'.format(size)]):

        energy = d.energy / d.natoms
        pore_size = d['pore']
        pore_sizes.add(pore_size)
        if pore_size not in energies:
            energies[pore_size] = [energy]
        else:
            energies[pore_size] += [energy]


    for ps in sorted(pore_sizes):
        num_calcs = len(energies[ps])
        if size == 3:
            plt.plot([ps]*num_calcs, energies[ps], 'bo', label="Size=3x3")
#            plt.boxplot(energies[ps], ps)
        elif size == 4:
            plt.plot([ps]*num_calcs, energies[ps], 'go', label="Size=4x4")
#            plt.boxplot(energies[ps], ps)
        elif size == 5:
            plt.plot([ps]*num_calcs, energies[ps], 'ro', label="Size=5x5")

file_path = 'results/pore-size-comparison.png'
#plt.legend(['Size = 3x3', 'Size = 4x4'])
from collections import OrderedDict
handles, labels = plt.gca().get_legend_handles_labels()
by_label = OrderedDict(zip(labels, handles))
plt.legend(by_label.values(), by_label.keys())
#plt.legend()
plt.xlabel('Pore size (atoms)')
plt.ylabel('Energy (eV/atom)')
#plt.savefig(file_path)
#print('[[' + file_path + ']]')
fig_name = "fig:pore-size-comparison"
caption = "An energy comparison of different pore structure for a 3x3 graphene superstructure. The calculations have not been relaxed after the pore was created. label:" + fig_name
td.print_image(file_path, plt, caption=caption, fig_name=fig_name)
#+END_SRC

#+RESULTS:
:RESULTS:
#+CAPTION: An energy comparison of different pore structure for a 3x3 graphene superstructure. The calculations have not been relaxed after the pore was created. label:fig:pore-size-comparison
#+NAME: fig:fig:pore-size-comparison
[[./img/results/pore-size-comparison.png]]
:END:

* Neural network

** DONE Graphene equation of state (amp-tutorial)
   CLOSED: [2016-07-19 Tue 16:18]
Build a neural network around the equation of state for graphene in the style of Jake's [[https://github.com/jboes/amp-tutorial][amp-tutorial]].

*** Build the database.

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
import matplotlib.pyplot as plt
from vasp import Vasp

import twodee as td

A = np.linspace(2, 3, 50)
format_name = 'vasp/type=eos/mat=graphene/layers=1/size=1/pore=0/lc={0:0.3f}'
calcs = [Vasp(format_name.format(a)) for a in A]

[calc.write_db('./database/eos.db', parser='=',
               overwrite=False, keys={'dbkey': 0},
               data={'ctime': calc.get_elapsed_time(),
                     'lattice': a})
 for (calc, a) in zip(calcs, A)]
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

*** Plot EOS using the database.

#+BEGIN_SRC python :results drawer
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np

import twodee as td

lc, nrg = [], []
with connect('database/eos.db') as db:
    for d in db.select('dbkey=0'):
        natoms = [d.natoms]
        lc += [d.data.lattice]
        nrg += [d.energy]
lc = np.array(lc)
nrg = np.array(nrg)
nrg_atom = nrg / natoms

plt.plot(lc, nrg_atom)
plt.xlabel('Lattice constant ($\AA$)')
plt.ylabel('Energy (eV/atom)')
plt.title('Graphene Equation of State')
file_path = './tmp/img/vasp/eos/mat=graphene_layers=1_pore=0_eos.png'
td.print_image(file_path, plt)
#+END_SRC

#+RESULTS:
:RESULTS:
[[./img/./tmp/img/vasp/eos/mat=graphene_layers=1_pore=0_eos.png]]
:END:

*** Designate training data

Leave 10% of calculations for testing later.
#+BEGIN_SRC python :results drawer
from ase.db import connect
import random
import numpy as np

db = connect('database/eos.db')

n_ids = []
for d in db.select('dbkey=0'):
    n_ids += [d.id]

n = len(n_ids)
n_train = int(round(n * 0.9))

random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

print("Done")
#+END_SRC

#+RESULTS:
:RESULTS:
Done
:END:

*** Build the network

Generate an initial guess for the parameters to build the neural networks.
#+BEGIN_SRC python :exports none
from amp import Amp
from amp.descriptor import Behler
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing
import os

db = connect('database/eos.db')

images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

for n in [4, 5]:
    wd = 'networks/db=eos0/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)

    calc = Amp(label=wd,
               dblabel='networks/',
               descriptor=Behler(cutoff=6.5),
               regression=NeuralNetwork(hiddenlayers=(2, n)))

    calc.train(images=images,
               data_format='db',
               cores=1,
               energy_goal=10,
               force_goal=None,
               global_search=SimulatedAnnealing(temperature=70,
                                                steps=50),
               extend_variables=False) # Do not use this feature

    os.unlink(os.path.join(wd, 'train-log.txt'))  # TODO devon: was just 'log.txt'
    os.unlink(os.path.join(wd, 'trained-parameters.json'))
#+END_SRC

#+RESULTS:

Build the networks using the previous initial guess.
#+BEGIN_SRC python :results drawer
from amp import Amp
from ase.db import connect
import os

db = connect('database/eos.db')

images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

for n in [4, 5]:
    wd = 'networks/db=eos0/{0}-{0}/'.format(n)

    calc = Amp(load=os.path.join(wd, 'initial-parameters.json'),
               label=wd,
               dblabel='networks/')

    calc.train(images=images,
               data_format='db',
               cores=1,
               energy_goal=1e-3,  # The default energy training goal
               force_goal=None,  # There are no forces in the training data
               global_search=None,  # Already have a good starting point
               extend_variables=False) # Do not use this feature
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

*** Convergence
    
Check for convergence.
#+BEGIN_SRC python :results drawer
import os
import json

print('|Hidden layers|Iteration|Time|Cost Function|Energy RMSE|')
print('|-')

for r, d, f in os.walk('networks/db=eos0/'):
    if 'train-log.txt' in f:
        with open(os.path.join(r, 'train-log.txt'), 'r') as fi:
            v = fi.readlines()[-3].split()

    if 'trained-parameters.json' in f:
        with open(os.path.join(r, 'trained-parameters.json'), 'r') as fi:
            p = json.load(fi)
        n = p['hiddenlayers']
        print('|{}|{}|{}|{}|{}|'.format(n, v[0], v[1], v[2], v[3]))
#+END_SRC

#+RESULTS:
:RESULTS:
| Hidden layers  | Iteration | Time                | Cost Function | Energy RMSE |
|----------------+-----------+---------------------+---------------+-------------|
| {u'C': [2, 4]} |       163 | 2016-07-18T15:57:52 |     4.354e-05 |   9.836e-04 |
| {u'C': [2, 5]} |       222 | 2016-07-18T15:58:01 |     4.444e-05 |   9.937e-04 |
:END:

*** Add to db

Add the neural network results to the database.
#+BEGIN_SRC python :results drawer
from ase.db import connect
from amp import Amp

db = connect('database/eos.db')

calc4 = Amp('./networks/db=eos0/4-4/')
calc5 = Amp('./networks/db=eos0/5-5/')

for d in db.select():
    atoms = db.get_atoms(d.id)

    atoms.set_calculator(calc4)
    e0 = atoms.get_potential_energy()

    atoms.set_calculator(calc5)
    e1 = atoms.get_potential_energy()

    db.update(d.id, nn0=e0, nn1=e1)
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

*** Residual analysis

#+BEGIN_SRC python :results drawer
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

import twodee as td


db = connect('database/eos.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([4, 5]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('dbkey=0')):
	E += [d.energy / d.natoms]
	nnE += [d['nn{}'.format(i)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(5, -0.0075,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(5, -0.009,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.01, 0.01)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./tmp/residuals-1.png')
print("[[" + './tmp/residuals-1.png' + "]]")
#+END_SRC

#+RESULTS:
:RESULTS:
[[./tmp/residuals-1.png]]
:END:

*** Recreate equation of state

#+BEGIN_SRC python :results drawer
import numpy as np
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.db import connect
from amp import Amp
import os
import json
import time
from ase.units import kJ

db = connect('database/eos.db')

for r, d, f in os.walk('./networks/db=eos0/'):
    if 'trained-parameters.json' in f:
        calc = Amp(load=r + '/')

        with open(os.path.join(r, 'trained-parameters.json'), 'r') as fi:
            p = json.load(fi)
        n = p['hiddenlayers'].values()[0]

        nrg, vol, t, lc = [], [], [], []
        for d in db.select(['dbkey=0']):
            atoms = db.get_atoms(d.id)
            atoms.set_calculator(calc)

            time1 = time.time()
            energy = atoms.get_potential_energy()
            time2 = time.time()

            nrg += [energy]
            lc += [d.data.lattice]
            vol += [d.volume]
            t += [(time2 - time1) * 1000]

        vol = np.array(vol)
        nrg = np.array(nrg)
        t = np.array(t)
        lc = np.array(lc)

        # Fit the data to SJEOS
        eos = EquationOfState(vol, nrg)
        v0, e0, B = eos.fit()

        x = np.linspace(vol.min(), vol.max(), 250)

        fig, ax = plt.subplots(figsize=(6, 4))
        ax.scatter(vol, nrg, color='b')
        ax.plot(x, eos.fit0(x**-(1.0 / 3)), 'k-')

        ax.set_xlim(vol.min(), vol.max())
        ax.set_xlabel('Lattic constant [$\AA$]')
        ax.set_ylabel('Potential energy (eV)')

        ax.text(vol.max() - 20, nrg.max(),
                 'V$_{0}$={1:1.1f}'.format('{min}', v0),
                 va='center', ha='left')
        ax.text(vol.max() - 20, nrg.max() - 1,
                 'E$_{0}$={1:1.3f}'.format('{min}', e0),
                 va='center', ha='left')
        ax.text(vol.max() - 20, nrg.max() - 2,
                 'B={0:1.0f}'.format(B  / kJ * 1.0e24),
                 va='center', ha='left')

        plt.tight_layout()
        plt.savefig('./tmp/eos-NN{}.png'.format(n[1]))
        print('[[' + './tmp/eos-NN{}.png'.format(n[1]) + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
[[./tmp/eos-NN4.png]]
[[./tmp/eos-NN5.png]]
:END:

My equation of state comparison
#+BEGIN_SRC python :results drawer
from amp import Amp
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
import os
import json

import twodee as td


# DFT
natoms, lc_dft, nrg_dft = [], [], []
with connect('database/eos.db') as db:
    for d in db.select('dbkey=0'):
        natoms += [d.natoms]
        lc_dft += [d.data.lattice]
        nrg_dft += [d.energy]
lc_dft = np.array(lc_dft)
nrg_dft = np.array(nrg_dft)
nrg_dft_atom = nrg_dft / natoms


# NN
db = connect('database/eos.db')
for r, d, f in os.walk('./networks/db=eos0/'):
    if 'trained-parameters.json' in f:
        calc = Amp(load=r + '/')

        with open(os.path.join(r, 'trained-parameters.json'), 'r') as fi:
            p = json.load(fi)
        n = p['hiddenlayers'].values()[0]

        natoms, lc_nn, nrg_nn = [], [], []
        for d in db.select(['dbkey=0']):
            atoms = db.get_atoms(d.id)
            atoms.set_calculator(calc)

            energy = atoms.get_potential_energy()

            natoms += [d.natoms]
            lc_nn += [d.data.lattice]
            nrg_nn += [energy]

        lc_nn = np.array(lc_nn)
        nrg_nn = np.array(nrg_nn)
        nrg_nn_atom = nrg_nn / natoms


# Plot
plt.plot(lc_dft, nrg_dft_atom, "k--", label="DFT")
plt.plot(lc_nn, nrg_nn_atom, "bo", label="NN")
plt.xlabel('Lattice constant ($\AA$)')
plt.ylabel('Energy (eV/atom)')
plt.title('Graphene Equation of State')
plt.legend()
plt.xlim([min(lc_dft), max(lc_dft)])
file_path = './tmp/img/vasp/eos/mat=graphene_layers=1_pore=0_eos.png'
td.print_image(file_path, plt)
#+END_SRC

#+RESULTS:
:RESULTS:
[[./img/./tmp/img/vasp/eos/mat=graphene_layers=1_pore=0_eos.png]]
:END:

Extrapolation
#+BEGIN_SRC python :results silent :exports none
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
from ase import Atoms, Atom
import matplotlib.pyplot as plt
import collections

D = {}
for calc in ['./networks/db=eos0/4-4/',
             './networks/db=eos0/5-5/']:

    D[calc[-2]] = collections.OrderedDict()
    for x in np.linspace(0.5, 4.0, 1000.):

        a1 = x * np.array([3.0**0.5/2., -1./2., 0.])
        a2 = x * np.array([3.0**0.5/2., 1./2., 0.])
        a3 = np.array([0., 0., 16.])

        atoms = Atoms([Atom('C', 1./2. * a3),
                        Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                        cell=[a1, a2, a3])

        atoms.set_calculator(Amp(calc))

        D[calc[-2]][x] = atoms.get_potential_energy()

res = abs(np.array(D['5'].values()) - np.array(D['4'].values()))

f, ax = plt.subplots(2, 1, sharex=True)
ax[0].plot(D['4'].keys(), D['4'].values(), 'b', lw=2, label='4-4')
ax[0].plot(D['5'].keys(), D['5'].values(), 'r', lw=2, label='5-5')
ax[0].plot([0.85, 0.85], [2, -6], 'k--')
ax[0].plot([2.1, 2.1], [2, -6], 'k--')
ax[0].set_ylabel('Potential energy (eV)')
ax[0].set_xlim(0.6, 2.5)
ax[0].legend(loc='best')

ax[1].plot([0.85, 0.85], [0, 0.5], 'k--')
ax[1].plot([2.07, 2.1], [0, 0.5], 'k--')
ax[1].plot(D['4'].keys(), res, 'k', lw=2)
ax[1].set_ylabel('NN energy difference (eV)')
ax[1].set_ylim(0, 0.5)
ax[1].set_xlabel('Strain/stretch factor (%)')
plt.tight_layout(w_pad=0.0)
plt.savefig('./tmp/app-eos.png')
#+END_SRC

[[./tmp/app-eos.png]]

** TODO Test neural network as a function of hidden layers and nodes

*** Copy the master database into working directory

#+BEGIN_SRC python
import os.path
import shutil

import twodee as td

wd = 'networks/test_validation'
dbname = os.path.basename(wd) + '.db'
new_db = os.path.join(wd, dbname)

if not os.path.exists(wd):
    os.makedirs(wd)
if os.path.exists(new_db):
    print("Database already exists.")
else:
    shutil.copyfile('database/master.db', new_db)
#+END_SRC

#+RESULTS:

*** Separate data into train / test

This test will be performed with size=2,3,4 point calculations.

#+BEGIN_SRC python
from ase.db import connect
import numpy as np
import os
import random

import twodee as td

wd = 'networks/test_validation'
dbname = os.path.basename(wd) + '.db'
db = connect(os.path.join(wd, dbname))

n_ids = []
for d in db.select(['type=point', '2<=size<=4']):
    n_ids += [d.id]

n = len(n_ids)
n_train = int(round(n * 0.9))

random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

print("Done")
#+END_SRC

#+RESULTS:
: Done

*** Build the network

Generate an initial guess for the parameters to build the neural networks.

#+BEGIN_SRC python
#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Behler
from amp.regression import NeuralNetwork
from ase.db import connect
import os

wd = 'networks/test_validation'
dbname = os.path.basename(wd) + '.db'
db = connect(os.path.join(wd, dbname))

images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

pwd = os.path.join(wd, 'h={0}/n={1}/')

if not os.path.exists(pwd):
    os.makedirs(pwd)

calc = Amp(label=pwd,
dblabel=wd,
descriptor=Behler(cutoff=6.5),
regression=NeuralNetwork(hiddenlayers=(tuple([{2}]*{1}))))

calc.train(images=images,
data_format='db',
cores=1,
energy_goal=1e-3,  # The default energy training goal
force_goal=None,  # There are no forces in the training data
global_search=None,  # Already have a good starting point
extend_variables=False) # Do not use this feature
#+END_SRC

There needs to be a better way to make these submission files.
#+BEGIN_SRC python
import os

import twodee as td


wd = 'networks/test_validation'
h_layers = [2, 3, 4, 5]
nodes = [2, 3, 4, 5, 6, 7, 8, 9, 10]

for h in h_layers:
    for n in nodes:

        code = """#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Behler
from amp.regression import NeuralNetwork
from ase.db import connect
import os

wd = 'networks/test_validation'
dbname = os.path.basename(wd) + '.db'
db = connect(os.path.join(wd, dbname))

images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

pwd = os.path.join(wd, 'h={0}/n={1}/')

if not os.path.exists(pwd):
    os.makedirs(pwd)

calc = Amp(label=pwd,
dblabel=wd,
descriptor=Behler(cutoff=6.5),
regression=NeuralNetwork(hiddenlayers=(tuple([{1}]*{0}))))

calc.train(images=images,
data_format='db',
cores=1,
energy_goal=1e-3,  # The default energy training goal
force_goal=None,  # There are no forces in the training data
global_search=None,  # Already have a good starting point
extend_variables=False) # Do not use this feature
""".format(h, n)

        pwd = os.path.join(wd, 'h={0}/n={1}/'.format(h,n))
        if os.path.exists(os.path.join(pwd, 'submit.py')):
            print('h={0}/n={1} already submitted.'.format(h,n))
            continue
        if not os.path.exists(pwd):
            os.makedirs(pwd)

        submit_file = os.path.join(pwd, 'submit.py')
        with open(submit_file, 'w') as f:
            f.write(code)

        td.qsub(submit_file)
        print('h={0}/n={1} submitted.'.format(h,n))
#+END_SRC

#+RESULTS:
#+begin_example
h=2/n=2 already submitted.
h=2/n=3 already submitted.
h=2/n=4 already submitted.
h=2/n=5 already submitted.
h=2/n=6 already submitted.
h=2/n=7 already submitted.
h=2/n=8 already submitted.
h=2/n=9 already submitted.
h=2/n=10 already submitted.
h=3/n=2 already submitted.
h=3/n=3 already submitted.
h=3/n=4 already submitted.
h=3/n=5 already submitted.
h=3/n=6 already submitted.
h=3/n=7 already submitted.
h=3/n=8 already submitted.
h=3/n=9 already submitted.
h=3/n=10 already submitted.
h=4/n=2 already submitted.
h=4/n=3 already submitted.
h=4/n=4 already submitted.
h=4/n=5 already submitted.
h=4/n=6 already submitted.
h=4/n=7 already submitted.
h=4/n=8 already submitted.
h=4/n=9 already submitted.
h=4/n=10 already submitted.
h=5/n=2 already submitted.
h=5/n=3 already submitted.
h=5/n=4 already submitted.
h=5/n=5 already submitted.
h=5/n=6 already submitted.
h=5/n=7 already submitted.
h=5/n=8 already submitted.
h=5/n=9 already submitted.
h=5/n=10 already submitted.
#+end_example

*** Convergence
Check the results for convergence.
#+BEGIN_SRC python :results drawer
import json
import os

import twodee as td

print('|Hidden layers|Iteration|Time|Cost Function|Energy RMSE|')
print('|-')

wd = 'networks/test_validation'
h_layers = [2, 3, 4, 5]
nodes = [2, 3, 4, 5, 6, 7, 8, 9, 10]

for h in h_layers:
    for n in nodes:
        pwd = os.path.join(wd, 'h={0}/n={1}/'.format(h,n))
        output_files = td.calc_output_files(pwd)

        if not output_files:
            print('h={0}/n={1}: In progress.'.format(h,n))
            continue

        output = os.path.join(pwd, output_files[0])
        with open(output, 'r') as f:
            if len(f.read()) > 0:
                print('h={0}/n={1} Did not converge.'.format(h,n))
            else:
                print('h={0}/n={1} Converged.'.format(h,n))
#+END_SRC

#+RESULTS:
:RESULTS:
| Hidden layers | Iteration | Time | Cost Function | Energy RMSE |
|---------------+-----------+------+---------------+-------------|
h=2/n=2 Did not converge.
| {u'C': [3, 3]} | 909 | 2016-07-25T13:37:23 | 2.369e-04 | 9.957e-04 |
h=2/n={u'C': [3, 3]} Converged.
|{u'C': [4, 4]}|428|2016-07-25T13:35:22|2.375e-04|9.968e-04|
h=2/n={u'C': [4, 4]} Converged.
| {u'C': [5, 5]} | 267 | 2016-07-25T13:34:54 | 2.126e-04 | 9.431e-04 |
h=2/n={u'C': [5, 5]} Converged.
| {u'C': [6, 6]} | 358 | 2016-07-25T13:35:34 | 2.316e-04 | 9.844e-04 |
h=2/n={u'C': [6, 6]} Converged.
| {u'C': [7, 7]} | 233 | 2016-07-25T13:34:32 | 2.331e-04 | 9.875e-04 |
h=2/n={u'C': [7, 7]} Converged.
| {u'C': [8, 8]} | 266 | 2016-07-25T13:34:49 | 2.369e-04 | 9.955e-04 |
h=2/n={u'C': [8, 8]} Converged.
| {u'C': [9, 9]} | 262 | 2016-07-25T13:35:43 | 2.340e-04 | 9.895e-04 |
h=2/n={u'C': [9, 9]} Converged.
|{u'C': [10, 10]}|301|2016-07-25T13:35:55|2.245e-04|9.692e-04|
h=2/n={u'C': [10, 10]} Converged.
h=3/n=2 Did not converge.
| {u'C': [3, 3, 3]} | 1151 | 2016-07-25T13:39:54 | 2.378e-04 | 9.975e-04 |
h=3/n={u'C': [3, 3, 3]} Converged.
h=3/n=4 Did not converge.
| {u'C': [5, 5, 5]} | 254 | 2016-07-25T13:35:32 | 2.275e-04 | 9.756e-04 |
h=3/n={u'C': [5, 5, 5]} Converged.
h=3/n=6 Did not converge.
h=3/n=7 Did not converge.
| {u'C': [8, 8, 8]} | 302 | 2016-07-25T13:36:33 | 2.300e-04 | 9.809e-04 |
h=3/n={u'C': [8, 8, 8]} Converged.
| {u'C': [9, 9, 9]} | 286 | 2016-07-25T13:36:42 | 2.317e-04 | 9.847e-04 |
h=3/n={u'C': [9, 9, 9]} Converged.
| {u'C': [10, 10, 10]} | 198 | 2016-07-25T13:36:12 | 2.280e-04 | 9.768e-04 |
h=3/n={u'C': [10, 10, 10]} Converged.
h=4/n=2 Did not converge.
| {u'C': [3, 3, 3, 3]} | 387 | 2016-07-25T13:36:56 | 1.972e-04 | 9.083e-04 |
h=4/n={u'C': [3, 3, 3, 3]} Converged.
h=4/n=4 Did not converge.
| {u'C': [5, 5, 5, 5]} | 797 | 2016-07-25T13:38:36 | 2.322e-04 | 9.856e-04 |
h=4/n={u'C': [5, 5, 5, 5]} Converged.
h=4/n=6 Did not converge.
h=4/n=7 Did not converge.
| {u'C': [8, 8, 8, 8]} | 210 | 2016-07-25T13:36:57 | 1.932e-04 | 8.990e-04 |
h=4/n={u'C': [8, 8, 8, 8]} Converged.
| {u'C': [9, 9, 9, 9]} | 1315 | 2016-07-25T13:45:32 | 1.973e-04 | 9.087e-04 |
h=4/n={u'C': [9, 9, 9, 9]} Converged.
| {u'C': [10, 10, 10, 10]} | 2542 | 2016-07-25T13:55:58 | 2.243e-04 | 9.689e-04 |
h=4/n={u'C': [10, 10, 10, 10]} Converged.
h=5/n=2 Did not converge.
| {u'C': [3, 3, 3, 3, 3]} | 238 | 2016-07-25T13:37:04 | 2.212e-04 | 9.620e-04 |
h=5/n={u'C': [3, 3, 3, 3, 3]} Converged.
| {u'C': [4, 4, 4, 4, 4]} | 424 | 2016-07-25T13:45:54 | 2.387e-04 | 9.993e-04 |
h=5/n={u'C': [4, 4, 4, 4, 4]} Converged.
h=5/n=5 Did not converge.
h=5/n=6 Did not converge.
| {u'C': [7, 7, 7, 7, 7]} | 290 | 2016-07-25T13:38:29 | 2.213e-04 | 9.622e-04 |
h=5/n={u'C': [7, 7, 7, 7, 7]} Converged.
| {u'C': [8, 8, 8, 8, 8]} | 330 | 2016-07-25T13:38:47 | 2.314e-04 | 9.840e-04 |
h=5/n={u'C': [8, 8, 8, 8, 8]} Converged.
| {u'C': [9, 9, 9, 9, 9]} | 384 | 2016-07-25T13:39:34 | 2.094e-04 | 9.359e-04 |
h=5/n={u'C': [9, 9, 9, 9, 9]} Converged.
| {u'C': [10, 10, 10, 10, 10]} | 239 | 2016-07-25T13:39:02 | 2.370e-04 | 9.958e-04 |
h=5/n={u'C': [10, 10, 10, 10, 10]} Converged.
:END:

#+BEGIN_SRC python
import itertools
import os

import twodee as td

wd = 'networks/test_validation'
h_layers = [2, 3, 4, 5]
nodes = [2, 3, 4, 5, 6, 7, 8, 9, 10]


unconverged = set()
for h in h_layers:
    for n in nodes:
        pwd = os.path.join(wd, 'h={0}/n={1}/'.format(h,n))
        output_files = td.calc_output_files(pwd)
        output = os.path.join(pwd, output_files[0])

        with open(output, 'r') as f:
            if len(f.read()) != 0:
                unconverged.add((h, n))

converged = set(itertools.product(h_layers, nodes)) - unconverged

print("Unconverged:")
print(sorted(unconverged))
print("Converged:")
print(sorted(converged))
#+END_SRC

#+RESULTS:
: Unconverged:
: [(2, 2), (3, 2), (3, 4), (3, 6), (3, 7), (4, 2), (4, 4), (4, 6), (4, 7), (5, 2), (5, 5), (5, 6)]
: Converged:
: [(2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9), (2, 10), (3, 3), (3, 5), (3, 8), (3, 9), (3, 10), (4, 3), (4, 5), (4, 8), (4, 9), (4, 10), (5, 3), (5, 4), (5, 7), (5, 8), (5, 9), (5, 10)]

Print convergence table.
#+BEGIN_SRC python :results drawer
import json
import os

import twodee as td


wd = 'networks/test_validation'
h_layers = [2, 3, 4, 5]
nodes = [2, 3, 4, 5, 6, 7, 8, 9, 10]

print('|Hidden layers|Nodes|Iterations|Time|Cost Function|Energy RMSE|')
for h in h_layers:
    print('|-')
    for n in nodes:
        pwd = os.path.join(wd, 'h={0}/n={1}/'.format(h,n))
        output_files = td.calc_output_files(pwd)

        if not output_files:
            continue

        output = os.path.join(pwd, output_files[0])
        with open(output, 'r') as f:
            if len(f.read()) == 0:
                with open(os.path.join(pwd, 'train-log.txt'), 'r') as f:
                    v = f.readlines()[-3].split()
                    with open(os.path.join(pwd, 'trained-parameters.json'), 'r') as f:
                        p = json.load(f)
                    print('|{}|{}|{}|{}|{}|{}|'.format(h, n, v[0], v[1], v[2], v[3]))
            else:
                print('|{}|{}||||Not converged|'.format(h, n))

#+END_SRC

#+RESULTS:
:RESULTS:
| Hidden layers | Nodes | Iterations | Time                | Cost Function |   Energy RMSE |
|---------------+-------+------------+---------------------+---------------+---------------|
|             2 |     2 |            |                     |               | Not converged |
|             2 |     3 |        909 | 2016-07-25T13:37:23 |     2.369e-04 |     9.957e-04 |
|             2 |     4 |        428 | 2016-07-25T13:35:22 |     2.375e-04 |     9.968e-04 |
|             2 |     5 |        267 | 2016-07-25T13:34:54 |     2.126e-04 |     9.431e-04 |
|             2 |     6 |        358 | 2016-07-25T13:35:34 |     2.316e-04 |     9.844e-04 |
|             2 |     7 |        233 | 2016-07-25T13:34:32 |     2.331e-04 |     9.875e-04 |
|             2 |     8 |        266 | 2016-07-25T13:34:49 |     2.369e-04 |     9.955e-04 |
|             2 |     9 |        262 | 2016-07-25T13:35:43 |     2.340e-04 |     9.895e-04 |
|             2 |    10 |        301 | 2016-07-25T13:35:55 |     2.245e-04 |     9.692e-04 |
|---------------+-------+------------+---------------------+---------------+---------------|
|             3 |     2 |            |                     |               | Not converged |
|             3 |     3 |       1151 | 2016-07-25T13:39:54 |     2.378e-04 |     9.975e-04 |
|             3 |     4 |            |                     |               | Not converged |
|             3 |     5 |        254 | 2016-07-25T13:35:32 |     2.275e-04 |     9.756e-04 |
|             3 |     6 |            |                     |               | Not converged |
|             3 |     7 |            |                     |               | Not converged |
|             3 |     8 |        302 | 2016-07-25T13:36:33 |     2.300e-04 |     9.809e-04 |
|             3 |     9 |        286 | 2016-07-25T13:36:42 |     2.317e-04 |     9.847e-04 |
|             3 |    10 |        198 | 2016-07-25T13:36:12 |     2.280e-04 |     9.768e-04 |
|---------------+-------+------------+---------------------+---------------+---------------|
|             4 |     2 |            |                     |               | Not converged |
|             4 |     3 |        387 | 2016-07-25T13:36:56 |     1.972e-04 |     9.083e-04 |
|             4 |     4 |            |                     |               | Not converged |
|             4 |     5 |        797 | 2016-07-25T13:38:36 |     2.322e-04 |     9.856e-04 |
|             4 |     6 |            |                     |               | Not converged |
|             4 |     7 |            |                     |               | Not converged |
|             4 |     8 |        210 | 2016-07-25T13:36:57 |     1.932e-04 |     8.990e-04 |
|             4 |     9 |       1315 | 2016-07-25T13:45:32 |     1.973e-04 |     9.087e-04 |
|             4 |    10 |       2542 | 2016-07-25T13:55:58 |     2.243e-04 |     9.689e-04 |
|---------------+-------+------------+---------------------+---------------+---------------|
|             5 |     2 |            |                     |               | Not converged |
|             5 |     3 |        238 | 2016-07-25T13:37:04 |     2.212e-04 |     9.620e-04 |
|             5 |     4 |        424 | 2016-07-25T13:45:54 |     2.387e-04 |     9.993e-04 |
|             5 |     5 |            |                     |               | Not converged |
|             5 |     6 |            |                     |               | Not converged |
|             5 |     7 |        290 | 2016-07-25T13:38:29 |     2.213e-04 |     9.622e-04 |
|             5 |     8 |        330 | 2016-07-25T13:38:47 |     2.314e-04 |     9.840e-04 |
|             5 |     9 |        384 | 2016-07-25T13:39:34 |     2.094e-04 |     9.359e-04 |
|             5 |    10 |        239 | 2016-07-25T13:39:02 |     2.370e-04 |     9.958e-04 |
:END:

*** Test against training and test

#+BEGIN_SRC python :tangle ./queue/test_validation/calc_energies.py
#!/usr/bin/env python
from amp import Amp
from ase.db import connect
import itertools
import os

import twodee as td


wd = 'networks/test_validation'
dbname = os.path.basename(wd) + '.db'
db = connect(os.path.join(wd, dbname))

h_layers = [2, 3, 4, 5]
nodes = [2, 3, 5, 6, 7, 8, 9, 10]
sizes = [2, 3, 4]

unconverged = set()
for h in h_layers:
    for n in nodes:
        pwd = os.path.join(wd, 'h={0}/n={1}/'.format(h,n))
        output_files = td.calc_output_files(pwd)
        output = os.path.join(pwd, output_files[0])

        with open(output, 'r') as f:
            if len(f.read()) != 0:
                unconverged.add((h, n))

converged = set(itertools.product(h_layers, nodes)) - unconverged

for (h, n) in converged:
    for s in sizes:
        wd = 'networks/test_validation'
        dbname = os.path.basename(wd) + '.db'
        db = connect(os.path.join(wd, dbname))
        pwd = os.path.join(wd, 'h={0}/n={1}/'.format(h, n))
        key = 'nn-{0}_{1}'.format(h, n)
        for d in db.select(['type=point', 'size={}'.format(s)]):
            if key in d:
                continue
            calculator = Amp(pwd)
            atoms = db.get_atoms(d.id)

            atoms.set_calculator(calculator)
            energy = atoms.get_potential_energy()
            nnE = {key: energy}

            db.update(d.id, nnE)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import twodee as td

td.qsub('./queue/test_validation/calc_energies.py')
#+END_SRC

#+RESULTS:
: 1429342.gilgamesh.cheme.cmu.edu

Stopped at 23:42m

#+BEGIN_SRC python
#!/usr/bin/env python
from amp import Amp
from ase.db import connect
import itertools
import os

import twodee as td


wd = 'networks/test_validation'
dbname = os.path.basename(wd) + '.db'
db = connect(os.path.join(wd, dbname))

h_layers = [2, 3, 4, 5]
nodes = [2, 3, 5, 6, 7, 8, 9, 10]

unconverged = set()
for h in h_layers:
    for n in nodes:
        pwd = os.path.join(wd, 'h={0}/n={1}/'.format(h,n))
        output_files = td.calc_output_files(pwd)
        output = os.path.join(pwd, output_files[0])

        with open(output, 'r') as f:
            if len(f.read()) != 0:
                unconverged.add((h, n))

converged = set(itertools.product(h_layers, nodes)) - unconverged

wd = 'networks/test_validation'
dbname = os.path.basename(wd) + '.db'
db = connect(os.path.join(wd, dbname))
for d in db.select(['type=point', 'size=3']):
    key = 'nn-2_3'
    if key in d:
        print(d[key])
#+END_SRC

#+RESULTS:

** Create two solid networks
*** Copy DB and separate into train and test sets
#+BEGIN_SRC python
import os.path
import shutil

import twodee as td

wd = 'networks/nn_master'
dbname = os.path.basename(wd) + '.db'
new_db = os.path.join(wd, dbname)

if not os.path.exists(wd):
    os.makedirs(wd)
if os.path.exists(new_db):
    print("Database already exists at destination path.")
else:
    shutil.copyfile('database/master.db', new_db)
    print("Database copied successfully.")
#+END_SRC

#+RESULTS:
: Database copied successfully.

#+BEGIN_SRC python
from ase.db import connect
import numpy as np
import os
import random

import twodee as td

wd = 'networks/nn_master'
dbname = os.path.basename(wd) + '.db'
db = connect(os.path.join(wd, dbname))

n_ids = []
for d in db.select(['type=point', '2<=size<=4']):
    n_ids += [d.id]

n = len(n_ids)
n_train = int(round(n * 0.9))

random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

print("Done")
#+END_SRC

#+RESULTS:
: Done

*** Build networks

#+BEGIN_SRC python :results output org drawer
from jinja2 import Environment, PackageLoader
import os

import twodee as td

# Load in python templates
env = Environment(loader=PackageLoader('twodee', 'templates'))
header = env.get_template("header.py")
footer = env.get_template("footer.py")
ase_db_get = env.get_template("ase_db_get.py")
amp = env.get_template("amp.py")
amp_train = env.get_template("amp_train.py")
remove_file = env.get_template("remove_file.py")

wd = 'networks/nn_master/'

frameworks = ((5, 5), (8, 8), (8, 8, 8))
for framework in frameworks:
    # Build directory paths based off NN framework
    framework_str = "-".join([str(f) for f in framework])
    nn_dir = os.path.join(wd, framework_str, "")

    # Check if job already submitted
    if os.path.exists(os.path.join(nn_dir, 'submit.py')):
        print('{0} already submitted.'.format(framework_str))
    #    continue
    if not os.path.exists(nn_dir):
        os.makedirs(nn_dir)


    # Collect the rendered code from the following templates
    codes = []

    # Build the Amp object with atoms from the database
    db_path = os.path.join(wd, "nn_master.db")
    select = "train_set=True"
    codes.append(ase_db_get.render(db_path=db_path, select=select))
    desc_type = "Behler"
    desc_args = {"cutoff": 6.5}
    reg_type = "NeuralNetwork"
    reg_args = {"hiddenlayers": framework}
    amp_args = {"label": nn_dir}
    codes.append(amp.render(desc_type=desc_type,
                            desc_args=desc_args,
                            reg_type=reg_type,
                            reg_args=reg_args,
                            amp_args=amp_args))

    # First training run - Wide tolerance to converge
    gs_type = "SimulatedAnnealing"
    gs_args = {"temperature": 70, "steps": 50}
    train_args = {"data_format": 'db',
                    "cores": 1,
                    "energy_goal": 10,
                    "force_goal": None,
                    "extend_variables": False}
    codes.append(amp_train.render(train_args=train_args,
                                  gs_type=gs_type,
                                  gs_args=gs_args))

    # Remove parameters from first training run
    file_path = os.path.join(nn_dir, 'train-log.txt')
    codes.append(remove_file.render(file_path=file_path))
    file_path = os.path.join(nn_dir, 'trained-parameters.json')
    codes.append(remove_file.render(file_path=file_path))

    # Second training run starting from the initial guess of run 1
    amp_args = {"label": nn_dir,
                 "load": os.path.join(nn_dir, 'initial-parameters.json')}
    codes.append(amp.render(amp_args=amp_args))
    train_args = {"data_format": 'db',
                  "cores": 1,
                  "energy_goal": 1e-3,
                  "force_goal": None,
                  "extend_variables": False}
    codes.append(amp_train.render(train_args=train_args))
    codes.append(footer.render())
    
    # Combine all templates into one .py file and submit to queue
    code = "\n\n".join(codes)

    submit_file = os.path.join(nn_dir, 'submit.py')
    with open(submit_file, 'w') as f:
        f.write(code)

    td.qsub(submit_file, walltime="10:00:00")
    print('{0} submitted.'.format(framework_str))
#+END_SRC

#+RESULTS:
:RESULTS:
1434156.gilgamesh.cheme.cmu.edu
1434158.gilgamesh.cheme.cmu.edu
1434159.gilgamesh.cheme.cmu.edu
5-5 submitted.
8-8 submitted.
8-8-8 submitted.
:END:

*** Calculate energies
* References
bibliographystyle:unsrt
bibliography:references.bib
* Misc :noexport:
** Journal
*** 2016-05-19 Thu
 - cite:zan-2012-graph-reknit ues:
 1. Repairing graphene
 2. Stacked-graphene aperture effect
   2.1. Neural network?

*** 2016-05-20 Fri
 - cite:drahushuk-2012-mechan-gas Mechanisms of Gas Permeation through Single Layer Graphene Membranes - Drahushuk, Strano*

*** 2016-05-23 Mon
 - cite:du-2011-separ-hydrog Separation of Hydrogen and Nitrogen Gases With  Porous Graphene Membrane - Du, Zhao*

*** 2016-05-24 Tue
 - cite:koenig-2012-selec-molec Selective Molecular Sieving Through Porous Graphene - Keonig, Bunch*

*** 2016-05-25 Wed
 - cite:liu-2013-permean-h2 

 Simulators meeting
 - Jake presented neural network vs reaxff with Au

*** 2016-05-26 Thu
 - cite:jiang-2009-porous-graph

*** 2016-05-27 Fri
 - cite:sun-2014-mechan-molec

 Prepared for a group meeting presentation. Ended up not having one.

**** 2016-05-27 3pm Presentation Prep
     DEADLINE: <2016-05-27 Fri 3pm>
  (Meeting cancelled)

***** Concept of gas phase transport

  #+BEGIN_SRC python
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
import sys

heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]

def movie(constraint):
    images = []
    for i, h in enumerate(heights):
        with jasp('./dft/transport/g-mono/3x3/pore=1/molec=CO2/' + constraint + '/d={0:0.2f}'.format(h)) as calc:
            atoms = calc.get_atoms()
            images.append(atoms)
    view(images)

free = 'linear-unconst_all'
unconst_G = 'linear-unconst_G'
const_all = 'linear-const'

#movie(free)
#movie(unconst_G)
movie(const_all)
  #+END_SRC

  #+RESULTS:

***** Bond length of molecules change as they transport

  [[./img/final-project/G-bond-length.png]]

***** Total energy difference between H2 and CO2

  [[./img/final-project/total_energy-comparison.png]]

***** How constraints effect total energy

  Hydrogen transport through monolayer graphene. Pore=1
  [[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison.png]]

***** Non-interaction distance convergence
  [[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison-LJ_zoom.png]]

  How does this well distance change with other molecules?
  - Running comparisons with CO2 and N2.

***** Pore distance convergence
  What pore interaction distance is acceptable?

  [[./img/material/g-mono/4x4/pore=10/vac=16.png]]

  [[./img/material/g-mono/5x5/pore=10/vac=16.png]]

  [[./img/material/g-mono/6x6/pore=10/vac=16.png]]

***** Questions
  - How well is DFT handling multiple species?
  - - Smearing: sigma is not dependent on per molecule basis

  - Pressure can change diffusion pathways (gas phase vs adsorption)
  - - cite:du-2011-separ-hydrog
  - - cite:drahushuk-2012-mechan-gas

*** 2016-05-31 Tue
 - cite:drahushuk-2016-analy-time Analysis of Time-Varying, Stochastic Gas Transport Through Graphene Membranes - Drahushuk, Keonig, Bunch*, Strano*

 Created vaccuum distance graph to deteremine interaction distance of leading atoms in a molecule.

 Bilayer graphene unit cell in queue for relaxation.

 Need to redo some of the 'free' transport. The graphene plane simply shifted down as the molecules approached. Might help to fix carbons around the outside edge.

**** DONE Check in on monolayer 5x5 and 6x6 pore=10 calculations
     CLOSED: [2016-06-01 Wed 12:26]
*** 2016-06-01 Wed
 - cite:shan-2012-influen-chemic
 - cite:schrier-2012-carbon-dioxid
 cite:koenig-2012-selec-molec

 - cite:wang-2015-molec-valves Molecular valves for controlling gas phase transport made from discrete ångström-sized pores in graphene - Wang, Drahushuk, Strano*
   
 - cite:partoens-2007-from-graph


 Possible research idea: Look into pore stability of different passivating molecules, including what it takes to remove a passivated species (ie. if N is a more stable passivating species than H, what is the energy barrier for replacing H with N?).

**** DONE Finish structure of pore=10 for bilayer
     CLOSED: [2016-06-01 Wed 12:26]

*** 2016-06-02 Thu
**** DONE Finish pore=10 for bilayer
     CLOSED: [2016-06-01 Wed 12:26]

*** 2016-06-03 Fri
*** 2016-06-06 Mon
*** 2016-06-07 Tue
*** 2016-06-08 Wed
*** 2016-06-09 Thu
 Prepared for group meeting research update tomorrow.
*** 2016-06-10 Fri
 Group meeting.

*** 2016-06-13 Mon
*** 2016-06-14 Tue
*** 2016-06-15 Wed
*** 2016-06-16 Thu
 To build:
 - pick edge atoms
 - pick center atom
 - tie into ase database to see if structure has been run
 - top layer pore candidates

 Would the atoms removed necessarily need to be next to eachother?

 Paper motivation:
 http://pubs.acs.org/doi/abs/10.1021/acsnano.5b01762

 Paper to compare my results to (maybe):
 http://pubs.acs.org/doi/abs/10.1021/acsnano.5b01762

**** Choosing unique solutions for graphene pores

 #+BEGIN_SRC python
from ase import Atoms, Atom
from jasp import *
import numpy as np

import twodee as td


with jasp('dft/material/g-mono/final') as calc:
    atoms = calc.get_atoms()
atoms.center()
atoms = atoms.repeat((3,3,1))

def is_the_same(x, fun, *args):
    """True if the object is unchanged during the function call."""
    import copy
    y = copy.deepcopy(x)
    fun(*args)
    return x == y

def closest_atom(atoms, position, exclude=None):
    """Return the index of the atom closest to a position."""
    choices = [a.index for a in atoms]

    if exclude is not None:
        choices = [i for i in choices if i not in exclude]

    closest = None
    min_dist = None
    for i in choices:
        dist = np.linalg.norm(atoms[i].position - position)
        if np.absolute(dist) < min_dist or closest is None:
            min_dist = dist
            closest = i

    return closest

def center(atoms):
    """Return the position (x,y,z) of the center of the cell."""
    cell = np.array(atoms.get_cell())
    center = (cell[0] + cell[1]) / 2
    center += cell[2] / 2
    return center

def center_layer(atoms):
    """Return the position (x,y,z) of the center of a layer of atoms."""
    cell = np.array(atoms.get_cell())
    center = (cell[0] + cell[1]) / 2
    center += [0, 0, np.mean([a.position[2] for a in atoms])]
    return center


pore = [9]
#pore = [3, 8, 9, 14]
#pore = [6, 7, 8, 9, 12, 13, 14, 15]
td.paint_atoms(atoms, pore)
td.bp(atoms)
 #+END_SRC

 #+RESULTS:


 #+BEGIN_SRC python
import numpy as np

a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

print(a, a1*3, a2*3, a3*3)
 #+END_SRC

 #+RESULTS:
 : (2.46, array([ 6.39126748, -3.69      ,  0.        ]), array([ 6.39126748,  3.69      ,  0.        ]), array([  0.,   0.,  30.]))

**** New vasp vs jasp error

 Temporary simple-co with new vasp:
 #+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp
import numpy as np
np.set_printoptions(precision=3, suppress=True)

co = Atoms([Atom('C', [0, 0, 0]),
            Atom('O', [1.2, 0, 0])],
           cell=(6., 6., 6.))

calc = Vasp('~/tmp/molecules/simple-co',  # output dir
            xc='PBE',  # the exchange-correlation functional
            nbands=6,    # number of bands
            encut=350,    # planewave cutoff
            ismear=1,    # Methfessel-Paxton smearing
            sigma=0.01,  # very small smearing factor for a molecule
            atoms=co)
print('energy = {0} eV'.format(co.get_potential_energy()))
print(co.get_forces())
 #+END_SRC

 #+RESULTS:
 : energy = -14.69111507 eV
 : [[ 5.091  0.     0.   ]
 :  [-5.091  0.     0.   ]]

 This works:
 #+BEGIN_SRC python
from ase import Atoms, Atom
from jasp import *

with jasp('~/dft-book/molecules/simple-co') as calc:
    atoms = calc.get_atoms()
 #+END_SRC

 #+RESULTS:

 This doesn't:
 #+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

print(Vasp.default_parameters) # this works.

calc = Vasp('~/dft-book/molecules/simple-co')
atoms = calc.get_atoms()
 #+END_SRC

 #+RESULTS:

 Trace:
 #+BEGIN_SRC screen
Traceback (most recent call last):
  File "<stdin>", line 6, in <module>
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 45, in inner
    return func(self, *args, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp_core.py", line 242, in __init__
    str(label), atoms)
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 51, in inner
    return self.exception_handler(self, *sys.exc_info())
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 48, in inner
    return func(self, *args, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/ase-s16/ase/calculators/calculator.py", line 513, in __init__
    atoms, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 51, in inner
    return self.exception_handler(self, *sys.exc_info())
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 48, in inner
    return func(self, *args, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/ase-s16/ase/calculators/calculator.py", line 184, in __init__
    self.read(restart)  # read parameters, atoms and results
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 51, in inner
    return self.exception_handler(self, *sys.exc_info())
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 48, in inner
    return func(self, *args, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/readers.py", line 322, in read
    atoms = self.read_atoms()
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 51, in inner
    return self.exception_handler(self, *sys.exc_info())
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 48, in inner
    return func(self, *args, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/readers.py", line 249, in read_atoms
    atoms.positions = xatoms.positions[resort]
AttributeError: 'NoneType' object has no attribute 'positions'
 #+END_SRC

**** Monolayer graphene pore selector

 *What is it?*
 A script that takes a pristine monolayer of graphene and generates Atoms objects for all unique pores, up to the edge atoms.

 It should start with the most central carbon and systematically expand from that point, removing more and more adjacent carbons.

 /Input/
 Size of the ixi repeated monolayer graphene.

 /Output/
 A list of Atoms objects with all the possibile pore configurations. (Might have scalability issues here.)

 *Function list*
 - 


 *Next step*

*** 2016-06-21 Tue
*** 2016-06-22 Wed

 Job scraper test string:
 /home-guest/devonw/hydrogen2D/vasp/base/mat=graphene/layers=2 Queued: 1412411.gilgamesh.cheme.cmu.edu

**** Jasp Vasp comparison
***** New Vasp() view atoms bug
      CLOSED: [2016-06-22 Wed 11:39]

  #+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from vasp import Vasp
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '10:00:00'

from ase.visualize import view
import twodee as td


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3.5 * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

name = 'tmp/vasp/base/mat=graphene/layers=1'
calc = Vasp(name,
            xc='PBE',          # GGA functional type
            encut=520,
            kpts=[11,11,1],
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms)


print(atoms.get_potential_energy())
print(atoms.get_forces())
td.bp(atoms)
td.bp()

print(atoms.get_potential_energy())
#calc.view()
atoms2 = calc.get_atoms()

atoms2.set_calculator()
#view(atoms2)
print(atoms2)
#td.print_image(name, atoms)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  -18.44792199
  [[ 0.077 -0.017  0.   ]
   [-0.077  0.017  0.   ]]
  :END:

***** New Vasp() view atoms bug - in Jasp
      CLOSED: [2016-06-22 Wed 11:39]

  #+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'

from ase.visualize import view
import twodee as td


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3.5 * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

#td.bp(atoms)
name = 'tmp/jasp/base/mat=graphene/layers=1'
with jasp(name,
            xc='PBE',          # GGA functional type
            encut=520,
            kpts=(11,11,1),
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms) as calc:
    print(atoms.get_potential_energy())
    print(atoms.get_forces())
#    td.bp(calc.get_atoms())


#calc.view()

#atoms2.set_calculator()
#view(atoms2)
#print(atoms2)
#td.print_image(name, atoms)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  -18.44792199
  [[ 0.077 -0.017  0.   ]
   [-0.077  0.017  0.   ]]
  :END:

*** 2016-06-23 Thu
** jasp (deprecated)
*** Testing
**** DONE nsw test
     CLOSED: [2016-06-09 Thu 09:19]

 Brief test to understand if nsw is having an effect on my calculations being run in the queue.

  #+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *

import twodee as td


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

i = 3
atoms = atoms.repeat([i,i,1])
del atoms[17:19]

nsw = [0]
print("Did not converge: [10]")

def calculate(nsw):
    name = 'material/g-bi/3x3/pore=1/test/nsw={:0.0f}'.format(nsw)
    td.print_image(name, atoms)

    with jasp('./jasp/' + name,
                encut=520,
                kpts=(6,6,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=nsw,             # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            td.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            td.status_inprogress()
            ready = False
            pass


for n in nsw:
    print("nsw: {:}".format(n))
    calculate(n)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  Did not converge: [10]
  nsw: 0
  [[./img/material/g-bi/3x3/pore=1/test/nsw=0.png]]
  Final structure calculation: Energy/f.u. = -8.742. Calculation time: 308 min.
  :END:

  The calculation did not converge for nsw=10 (probably should have expected).

*** Material
**** INPROGRESS Graphene monolayer
***** Pristine

 #+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

name = 'material/g-mono/final'

print(atoms)
with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

print(atoms)
file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Atoms(symbols='C2', positions=..., cell=[[2.130422493309719, -1.23,
       0.0], [2.130422493309719, 1.23, 0.0], [0.0, 0.0, 18.0]],
       pbc=[False, False, False])
 Final structure calculation: Atoms: 2. Energy/f.u. = -9.228. Calculation time: 6 min.
 Atoms(symbols='C2', positions=..., cell=[[2.130422493309719, -1.23,
       0.0], [2.130422493309719, 1.23, 0.0], [0.0, 0.0, 18.0]],
       pbc=[False, False, False], calculator=Vasp(...))
 [[./img/material/g-mono/final.png]]
 :END:

***** Pore=1 (One carbon defect)
****** DONE 3x3. Non-centered, standard spacing
       CLOSED: [2016-06-02 Thu 14:44]
 Looking back, the non-centered versions of these calculations are not as intuitive to watch in a movie format. Also, the desired ease of having the symmetry point being at the gamma point does not carry to pore sizes greater than 1.

 #+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys
#JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 3
atoms = unitcell.repeat((i,i,1))

print('Graphene 3x3 pore=1:'.format(i))

del atoms[0]

name = 'material/g-mono/3x3/pore=1/non-centered/vac=10'

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Graphene 3x3 pore=1:
 Final structure calculation: Atoms: 17. Energy/f.u. = -8.759. Calculation time: 188 min.
 [[./img/material/g-mono/3x3/pore=1/non-centered/vac=10.png]]
 :END:

****** DONE 3x3. Non-centered, wide vaccuum
       CLOSED: [2016-06-02 Thu 14:43]
 Looking back, it doesn't really make sense to run these calculations with a vacuum any wider than the distance where planes of the superstructure do not interact.

 #+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *

import twodee as td


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 20.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 3
atoms = unitcell.repeat((i,i,1))

print('Graphene 3x3 pore=1:'.format(i))

del atoms[0]

name = 'material/g-mono/3x3/pore=1/non-centered/vac=20'
print(td.write_image(name, atoms))

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=100,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        td.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        td.status_inprogress()
        ready = False
        pass
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Graphene 3x3 pore=1:
 [[./img/material/g-mono/3x3/pore=1/non-centered/vac=20.png]]
 Final structure calculation: Energy/f.u. = -8.760. Calculation time: 589 min.
 :END:

****** DONE 3x3. Centered
       CLOSED: [2016-06-02 Thu 14:44]
 Based on the gas transport graph, a distance of 8 Angstrom between graphene planes should be more than sufficient to say the planes are not interacting. 

 #+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'

import twodee as td


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 8.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 3
atoms = atoms.repeat((i,i,1))

print("Position of defect: {}".format(atoms[9].position))
del atoms[9]

name = 'material/g-mono/3x3/pore=1/final'
td.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=100,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        td.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        td.status_inprogress()
        ready = False
        pass
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 7.38
 :END:

 As expected, the energy is the same as the energies of the non-centered calculations.

****** DONE 4x4, 5x5, 6x6
       CLOSED: [2016-06-10 Fri 10:48]
******* DONE Same kpts
        CLOSED: [2016-06-10 Fri 10:48]
 Calculate the energies for a monolayer of graphene with a single carbon pore for larger unitcells (more spacing between the pores).

 #+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '4GB'

import twodee as td


def calculate(name):
    ready = True
    with jasp('./jasp/' + name,
                encut=520,
                kpts=(3,3,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=0,             # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            td.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            td.status_inprogress()
            ready = False
            pass

    return ready


with jasp("jasp/material/g-mono/final") as calc:
    graphene = calc.get_atoms()

sizes = [2, 3, 4, 5, 6]
pores = [6, 9, 20, 24, 29]


for i, p in zip(sizes, pores):
    atoms = graphene.copy()
    atoms = atoms.repeat((i,i,1))
    atoms = td.make_pore(atoms, [p])

    print("size={0}x{0}".format(i))
    name = 'material/g-mono/{0:0.0f}x{0:0.0f}/pore=1/convergence/size'.format(i)
    td.print_image(name, atoms)
    calculate(name)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 size=2x2
 [[./img/material/g-mono/2x2/pore=1/convergence/size.png]]
 Final structure calculation: Energy/f.u. = -8.139. Calculation time: 3 min.
 size=3x3
 [[./img/material/g-mono/3x3/pore=1/convergence/size.png]]
 Final structure calculation: Energy/f.u. = -8.743. Calculation time: 16 min.
 size=4x4
 [[./img/material/g-mono/4x4/pore=1/convergence/size.png]]
 Final structure calculation: Energy/f.u. = -8.959. Calculation time: 87 min.
 size=5x5
 [[./img/material/g-mono/5x5/pore=1/convergence/size.png]]
 Final structure calculation: Energy/f.u. = -9.056. Calculation time: 872 min.
 size=6x6
 [[./img/material/g-mono/6x6/pore=1/convergence/size.png]]
 Final structure calculation: Energy/f.u. = -9.107. Calculation time: 2167 min.
 :END:

******* DONE kpts differing by size
        CLOSED: [2016-06-09 Thu 10:27]
 Calculate the energies for a monolayer of graphene with a single carbon pore for larger unitcells (more spacing between the pores).

 #+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '4GB'

import twodee as td


def calculate(name, k):
    ready = True
    with jasp('./jasp/' + name,
                encut=520,
                kpts=(k,k,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=0,             # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            td.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            td.status_inprogress()
            ready = False
            pass

    return ready


with jasp("jasp/material/g-mono/final") as calc:
    graphene = calc.get_atoms()

sizes = [2, 3, 4, 5, 6]
pores = [6, 9, 20, 24, 29]
kpts =  [5, 5, 5, 1, 1]

for i, p, k in zip(sizes, pores, kpts):
    atoms = graphene.copy()
    atoms = atoms.repeat((i,i,1))
    atoms = td.make_pore(atoms, [p])

    print("size={0}x{0}".format(i))
    name = 'material/g-mono/{0:0.0f}x{0:0.0f}/pore=1/convergence/size/kpts={1:0.0f}'.format(i, k)
    td.print_image(name, atoms)
    calculate(name, k)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 size=2x2
 [[./img/material/g-mono/2x2/pore=1/convergence/size/kpts=5.png]]
 Final structure calculation: Energy/f.u. = -8.180. Calculation time: 3 min.
 size=3x3
 [[./img/material/g-mono/3x3/pore=1/convergence/size/kpts=5.png]]
 Final structure calculation: Energy/f.u. = -8.746. Calculation time: 18 min.
 size=4x4
 [[./img/material/g-mono/4x4/pore=1/convergence/size/kpts=5.png]]
 Final structure calculation: Energy/f.u. = -8.958. Calculation time: 120 min.
 size=5x5
 [[./img/material/g-mono/5x5/pore=1/convergence/size/kpts=1.png]]
 Final structure calculation: Energy/f.u. = -9.044. Calculation time: 340 min.
 size=6x6
 [[./img/material/g-mono/6x6/pore=1/convergence/size/kpts=1.png]]
 Final structure calculation: Energy/f.u. = -9.090. Calculation time: 736 min.
 :END:

***** INPROGRESS Pore=10 (Ten carbon defect)
****** TODO 4x4
******* TODO final
 TODO: This does not match the results to the other k-point values. Check the nsw convergence test (running now) to see if it affects the energy.

 #+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys
#JASPRC['queue.walltime'] = '10:00:00'

import twodee as td


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 20.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 4
atoms = unitcell.repeat((i,i,1))

print('Graphene 4x4 pore=10:'.format(i))
del atoms[26]
del atoms[17:21]
del atoms[11:15]
del atoms[5]


name = 'material/g-mono/4x4/pore=10/final'

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        td.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        td.status_inprogress()
        ready = False
        pass

td.print_image(name, atoms)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Graphene 4x4 pore=10:
 Final structure calculation: Energy/f.u. = -8.167. Calculation time: 1933 min.
 [[./img/material/g-mono/4x4/pore=10/final.png]]
 :END:

******* DONE Convergence: kpts
        CLOSED: [2016-06-10 Fri 09:32]

 #+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '4GB'

import twodee as td


with jasp("jasp/material/g-mono/final") as calc:
    atoms = calc.get_atoms()

i = 4
atoms = atoms.repeat((i,i,1))

print('Graphene 4x4 pore=10:'.format(i))
del atoms[26]
del atoms[17:21]
del atoms[11:15]
del atoms[5]

kpts = [1, 3, 5]

name = 'material/g-mono/4x4/pore=10/convergence'
td.print_image(name, atoms)

def calculate(k):
    with jasp('./jasp/' + name + '/kpts={0:0.0f}'.format(k),
                encut=520,
                kpts=(k,k,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=0,             # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            td.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            td.status_inprogress()
            ready = False
            pass

for k in kpts:
    print("kpts={0}x{0}x1".format(k))
    calculate(k)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Graphene 4x4 pore=10:
 [[./img/material/g-mono/4x4/pore=10/convergence.png]]
 kpts=1x1x1
 Final structure calculation: Energy/f.u. = -8.128. Calculation time: 25 min.
 kpts=3x3x1
 Final structure calculation: Energy/f.u. = -8.112. Calculation time: 96 min.
 kpts=5x5x1
 Final structure calculation: Energy/f.u. = -8.112. Calculation time: 202 min.
 :END:

******* INPROGRESS Convergence: nsw

 #+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'

import twodee as td


with jasp("jasp/material/g-mono/final") as calc:
    atoms = calc.get_atoms()

i = 4
atoms = atoms.repeat((i,i,1))

print('Graphene 4x4 pore=10:'.format(i))
del atoms[26]
del atoms[17:21]
del atoms[11:15]
del atoms[5]

name = 'material/g-mono/4x4/pore=10/convergence/nsw=50'
td.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=520,
            kpts=(3,3,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,             # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        td.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        td.status_inprogress()
        ready = False
        pass
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 :END:

****** DONE 5x5
       CLOSED: [2016-06-09 Thu 23:25]
******* DONE final
        CLOSED: [2016-06-08 Wed 15:42]
 #+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
JASPRC['queue.mem'] = '4GB'

import twodee as td


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 5
atoms = unitcell.repeat((i,i,1))

print('Graphene 5x5 pore=10:'.format(i))
del atoms[32:35]
del atoms[23:27]
del atoms[15:18]

name = 'material/g-mono/5x5/pore=10/final'

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=0,             # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        td.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        td.status_inprogress()
        ready = False
        pass

td.print_image(name, atoms)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Graphene 5x5 pore=10:
 Final structure calculation: Energy/f.u. = -8.604. Calculation time: 2933 min.
 [[./img/material/g-mono/5x5/pore=10/final.png]]
 :END:

 Looking at the structure in view(atoms) shows that the structure has not changed at all from the base structure. All lattice constants are still 2.46, though the energy/f.u. is higher. Not sure if this structure is accurate.

******* INPROGRESS ediffg -0.05 comarison
 #+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'

import twodee as td


with jasp('jasp/material/g-mono/final') as calc:
    unitcell = calc.get_atoms()
i = 5
atoms = unitcell.repeat((i,i,1))

print('Graphene 5x5 pore=10:'.format(i))
atoms = td.make_pore(atoms, [15, 16, 17, 23, 24, 25, 26, 32, 33, 34])

name = 'jasp/material/g-mono/5x5/pore=10/convergence/ediffg=-0.05'
with jasp(name,
            encut=520,
            kpts=(5,5,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            ediffg=-0.05,
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        td.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        td.status_inprogress()
        ready = False
        pass

td.print_image(name, atoms)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Graphene 5x5 pore=10:
 Final structure calculation: In progress.
 [[./img/jasp/material/g-mono/5x5/pore=10/convergence/ediffg=-0.05.png]]
 :END:

Looking at the structure in view(atoms) shows that the structure has not changed at all from the base structure. All lattice constants are still 2.46, though the energy/f.u. is higher. Not sure if this structure is accurate.

******* DONE Convergence: kpts
        CLOSED: [2016-06-09 Thu 22:21]

 #+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '4GB'

import twodee as td


with jasp("jasp/material/g-mono/final") as calc:
    atoms = calc.get_atoms()

i = 5
atoms = atoms.repeat((i,i,1))

print('Graphene 5x5 pore=10:'.format(i))
del atoms[32:35]
del atoms[23:27]
del atoms[15:18]


kpts = [1, 3, 5]

name = 'material/g-mono/5x5/pore=10/convergence'
td.print_image(name, atoms)

def calculate(k):
    with jasp('./jasp/' + name + '/kpts={0:0.0f}'.format(k),
                encut=520,
                kpts=(k,k,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=0,             # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            td.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            td.status_inprogress()
            ready = False
            pass

for k in kpts:
    print("kpts={0}x{0}x1".format(k))
    calculate(k)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Graphene 5x5 pore=10:
 [[./img/material/g-mono/5x5/pore=10/convergence.png]]
 kpts=1x1x1
 Final structure calculation: Energy/f.u. = -8.580. Calculation time: 96 min.
 kpts=3x3x1
 Final structure calculation: Energy/f.u. = -8.604. Calculation time: 966 min.
 kpts=5x5x1
 Final structure calculation: Energy/f.u. = -8.604. Calculation time: 1098 min.
 :END:

 Looks to be converged within 0.001 eV with a 3x3x1 k-point grid. A 1x1x1 grid is within ~0.02 eV. 

****** DONE 6x6
       CLOSED: [2016-06-21 Tue 14:44]

 #+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '8GB'

import twodee as td


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")

with jasp('jasp/material/g-mono/final') as calc:
    atoms = calc.get_atoms()
td.set_vacuum(atoms, 16)
i = 6
atoms = atoms.repeat((i,i,1))
pore = [19, 29, 30, 31, 32, 39, 40, 41, 42, 52]
atoms = td.make_pore(atoms, pore)

print('Graphene {0:1.1f}x{0:1.1f} pore=10:'.format(i))

name = 'material/g-mono/6x6/pore=10/vac=16/kpts=1'
td.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=520,
            kpts=(1,1,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        td.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        td.status_inprogress()
        ready = False
        pass

 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Graphene 6.0x6.0 pore=10:
 [[./img/material/g-mono/6x6/pore=10/vac=16/kpts=1.png]]
 Final structure calculation: Energy/f.u. = -8.850. Calculation time: 2929 min.

 :END:

**** Graphene bilayer
***** Pristine
****** DONE final
       CLOSED: [2016-06-09 Thu 10:32]
  Structure obtained from https://www.tfkp.physik.uni-erlangen.de/download/theses/master_daniel-branski.pdf.

  #+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

name = 'material/g-bi/final'

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  Final structure calculation: Atoms: 4. Energy/f.u. = -9.225. Calculation time: 14 min.
  [[./img/material/g-bi/final.png]]
  :END:

***** TODO Pore=1
****** TODO 3x3
 TODO: Update path to /final

 #+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *

import twodee as td


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

i = 3
atoms = atoms.repeat([i,i,1])
del atoms[17:19]

name = 'material/g-bi/3x3/pore=1'

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=150,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Final structure calculation: Atoms: 34. Energy/f.u. = -8.759. Calculation time: 277 min.
 [[./img/material/g-bi/3x3/pore=1.png]]
 :END:

****** TODO 4x4
******* DONE final
        CLOSED: [2016-06-21 Tue 15:04]
 #+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from jasp import *

import twodee as td


with jasp('jasp/material/g-bi/final') as calc:
    atoms = calc.get_atoms()
td.set_vacuum(atoms, 16)
i = 4
atoms = atoms.repeat([i,i,1])
pore = [41, 42]
atoms = td.make_pore(atoms, pore)

name = 'material/g-bi/{0:0.0f}x{0:0.0f}/pore=1'.format(i)
td.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=520,
            kpts=(3,3,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        td.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        td.status_inprogress()
        ready = False
        pass
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 [[./img/material/g-bi/4x4/pore=1.png]]
 Final structure calculation: Energy/f.u. = -8.967. Calculation time: 3287 min.
 :END:

******* DONE nsw=0, kpts=1
        CLOSED: [2016-06-21 Tue 15:04]
 #+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from jasp import *

import twodee as td


with jasp('jasp/material/g-bi/final') as calc:
    atoms = calc.get_atoms()
td.set_vacuum(atoms, 16)
i = 4
atoms = atoms.repeat([i,i,1])
pore = [41, 42]
atoms = td.make_pore(atoms, pore)

name = 'material/g-bi/{0:0.0f}x{0:0.0f}/pore=1/convergence/nsw=0'.format(i)
td.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=520,
            kpts=(3,3,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=0,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        td.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        td.status_inprogress()
        ready = False
        pass

name = 'material/g-bi/{0:0.0f}x{0:0.0f}/pore=1/convergence/kpts=1'.format(i)
td.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=520,
            kpts=(1,1,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=0,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        td.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        td.status_inprogress()
        ready = False
        pass
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 [[./img/material/g-bi/4x4/pore=1/convergence/nsw=0.png]]
 Final structure calculation: Energy/f.u. = -8.955. Calculation time: 418 min.
 [[./img/material/g-bi/4x4/pore=1/convergence/kpts=1.png]]
 Final structure calculation: Energy/f.u. = -8.979. Calculation time: 156 min.
 :END:

***** CANCELED Pore=10
      CLOSED: [2016-06-21 Tue 14:59]
****** CANCELED Final
       CLOSED: [2016-06-09 Thu 09:14]

 #+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
JASPRC['queue.mem'] = '8GB'

import twodee as td


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 16. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

i = 6
atoms = atoms.repeat([i,i,1])

pore_l1 = [57, 60, 61, 80, 81, 84, 85, 104, 105, 108]
pore_l2 = [35, 38, 39, 58, 59, 62, 63, 82, 83, 86]
pore = pore_l1 + pore_l2
pore.sort()
for p in reversed(pore):
#    atoms[p].symbol = "N"
    del atoms[p]


name = 'material/g-bi/6x6/pore=10/final'
td.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=100,           # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        td.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        td.status_inprogress()
        ready = False
        pass
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 [[./img/material/g-bi/6x6/pore=10/final.png]]
 Final structure calculation: In progress.
 :END:

****** CANCELED Kpts test
       CLOSED: [2016-06-09 Thu 09:15]
 Test the effect that k-points may have on the convergence of a 6x6 repeated bilayer graphene.

 #+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
JASPRC['queue.mem'] = '8GB'

import twodee as td


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 16. # vaccuum height between material planes

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

i = 6
atoms = atoms.repeat([i,i,1])

pore_l1 = [57, 60, 61, 80, 81, 84, 85, 104, 105, 108]
pore_l2 = [35, 38, 39, 58, 59, 62, 63, 82, 83, 86]
pore = pore_l1 + pore_l2
pore.sort()
for p in reversed(pore):
#    atoms[p].symbol = "N"
    del atoms[p]


name = 'material/g-bi/6x6/pore=10'
td.print_image(name, atoms)

kpts = [3, 5] 
print("Failed to complete: [1, 2, 4, 7]")

def calculate(k):
    with jasp('./jasp/' + name + '/kpts={:0.0f}'.format(k),
                encut=520,
                kpts=(k,k,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=100,           # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            td.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            td.status_inprogress()
            ready = False
            pass

for k in kpts:
    print("kpts=({0},{0},1):".format(k))
    calculate(k)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 :END:

 The 

 | k-points (ixix1) | Memory requested [GB] |
 |                1 |                   0.9 |
 |                2 |                   3.0 |
 |                3 |                   2.5 |
 |                4 |                  10.4 |
 |                5 |                   5.9 |
 |                6 |                  22.9 |
 |                7 |                  10.8 |

****** CANCELED Minimal resource use
       CLOSED: [2016-06-21 Tue 14:59]
 Run a calculation with the least possible resources. It's okay if the energy is a poor calculation, let's just see if time-wise this type of calculation is feasible.

 Some notes
 - sigma for bi-layer smaller than monolayer 


 #+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '2GB'

import twodee as td


with jasp('jasp/material/g-bi/final') as calc:
    atoms = calc.get_atoms()
td.set_vacuum(atoms, 16)
i = 6
atoms = atoms.repeat([i,i,1])

pore_l1 = [57, 60, 61, 80, 81, 84, 85, 104, 105, 108]
pore_l2 = [35, 38, 39, 58, 59, 62, 63, 82, 83, 86]
pore = pore_l1 + pore_l2
atoms = td.make_pore(atoms, pore)

name = 'material/g-bi/6x6/pore=10/convergence/minimal'
td.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=350,
            kpts=(1,1,1),
            xc='LDA',
            ismear=0,
            sigma=0.2,
            isif=2,
            ibrion=1,
            nsw=50,
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        td.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        td.status_inprogress()
        ready = False
        pass
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 :END:

*** Transport
**** Graphene monolayer
***** Linear NEB
****** TODO H2 linear-const-const

 #+BEGIN_SRC python :results drawer
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

import twodee as td


def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('jasp/material/g-mono/3x3/pore=1/final') as calc:
    graphene = calc.get_atoms()

td.set_vacuum(graphene, 20)
defect_pos = np.array([5.681, 0., 10.]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
#heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2.]
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1.5, -2.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
HH_bond = 0.74 # Bond length [Ang]
for i, h in enumerate(heights):
    H2 = Atoms([Atom('H', defect_pos + (0, 0, h - HH_bond/2.)),
                Atom('H', defect_pos + (0, 0, h + HH_bond/2.))])
    atoms[i].extend(H2)


# Hydrogen fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'H':
        hydrogen_constraint = [FixAtoms(indices=[atom.index])]
        break


# Graphene total constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Unconstrained graphene, unconstrained molecule
# Constraint one carbon so the entire plane doesn't shift as the molecule approaches
atoms_free = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_free[i].set_constraint([FixAtoms(indices=[0])])

# Unconstrained graphene, constrained molecule
atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(hydrogen_constraint)

# Constrained graphene, constrained molecule
atoms_con = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_con[i].set_constraint(hydrogen_constraint + graphene_constraint)

ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./jasp/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/'

print('Unconstrained graphene, unconstrained hydrogen:')
name_free = base_name + 'linear-free-free'
TE_free = []
calculate(name_free, atoms_free, TE_free)

#print('')
#print('Unconstrained graphene, constrained leading hydrogen:')
#name_uncon = base_name + 'linear-free-const'
#TE_uncon = []
#calculate(name_uncon, atoms_uncon, TE_uncon)

print('')
print('Constrained graphene, constrained leading hydrogen:')
name_con = base_name + 'linear-const-const'
TE_con = []
calculate(name_con, atoms_con, TE_con)

if not ready:
    sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
#TE_uncon = np.array(TE_uncon)
#TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(-2,10,200)
    plt.plot(x_lin, spline(x_lin), style)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
spline_free = interp1d(heights, TE_free, kind='cubic')
plt.plot(heights, TE_free, 'ro', label='No constraints')
#plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
#plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Center of molecule height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Unconstrained graphene, unconstrained hydrogen:
 Distance: 10.00. Energy = -155.683. Calculation time: 807 min.
 Distance:  9.00. Energy = -155.683. Calculation time: 811 min.
 Distance:  8.00. Energy = -155.683. Calculation time: 422 min.
 Distance:  7.00. Energy = -155.684. Calculation time: 421 min.
 Distance:  6.00. Energy = -155.684. Calculation time: 582 min.
 Distance:  5.00. Energy = -155.687. Calculation time: 582 min.
 Distance:  4.00. Energy = -155.695. Calculation time: 307 min.
 Distance:  3.00. Energy = -155.690. Calculation time: 299 min.
 Distance:  2.50. Energy = -155.681. Calculation time: 1802 min.
 Distance:  2.00. Energy = -155.707. Calculation time: 2886 min.
 Distance:  1.50. Energy = -155.696. Calculation time: 2803 min.
 Distance:  1.00. Energy = -158.272. Calculation time: 6159 min.
 Distance:  0.50. Energy = -158.278. Calculation time: 5042 min.
 Distance:  0.00. Energy = -155.239. Calculation time: 1338 min.
 Distance: -0.50. Energy = -158.278. Calculation time: 5150 min.
 Distance: -1.50. Energy = -155.695. Calculation time: 3496 min.
 Distance: -2.00. Energy = -155.671. Calculation time: 2967 min.

 Constrained graphene, constrained leading hydrogen:
 Distance: 10.00. Energy = -155.683. Calculation time: 484 min.
 Distance:  9.00. Energy = -155.683. Calculation time: 574 min.
 Distance:  8.00. Energy = -155.683. Calculation time: 834 min.
 Distance:  7.00. Energy = -155.684. Calculation time: 415 min.
 Distance:  6.00. Energy = -155.684. Calculation time: 849 min.
 Distance:  5.00. Energy = -155.687. Calculation time: 622 min.
 Distance:  4.00. Energy = -155.695. Calculation time: 587 min.
 Distance:  3.00. Energy = -155.690. Calculation time: 757 min.
 Distance:  2.50. Energy = -155.611. Calculation time: 1040 min.
 Distance:  2.00. Energy = -155.283. Calculation time: 981 min.
 Distance:  1.50. Energy = -154.461. Calculation time: 1070 min.
 Distance:  1.00. Energy = -153.815. Calculation time: 508 min.
 Distance:  0.50. Energy = -154.247. Calculation time: 515 min.
 Distance:  0.00. Energy = -154.990. Calculation time: 509 min.
 Distance: -0.50. Energy = -155.130. Calculation time: 787 min.
 Distance: -1.50. Energy = -154.380. Calculation time: 464 min.
 Distance: -2.00. Energy = -155.269. Calculation time: 477 min.

 [[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison.png]]
 :END:

 The free-free calculation did not converge at a molecule height of -1.0 Ang.

***** TODO Linear - 3x3 pore=1
 This is the type of transport I used for the final project in 0640. Essentially, I believe it tries to simulate an ab-initio MD calculation, which I need to look into.

 Pros:
 - Better than a L-J MD at each point.

 Cons:
 - This should be setup as a NEB calculation
 - Meaningful calculations are too costly.
 - Pore distances must be kept small.

****** H2
******* const-const, const-free. Same params as final project
 Somewhat done for now. The unconstrained graphene + constrained H2 molecule calculations did not finish in time. Unfortunately, that is the one that would be most accurate to what is really going on with the transport.

 #+BEGIN_SRC python :results drawer
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

import twodee as td


def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('jasp/material/g-mono/3x3/pore=1/final') as calc:
    graphene = calc.get_atoms()

td.set_vacuum(graphene, 20)
defect_pos = np.array([5.681, 0., 10.]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
#heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2.]
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1.5, -2.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
HH_bond = 0.74 # Bond length [Ang]
for i, h in enumerate(heights):
    H2 = Atoms([Atom('H', defect_pos + (0, 0, h - HH_bond/2.)),
                Atom('H', defect_pos + (0, 0, h + HH_bond/2.))])
    atoms[i].extend(H2)


# Hydrogen fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'H':
        hydrogen_constraint = [FixAtoms(indices=[atom.index])]
        break


# Graphene total constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Unconstrained graphene, unconstrained molecule
# Constraint one carbon so the entire plane doesn't shift as the molecule approaches
atoms_free = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_free[i].set_constraint([FixAtoms(indices=[0])])

# Unconstrained graphene, constrained molecule
atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(hydrogen_constraint)

# Constrained graphene, constrained molecule
atoms_con = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_con[i].set_constraint(hydrogen_constraint + graphene_constraint)

ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./jasp/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/'

print('Unconstrained graphene, unconstrained hydrogen:')
name_free = base_name + 'linear-free-free'
TE_free = []
calculate(name_free, atoms_free, TE_free)

#print('')
#print('Unconstrained graphene, constrained leading hydrogen:')
#name_uncon = base_name + 'linear-free-const'
#TE_uncon = []
#calculate(name_uncon, atoms_uncon, TE_uncon)

print('')
print('Constrained graphene, constrained leading hydrogen:')
name_con = base_name + 'linear-const-const'
TE_con = []
calculate(name_con, atoms_con, TE_con)

if not ready:
    sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
#TE_uncon = np.array(TE_uncon)
#TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(-2,10,200)
    plt.plot(x_lin, spline(x_lin), style)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
spline_free = interp1d(heights, TE_free, kind='cubic')
plt.plot(heights, TE_free, 'ro', label='No constraints')
#plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
#plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Center of molecule height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Unconstrained graphene, unconstrained hydrogen:
 Distance: 10.00. Energy = -155.683. Calculation time: 807 min.
 Distance:  9.00. Energy = -155.683. Calculation time: 811 min.
 Distance:  8.00. Energy = -155.683. Calculation time: 422 min.
 Distance:  7.00. Energy = -155.684. Calculation time: 421 min.
 Distance:  6.00. Energy = -155.684. Calculation time: 582 min.
 Distance:  5.00. Energy = -155.687. Calculation time: 582 min.
 Distance:  4.00. Energy = -155.695. Calculation time: 307 min.
 Distance:  3.00. Energy = -155.690. Calculation time: 299 min.
 Distance:  2.50. Energy = -155.681. Calculation time: 1802 min.
 Distance:  2.00. Energy = -155.707. Calculation time: 2886 min.
 Distance:  1.50. Energy = -155.696. Calculation time: 2803 min.
 Distance:  1.00. Energy = -158.272. Calculation time: 6159 min.
 Distance:  0.50. Energy = -158.278. Calculation time: 5042 min.
 Distance:  0.00. Energy = -155.239. Calculation time: 1338 min.
 Distance: -0.50. Energy = -158.278. Calculation time: 5150 min.
 Distance: -1.50. Energy = -155.695. Calculation time: 3496 min.
 Distance: -2.00. Energy = -155.671. Calculation time: 2967 min.

 Constrained graphene, constrained leading hydrogen:
 Distance: 10.00. Energy = -155.683. Calculation time: 484 min.
 Distance:  9.00. Energy = -155.683. Calculation time: 574 min.
 Distance:  8.00. Energy = -155.683. Calculation time: 834 min.
 Distance:  7.00. Energy = -155.684. Calculation time: 415 min.
 Distance:  6.00. Energy = -155.684. Calculation time: 849 min.
 Distance:  5.00. Energy = -155.687. Calculation time: 622 min.
 Distance:  4.00. Energy = -155.695. Calculation time: 587 min.
 Distance:  3.00. Energy = -155.690. Calculation time: 757 min.
 Distance:  2.50. Energy = -155.611. Calculation time: 1040 min.
 Distance:  2.00. Energy = -155.283. Calculation time: 981 min.
 Distance:  1.50. Energy = -154.461. Calculation time: 1070 min.
 Distance:  1.00. Energy = -153.815. Calculation time: 508 min.
 Distance:  0.50. Energy = -154.247. Calculation time: 515 min.
 Distance:  0.00. Energy = -154.990. Calculation time: 509 min.
 Distance: -0.50. Energy = -155.130. Calculation time: 787 min.
 Distance: -1.50. Energy = -154.380. Calculation time: 464 min.
 Distance: -2.00. Energy = -155.269. Calculation time: 477 min.

 [[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison.png]]
 :END:

 The free-free calculation did not converge at a molecule height of -1.0 Ang.

******* INPROGRESS free-const

 #+BEGIN_SRC python :results drawer
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

import twodee as td


def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('jasp/material/g-mono/3x3/pore=1/final') as calc:
    graphene = calc.get_atoms()

td.set_vacuum(graphene, 20)
defect_pos = np.array([5.681, 0., 10.]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
#heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2.]
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1.5, -2.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
HH_bond = 0.74 # Bond length [Ang]
for i, h in enumerate(heights):
    H2 = Atoms([Atom('H', defect_pos + (0, 0, h - HH_bond/2.)),
                Atom('H', defect_pos + (0, 0, h + HH_bond/2.))])
    atoms[i].extend(H2)


# Hydrogen fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'H':
        hydrogen_constraint = [FixAtoms(indices=[atom.index])]
        break


# Graphene total constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]


# Unconstrained graphene, constrained molecule
atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(hydrogen_constraint)


ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./jasp/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(5,5,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=0,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/'

print('Unconstrained graphene, constrained leading hydrogen:')
name_uncon = base_name + 'linear-free-const'
TE_uncon = []
calculate(name_uncon, atoms_uncon, TE_uncon)

if not ready:
    sys.exit()

# Consider the change in energy from lowest energy state
TE_uncon = np.array(TE_uncon)
TE_uncon -= min(TE_uncon)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(-2,10,200)
    plt.plot(x_lin, spline(x_lin), style)

from ase.visualize import view
view(atoms_uncon)
td.bp()
td.bp(atoms_uncon)
# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plot_spline(heights, TE_uncon, plt, 'g-')
plt.xlabel('Center of molecule height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Unconstrained graphene, constrained leading hydrogen:
 Distance: 10.00. Energy = -155.682. Calculation time:  88 min.
 Distance:  9.00. Energy = -155.682. Calculation time:  96 min.
 Distance:  8.00. Energy = -155.682. Calculation time: 304 min.
 Distance:  7.00. Energy = -155.683. Calculation time:  78 min.
 Distance:  6.00. Energy = -155.683. Calculation time:  79 min.
 Distance:  5.00. Energy = -155.686. Calculation time: 249 min.
 Distance:  4.00. Energy = -155.694. Calculation time: 126 min.
 Distance:  3.00. Energy = -155.688. Calculation time: 197 min.
 Distance:  2.50. Energy = -155.606. Calculation time:  66 min.
 Distance:  2.00. Energy = -155.263. Calculation time: 153 min.
 Distance:  1.50. Energy = -154.363. Calculation time:  54 min.
 Distance:  1.00. Energy = -153.467. Calculation time: 228 min.
 Distance:  0.50. Energy = -153.590. Calculation time:  86 min.
 Distance:  0.00. Energy = -153.925. Calculation time: 262 min.
 Distance: -0.50. Energy = -153.590. Calculation time:  72 min.
 Distance: -1.50. Energy = -154.363. Calculation time:  98 min.
 Distance: -2.00. Energy = -155.263. Calculation time: 109 min.
 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 :END:

******* INPROGRESS free-const 2

 #+BEGIN_SRC python :results drawer
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

import twodee as td


def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('jasp/material/g-mono/3x3/pore=1/final') as calc:
    graphene = calc.get_atoms()

td.set_vacuum(graphene, 20)
defect_pos = np.array([5.681, 0., 10.]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
#heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2.]
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1.5, -2.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
HH_bond = 0.74 # Bond length [Ang]
for i, h in enumerate(heights):
    H2 = Atoms([Atom('H', defect_pos + (0, 0, h - HH_bond/2.)),
                Atom('H', defect_pos + (0, 0, h + HH_bond/2.))])
    atoms[i].extend(H2)


# Hydrogen fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'H':
        hydrogen_constraint = [FixAtoms(indices=[atom.index])]
        break


# Graphene total constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]


# Unconstrained graphene, constrained molecule
atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(hydrogen_constraint)


ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./jasp/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(5,5,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=50,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/nsw=50/'

td.bp(atoms_uncon)
print('Unconstrained graphene, constrained leading hydrogen:')
name_uncon = base_name + 'linear-free-const'
TE_uncon = []
calculate(name_uncon, atoms_uncon, TE_uncon)

if not ready:
    sys.exit()

# Consider the change in energy from lowest energy state
TE_uncon = np.array(TE_uncon)
TE_uncon -= min(TE_uncon)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(-2,10,200)
    plt.plot(x_lin, spline(x_lin), style)

# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plot_spline(heights, TE_uncon, plt, 'g-')
plt.xlabel('Center of molecule height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 Atoms(symbols='C17H2', positions=..., tags=...,
       cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
       0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
       constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

 :END:

****** DONE N2
       CLOSED: [2016-06-08 Wed 16:05]

 Only ran the       


 #+BEGIN_SRC python
import copy
import numpy as np
import matplotlib.pyplot as plt
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('jasp/material/g-mono/3x3/pore=1/non-centered/vac=20') as calc:
    graphene = calc.get_atoms()
plane_height = 10.
defect_pos = np.array([0, 0., plane_height]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
bond1 = 1.13 # Bond length [Ang]
for i, h in enumerate(heights):
    N2 = Atoms([Atom('N', defect_pos + (0, 0, h - bond1/2.)),
                Atom('N', defect_pos + (0, 0, h + bond1/2.))])
    atoms[i].extend(N2)


# Fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'N':
        molecule_constraint = [FixAtoms(indices=[atom.index])]
        break

# Graphene constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Make images with constraints
atoms_free = copy.deepcopy(atoms)

atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(molecule_constraint)

atoms_con = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_con[i].set_constraint(molecule_constraint + graphene_constraint)

ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./jasp/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=N2/'

#print('Unconstrained graphene, unconstrained hydrogen:')
#name_free = base_name + 'linear-unconst_all'
#TE_free = []
#calculate(name_free, atoms_free, TE_free)
#
#print('')
#print('Unconstrained graphene, constrained leading hydrogen:')
#name_uncon = base_name + 'linear-unconst_G'
#TE_uncon = []
#calculate(name_uncon, atoms_uncon, TE_uncon)

print('')
print('Constrained graphene, constrained leading atom:')
name_con = base_name + 'linear-const'
TE_con = []
calculate(name_con, atoms_con, TE_con)

if not ready:
    sys.exit()
sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
TE_uncon = np.array(TE_uncon)
TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.plot(heights, TE_free, label='No constraints')
plt.plot(heights, TE_uncon, label='Leading H atom constrained')
plt.plot(heights, TE_con, label='All constrained')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
 #+END_SRC

 #+RESULTS:

****** DONE CO2
       CLOSED: [2016-06-08 Wed 16:05]

 #+BEGIN_SRC python
import copy
import numpy as np
import matplotlib.pyplot as plt
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('jasp/material/g-mono/3x3/pore=1/vac=20') as calc:
    graphene = calc.get_atoms()
plane_height = 10.
defect_pos = np.array([0, 0., plane_height]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]
CO_bond = 1.21 # Bond length [Ang]
atoms =  [Atoms(graphene) for i in range(len(heights))]
for i, h in enumerate(heights):
    CO2 = Atoms([Atom('O', defect_pos + (0., 0., h - CO_bond)),
                 Atom('C', defect_pos + (0., 0., h)),
                 Atom('O', defect_pos + (0., 0., h + CO_bond))])
    atoms[i].extend(CO2)

# Fixed position constraint
for i, atom in enumerate(atoms[0]):
    if atom.symbol == 'O':
        molecule_constraint = [FixAtoms(indices=[atom.index+1])]
        break

# Graphene constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Make images with constraints
atoms_free = copy.deepcopy(atoms)

atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(molecule_constraint)

atoms_con = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_con[i].set_constraint(molecule_constraint + graphene_constraint)


ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./jasp/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=CO2/'

print('Unconstrained graphene, unconstrained molecule:')
name_free = base_name + 'linear-unconst_all'
TE_free = []
calculate(name_free, atoms_free, TE_free)

print('')
print('Unconstrained graphene, constrained CO2 carbon:')
name_uncon = base_name + 'linear-unconst_G'
TE_uncon = []
calculate(name_uncon, atoms_uncon, TE_uncon)

print('')
print('Constrained graphene, constrained CO2 carbon:')
name_con = base_name + 'linear-const'
TE_con = []
calculate(name_con, atoms_con, TE_con)

if not ready:
    sys.exit()
sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
TE_uncon = np.array(TE_uncon)
TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.plot(heights, TE_free, label='No constraints')
plt.plot(heights, TE_uncon, label='Leading H atom constrained')
plt.plot(heights, TE_con, label='All constrained')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
 #+END_SRC

 #+RESULTS:
 #+begin_example
Unconstrained graphene, unconstrained molecule:
Distance: 10.00. Energy = -171.861. Calculation time: 387 min.
Distance:  9.00. Energy = -171.861. Calculation time: 604 min.
Distance:  8.00. Energy = -171.861. Calculation time: 556 min.
Distance:  7.00. Energy = -171.861. Calculation time: 339 min.
Distance:  6.00. Energy = -171.861. Calculation time: 347 min.
Distance:  5.00. Energy = -171.863. Calculation time: 381 min.
Distance:  4.00. Energy = -171.803. Calculation time: 355 min.
Distance:  3.00. Energy = -171.800. Calculation time: 2632 min.
Distance:  2.50. Energy = -171.741. Calculation time: 4954 min.
Distance:  2.00. Energy = -171.777. Calculation time: 4830 min.
Distance:  1.50. Energy = -173.486. Calculation time: 2459 min.
Distance:  1.00. Energy = -172.259. Calculation time: 1947 min.
Distance:  0.50. Energy = -172.258. Calculation time: 2127 min.
Distance:  0.00. Energy = -170.043. Calculation time: 1282 min.

Unconstrained graphene, constrained CO2 carbon:
Distance: 10.00. Energy = -171.861. Calculation time: 265 min.
Distance:  9.00. Energy = -171.861. Calculation time: 277 min.
Distance:  8.00. Energy = -171.861. Calculation time: 291 min.
Distance:  7.00. Energy = -171.861. Calculation time: 275 min.
Distance:  6.00. Energy = -171.861. Calculation time: 267 min.
Distance:  5.00. Energy = -171.863. Calculation time: 284 min.
Distance:  4.00. Energy = -171.803. Calculation time: 273 min.
Distance:  3.00. Energy = -171.757. Calculation time: 2732 min.
Distance:  2.50. Energy = -171.796. Calculation time: 4690 min.
Distance:  2.00. Energy = -171.787. Calculation time: 4402 min.
Distance:  1.50. In progress.
Distance:  1.00. Energy = -172.244. Calculation time: 814 min.
Distance:  0.50. Energy = -172.256. Calculation time: 2039 min.
Distance:  0.00. Energy = -170.043. Calculation time: 786 min.

Constrained graphene, constrained CO2 carbon:
Distance: 10.00. Energy = -171.861. Calculation time: 300 min.
Distance:  9.00. Energy = -171.861. Calculation time: 303 min.
Distance:  8.00. Energy = -171.861. Calculation time: 325 min.
Distance:  7.00. Energy = -171.861. Calculation time: 323 min.
Distance:  6.00. Energy = -171.861. Calculation time: 313 min.
Distance:  5.00. Energy = -171.863. Calculation time: 318 min.
Distance:  4.00. Energy = -171.803. Calculation time: 215 min.
Distance:  3.00. Energy = -170.736. Calculation time: 249 min.
Distance:  2.50. Energy = -168.686. Calculation time: 247 min.
Distance:  2.00. Energy = -166.160. Calculation time: 122 min.
Distance:  1.50. Energy = -171.428. Calculation time: 432 min.
Distance:  1.00. Energy = -171.304. Calculation time: 306 min.
Distance:  0.50. Energy = -170.840. Calculation time: 504 min.
Distance:  0.00. Energy = -169.706. Calculation time: 424 min.
 #+end_example

*** Results
**** DONE Final project
     CLOSED: [2016-06-09 Thu 22:20]
***** DONE Bond length
      CLOSED: [2016-06-09 Thu 22:20]

  #+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

import twodee as td


fp_dir = '~/techela/s16-06640/final-project/' # Directory of final project.

# Distance of the molecule normal to the graphene plane
heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]

# Calculated distance after relaxation
h_rel = []

BL_h = []
BL_co2 = [[], []]
for i, h in enumerate(heights):

    with jasp(fp_dir + 'transport/G-c-HHc-constraints-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        bond_dist = atoms.get_distance(17,18)
        BL_h.append(bond_dist)
        h_fixed = atoms[17].position[2]
        h_graphene = atoms[0].position[2]
        h_rel_i = h_fixed + (bond_dist / 2.) - h_graphene
        h_rel.append(h_rel_i)

    with jasp(fp_dir + 'transport/G-c-CO2-transport-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        BL_co2[0].append(atoms.get_distance(17,18))
        BL_co2[1].append(atoms.get_distance(18,19))


file_path = './img/final-project/G-bond-length.png'
plt.plot(h_rel, BL_h, 'ro-', label='H2')
plt.plot(heights, BL_co2[0], 'go-', label='CO2 #1')
plt.plot(heights, BL_co2[1], 'bo-', label='CO2 #2')
plt.xlabel('Molecule center distance from graphene plane ($\AA$)')
plt.ylabel('Bond length ($\AA$)')
plt.ylim([0.5,3])
plt.xlim([-3,3])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  [[./img/final-project/G-bond-length.png]]
  :END:

***** DONE Barrier energy
      CLOSED: [2016-06-09 Thu 22:20]

  #+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

import twodee as td


fp_dir = '~/techela/s16-06640/final-project/' # Directory of final project.

# Distance of the molecule normal to the graphene plane
heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]

# Calculated distance after relaxation
h_rel = []

TE_h = []
TE_co2 = []
for i, h in enumerate(heights):

    with jasp(fp_dir + 'transport/G-c-HHc-constraints-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        energy = atoms.get_potential_energy()
        TE_h.append(energy)
        bond_dist = atoms.get_distance(17,18)
        h_fixed = atoms[17].position[2]
        h_graphene = atoms[0].position[2]
        h_rel_i = h_fixed + (bond_dist / 2.) - h_graphene
        h_rel.append(h_rel_i)

    with jasp(fp_dir + 'transport/G-c-CO2-transport-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        energy = atoms.get_potential_energy()
        TE_co2.append(energy)

TE_h = np.array(TE_h)
TE_h -= min(TE_h)
TE_co2 = np.array(TE_co2)
TE_co2 -= min(TE_co2)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(x[0],x[-1],200)
    print('Max energy: {:0.3f} eV'.format(max(spline(x_lin)))) 
    plt.plot(x_lin, spline(x_lin), style)

print('Energy barriers:')
file_path = './img/final-project/total_energy-comparison.png'
plt.plot(h_rel, TE_h, 'ro', label='H2')
plt.plot(heights, TE_co2, 'go', label='CO2')
plot_spline(h_rel, TE_h, plt, 'r-')
plot_spline(heights, TE_co2, plt, 'g-')
plt.xlabel('Molecule distance from graphene plane ($\AA$)')
plt.ylabel('$\Delta$ Energy (eV)')
plt.xlim([-3.,3.])
plt.ylim([0,5.5])
plt.legend(loc='upper center')
plt.savefig(file_path)
print('[[' + file_path + ']]')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  Energy barriers:
  Max energy: 1.879 eV
  Max energy: 4.643 eV
  [[./img/final-project/total_energy-comparison.png]]
  :END:

  Barrier peaks could mean clustering around the pores.

**** TODO Transport. Pore=1
  #+BEGIN_SRC python
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Transport initial images. Distance of molecule's center from grahene plane
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]

def calculate(name, TE):
    for i, h in enumerate(heights):
        with jasp('./dft/' + name + '/d={0:0.2f}'.format(h)) as calc:
            calc.calculate()
            atoms = calc.get_atoms()
            energy = atoms.get_potential_energy()
            TE.append(energy)


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/'

name_free = base_name + 'linear-unconst_all'
TE_free = []
calculate(name_free, TE_free)

#name_uncon = base_name + 'linear-unconst_G'
#TE_uncon = []
#calculate(name_uncon, TE_uncon)

name_con = base_name + 'linear-const'
TE_con = []
calculate(name_con, TE_con)

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
#TE_uncon = np.array(TE_uncon)
#TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(0,10,1000)
    plt.plot(x_lin, spline(x_lin), style)


print('')
print('Normal view')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.figure(1)
plt.plot(heights, TE_free, 'ro', label='No constraints')
#plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')

print('')
print('Lennard-Jones potential well and convergence view')
file_path = './img/' + base_name + 'TE-comparison-LJ_zoom.png'
plt.figure(2)
plt.plot(heights, TE_free, 'ro', label='No constraints')
#plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
#plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,8])
plt.ylim([-0.15,0.2])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
  #+END_SRC

  #+RESULTS:

**** DONE Vacuum distance convergence
     CLOSED: [2016-06-08 Wed 15:59]
  Look at the distance the molecule away from the graphene plane is to know when it appears to be a free molecule in space and does not exhibit changes in energy due to interaction.

  #+BEGIN_SRC python :results drawer
import numpy as np
import matplotlib.pyplot as plt

from ase import Atom, Atoms
from jasp import *

import twodee as td

def closest_atom_distance(atoms):
    pos = atoms.get_positions()
    dist = (pos[17] - pos[0])[2] # leading atom was always #17 in these calculations
    return dist


def calculate(molec, dist, TE, heights):
    for h in heights:
        with jasp('./dft/transport/g-mono/3x3/pore=1/molec=' + molec + '/linear-const-const/d={0:0.2f}'.format(h)) as calc:
	    calc.calculate()
	    atoms = calc.get_atoms()
	    dist.append(closest_atom_distance(atoms))
	    energy = atoms.get_potential_energy()
	    TE.append(energy)


dists = [[] for i in range(3)]
TEs = [[] for i in range(3)]
molecs = ['H2', 'N2', 'CO2']
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]
for i, (molec, dist, TE) in enumerate(zip(molecs, dists, TEs)):
    calculate(molec, dist, TE, heights)
    TE = np.array(TE)
    TE -= min(TE)
    TEs[i] = TE


for dist, TE in zip(dists, TEs):
    plt.plot(dist, TE)
plt.xlabel('Closest atom distance from graphene plane ($\AA$)')
plt.ylabel('$\Delta$ Energy (eV)')
plt.xlim([0,8])
plt.ylim([-0.5,2])
plt.legend(molecs)

path = 'results/convergence-vaccuum-pore=1.png'
caption = "Vaccuum distance convergence. Height represents distance between the molecule\'s closest atom and the graphene plane."
name = "vaccuum-molecule-distance"
td.print_image(path, plt, name, caption)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  #+CAPTION: Vaccuum distance convergence. Height represents distance between the molecule's closest atom and the graphene plane.
  #+NAME: fig:vaccuum-molecule-distance
  [[./img/results/convergence-vaccuum-pore=1.png]]
  :END:

  cite:sun-2014-mechan-molec reports between 5-6 Å is the distance of non-interaction for these molecules. They used classical MD with LJ potentials.

  It appears that when the leading atom is 4 Å away from the graphene plane, there is no interaction. Since most molecules that we'll be testing are about 2-4 Å in length, it seems reasonable to make the z-direction vaccuum space of the calculations to be 9 Å on either side of the graphene plane. 

  This probably the lowest case, as all atoms are constrained and the pore is not functionalized. The carbon atoms in graphene around a pore are not directly inline with the graphene plane.

**** DONE Height of carbon atoms around an unfunctionalized graphene pore
     CLOSED: [2016-06-09 Thu 11:16]
  Show that the carbon atoms around an unfunctionalized graphene pore do not change in height from the rest of the graphene plane.

***** DONE Monolayer graphene 5x5 pore=10
      CLOSED: [2016-06-09 Thu 11:17]
  Show that at a pore, carbon atoms are not directly in line with the bulk graphene plane.

  #+BEGIN_SRC python :results drawer
import numpy as np
import matplotlib.pyplot as plt

from ase import Atoms, Atom
from ase.io import write as ase_write
from jasp import *

import twodee as td

name = "dft/material/g-mono/5x5/pore=10/final"
with jasp(name) as calc:
    atoms = calc.get_atoms()


td.print_image("results/carbon-5x5-around-pore-vertical", atoms)
atoms2 = atoms.copy()
atoms2.rotate('x', np.pi/2)
td.print_image("results/carbon-5x5-around-pore-side", atoms2)

heights = []
dists = []
defect = [5.681, 0., 4.]
center = atoms.cell[2][2] / 2.
for i, a in enumerate(atoms):
    dist_defect = np.linalg.norm(a.position - defect)
    dists.append(dist_defect)
    heights.append(a.position[2] - center)

plt.plot(dists, heights)
file_path = './img/results/carbon-5x5-around-pore-plot.png'
plt.xlabel('Distance from pore ($\AA$)')
plt.ylabel('Distance from plane center ($\AA$)')
plt.savefig(file_path)
print('[[' + file_path + ']]')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  [[./img/results/carbon-5x5-around-pore-vertical.png]]
  [[./img/results/carbon-5x5-around-pore-side.png]]
  [[./img/results/carbon-5x5-around-pore-plot.png]]
  :END:

***** DONE Monolayer graphene 3x3 pore=1
      CLOSED: [2016-06-09 Thu 11:17]
  Show that at a pore, carbon atoms are not directly in line with the bulk graphene plane.

  #+BEGIN_SRC python :results drawer
import numpy as np
import matplotlib.pyplot as plt

from ase import Atoms, Atom
from ase.io import write as ase_write
from jasp import *

import twodee as td

name = "dft/material/g-mono/3x3/pore=1/final"
with jasp(name) as calc:
    atoms = calc.get_atoms()


td.print_image("results/carbon-3x3-around-pore-vertical", atoms)
atoms2 = atoms.copy()
atoms2.rotate('x', np.pi/2)
td.print_image("results/carbon-3x3-around-pore-side", atoms2)

heights = []
dists = []
defect = [5.681, 0., 4.]
center = atoms.cell[2][2] / 2.
for i, a in enumerate(atoms):
    dist_defect = np.linalg.norm(a.position - defect)
    dists.append(dist_defect)
    heights.append(a.position[2] - center)

plt.plot(dists, heights)
file_path = './img/results/carbon-3x3-around-pore-plot.png'
plt.xlabel('Distance from pore ($\AA$)')
plt.ylabel('Distance from plane center ($\AA$)')
plt.savefig(file_path)
print('[[' + file_path + ']]')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  [[./img/results/carbon-3x3-around-pore-vertical.png]]
  [[./img/results/carbon-3x3-around-pore-side.png]]
  matplotlib.pyplot
  :END:

**** TODO Height of carbon atoms around a functionalized graphene pore
**** Monolayer graphene pore distance convergence
  Show that as the graphene layers get larger, the negative effect of the pore on the total energy decreases.

  #+BEGIN_SRC python :results drawer
import matplotlib.pyplot as plt
import numpy as np

from ase import Atom, Atoms
from jasp import *

import twodee as td


sizes = [2, 3, 4, 5, 6]
kpts =  [5, 5, 5, 1, 1]

energies = []
dists = []
times = []
images = []
for i, k in zip(sizes, kpts):
    name = 'dft/material/g-mono/{0:0.0f}x{0:0.0f}/pore=1/convergence/size/kpts={1:0.0f}'.format(i, k)

    with jasp(name) as calc:
        atoms = calc.get_atoms()
        energy = atoms.get_potential_energy()/len(atoms)
        time = float(get_elapsed_time(calc)) / 60 # minutes

    energies.append(energy)
    dists.append(np.linalg.norm(atoms.cell[0]))
    times.append(time)
    images.append(atoms)

# Pristine comparison
with jasp("dft/material/g-mono/final") as calc:
    atoms = calc.get_atoms()
    energy = atoms.get_potential_energy()/len(atoms)
px = np.linspace(dists[0], dists[-1])
py = [energy for i in px]


path = 'results/monolayer-energy_vs_pore_distance'

ax1 = plt.gca()
ax1.plot(px, py, 'g--', label="Pristine graphene")
ax1.plot(dists, energies, 'go', label="Pore=1")
spline = td.spline(dists, energies)
ax1.plot(spline[0], spline[1], 'g-')

ax2 = plt.gca().twinx()
ax2.plot(dists, times, 'ro', label="Pore=1")
spline = td.spline(dists, times)
ax2.plot(spline[0], spline[1], 'r-')

ax1.set_xlabel("Distance between pore centers ($\AA$)")
ax1.set_ylabel("Energy per atom (eV/f.u.)", color='g')
ax2.set_ylabel("Calculation time (min)", color='r')
plt.xlim(dists[0],dists[-1])
ax1.legend(loc='upper left')
ax2.legend(loc='upper right')

caption = "The effect of distance between pores on energy and calculation time."
name = "g-mono-energy_vs_pore_distance"
td.print_image(path + '.png', plt, name, caption)

for i, [s, d] in enumerate(zip(sizes, dists)):
    print("Distance = {0}. Structure = {1}x{1}".format(d, s))
    if s in [2, 3]:
        r = 3
    else:
        r = 2
    td.print_image(path + '-pore=1-size={}'.format(s), images[i].repeat([r,r,1]))


# Pore=10 comparison
p10dists = [dists[sizes.index(4)], dists[sizes.index(5)], dists[sizes.index(6)]]
p10energies = [-8.128, -8.604, -8.850]
p10times = [96, 966, 2929]
p10sizes = [4, 5, 6]
p10images = []

for i, [s, d] in enumerate(zip(p10sizes, p10dists)):
    with jasp('dft/material/g-mono/{0}x{0}/pore=10/final'.format(s)) as calc:
        p10images.append(calc.get_atoms())
    print("Distance = {0}. Structure = {1}x{1}".format(d, s))
    td.print_image(path + '-pore=10-size={}'.format(s), p10images[i].repeat([2,2,1]))

ax1.plot(p10dists, p10energies, 'gd-', label="Pore=10")
ax2.plot(p10dists, p10times, 'rd-', label="Pore=10")
#spline = td.spline(p10dists, p10energies)
#ax1.plot(spline[0], spline[1], 'g-')
#spline = td.spline(p10dists, p10times)
#ax2.plot(spline[0], spline[1], 'r-')
ax1.legend(loc='upper left')
ax2.legend(loc='upper right')
td.print_image(path + '-pore=10.png', plt, name, caption)
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  #+CAPTION: The effect of distance between pores on energy and calculation time.
  #+NAME: fig:g-mono-energy_vs_pore_distance
  [[./img/results/monolayer-energy_vs_pore_distance.png]]
  Distance = 4.92. Structure = 2x2
  [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=2.png]]
  Distance = 7.38. Structure = 3x3
  [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=3.png]]
  Distance = 9.84. Structure = 4x4
  [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=4.png]]
  Distance = 12.3. Structure = 5x5
  [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=5.png]]
  Distance = 14.76. Structure = 6x6
  [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=6.png]]
  Distance = 9.84. Structure = 4x4
  [[./img/results/monolayer-energy_vs_pore_distance-pore=10-size=4.png]]
  Distance = 12.3. Structure = 5x5
  [[./img/results/monolayer-energy_vs_pore_distance-pore=10-size=5.png]]
  Distance = 14.76. Structure = 6x6
  [[./img/results/monolayer-energy_vs_pore_distance-pore=10-size=6.png]]
  #+CAPTION: The effect of distance between pores on energy and calculation time.
  #+NAME: fig:g-mono-energy_vs_pore_distance
  [[./img/results/monolayer-energy_vs_pore_distance-pore=10.png]]
  :END:

  Approaches the pristine limit but calculation time goes way up. This is also one of the best case scenarios - a single missing carbon atom. As the ammount of carbon atoms removed increases, the energy goes up.

**** TODO Charge density view of monolayer graphene pore=10

  Show what the charge density looks like around a pore.

  #+BEGIN_SRC python
from ase.data import vdw_radii
from ase.data.colors import cpk_colors
from enthought.mayavi import mlab
from jasp import *

import twodee as td


with jasp('dft/material/g-mono/5x5/pore=10/final') as calc:
    atoms = calc.get_atoms()
    x, y, z, cd = calc.get_charge_density()

mlab.contour3d(x,y,z,cd)

td.bp()
mlab.figure(bgcolor=(1, 1, 1))

# plot the atoms as spheres
for atom in atoms:
    mlab.points3d(atom.x,
                  atom.y,
                  atom.z,
                  scale_factor=vdw_radii[atom.number]/5,
                  resolution=20,
                  # a tuple is required for the color
                  color=tuple(cpk_colors[atom.number]),
                  scale_mode='none')

# draw the unit cell - there are 8 corners, and 12 connections
a1, a2, a3 = atoms.get_cell()
origin = [0, 0, 0]
cell_matrix = [[origin,  a1],
               [origin,  a2],
               [origin,  a3],
               [a1,      a1 + a2],
               [a1,      a1 + a3],
               [a2,      a2 + a1],
               [a2,      a2 + a3],
               [a3,      a1 + a3],
               [a3,      a2 + a3],
               [a1 + a2, a1 + a2 + a3],
               [a2 + a3, a1 + a2 + a3],
               [a1 + a3, a1 + a3 + a2]]

for p1, p2 in cell_matrix:
    mlab.plot3d([p1[0], p2[0]], # x-positions
                [p1[1], p2[1]], # y-positions
                [p1[2], p2[2]], # z-positions
                tube_radius=0.02)


# Now plot the charge density
mlab.contour3d(x, y, z, cd, transparent=True)

# this view was empirically found by iteration
mlab.view(azimuth=-90, elevation=90, distance='auto')

file_path = 'tmp/test_charge.png'
mlab.savefig(file_path)
#mlab.show()
print('[[' + file_path + ']]')
  #+END_SRC

  #+RESULTS:
  :RESULTS:
  :END:
  


