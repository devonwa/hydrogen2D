#+title: MS Research Project
#+author: Devon Walker
#+email: devonw@andrew.cmu.edu

* Journal
** 2016-05-19 Thu
- cite:zan-2012-graph-reknit Graphene Reknits Its Holes - Zan (Novoselov)

Competing possible research avenues:
1. Repairing graphene
2. Stacked-graphene aperture effect
  2.1. Neural network?

** 2016-05-20 Fri
- cite:drahushuk-2012-mechan-gas Mechanisms of Gas Permeation through Single Layer Graphene Membranes - Drahushuk (Strano)

** 2016-05-23 Mon
- cite:du-2011-separ-hydrog Separation of Hydrogen and Nitrogen Gases With  Porous Graphene Membrane - Du (Zhao)

** 2016-05-24 Tue
- cite:koenig-2012-selec-molec Selective Molecular Sieving Through Porous Graphene - Keonig (Bunch)

- cite:wang-2015-molec-valves Molecular valves for controlling gas phase transport made from discrete ångström-sized pores in graphene - Wang, Drahushuk (Strano)

** 2016-05-25 Wed

Simulators meeting
- Jake presented neural network vs reaxff with Au

* Snippets
** 2016-03-07: Remote copying
*Note 2016-05-18* - Copying is better done by maintaining the git repo. 

To Gilgamesh:
#+BEGIN_SRC sh
scp ~/Google_Drive/projects/hydrogen2D/hydrogen2D.org devonw@gilgamesh.cheme.cmu.edu:projects/hydrogen2D
#+END_SRC

To host:
#+BEGIN_SRC sh
scp devonw@gilgamesh.cheme.cmu.edu:projects/hydrogen2D/hydrogen2D.org ~/Google_Drive/projects/hydrogen2D
#+END_SRC

To update buffer
#+BEGIN_SRC 
M-x revert-buffer
#+END_SRC

** 2016-05-10: Tramp remote execution
This is a way to run code on a remote server while maintaining the code locally. It works for basic things that have text output. It doesn't work for things like ASE's view, which spawns a gui, and I haven't tried it for running vasp codes (not sure how directories would work out exactly -> may need to use absolute paths).

Check tramp works
#+begin_src sh :dir /devonw@gilgamesh.cheme.cmu.edu: :results output
echo "Executed by `whoami` on `hostname` in `pwd`"
#+end_srC

#+RESULTS:
: Executed by devonw on gilgamesh.cheme.cmu.edu in /home-guest/devonw

Test what $PATH is defined as. May need to copy the remote's path to the tramp path (Don't know why they'd want this to be different except for speed(?)).
#+begin_src sh :dir /ssh:devonw@gilgamesh.cheme.cmu.edu: :results output
#source ~/.bash_profile
#echo $PATH
#source .bash_profile
echo $PATH
#+end_src

#+RESULTS:
: /opt/kitchingroup/vasp-5.3.5/vtstscripts-914:/home-research/jkitchin/bin:/opt/vtk/bin:/opt/kitchingroup/vasp-5.3.5/ase-s16/tools:/opt/kitchingroup/vasp-5.3.5/jasp-s16/jasp/bin:/opt/kitchingroup/vasp-5.3.5/bin:/usr/mpi/intel/openmpi-1.4-qlc/bin:/opt/kitchingroup/CANOPY/Canopy_64bit/User/bin:/opt/maui/bin:/opt/fav/bin:/usr/local/texlive/2012/bin/x86_64-linux:/opt/intel/Compiler/11.1/072/bin/intel64:/opt/intel/impi/4.0.0.028/intel64/bin:/usr/lib64/qt-3.3/bin:/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/usr/share/pvm3/lib:/sbin:/usr/sbin:/usr/local/sbin

Modules are used to load in python code (?). Weird that this doesn't print what it does in shell.
#+begin_src sh :dir /devonw@gilgamesh.cheme.cmu.edu: :results output
source ~/.bash_profile
module list
#+end_src

#+RESULTS:

Test remote execution of a python file. The import statements working is the important part.
#+BEGIN_SRC python :results output :dir /devonw@gilgamesh.cheme.cmu.edu:
import os
from ase import Atoms
import numpy as np
from jasp import *
a = 5
print(a)
#+END_SRC

#+RESULTS:
: 5

Local python test. Unless you've installed ase and jasp locally, this shouln't work but the previous block should have.
#+BEGIN_SRC python :results output
import numpy as np
from ase import Atoms
from jasp import *
a = 5
print(a)
#+END_SRC

#+RESULTS:

** 2016-05-23: Test vasp is working on the server

#+BEGIN_SRC python
import numpy as np
np.set_printoptions(precision=3, suppress=True)

from ase import Atoms, Atom
from ase.structure import molecule
from ase.io import write as ase_write
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'

atoms = molecule('C2H6')

ENCUTS = [300, 350, 400]
energies_en = []
forces_en = []
ready = True
for en in ENCUTS:
    job_name = '~/tmp/vasp_test/molecules/c2h6-en-{0}'.format(en)
    with jasp(job_name,
              encut=en,
              xc='PBE',
              atoms=atoms) as calc:
        try:
            energies_en.append(atoms.get_potential_energy())
            forces_en.append(atoms.get_forces())
        except (VaspSubmitted, VaspQueued):
            ready = False
            print("Still processing: {}".format(job_name))


cells = [0.5, 3, 6]
energies_L = []
forces_L = []
for c in cells:
    atoms.center(vacuum=c)
    job_name = '~/tmp/vasp_test/molecules/c2h6-L-{0}'.format(c)
    with jasp(job_name,
              encut=400,
              xc='PBE',
              atoms=atoms) as calc:
        try:
            energies_L.append(atoms.get_potential_energy())
            forces_L.append(atoms.get_forces())
        except (VaspSubmitted, VaspQueued):
            ready = False
            print("Still processing: {}".format(job_name))

if not ready:
    import sys; sys.exit()

print("1.")
print("{0:5s}    {1:7s}    {2:9s}".format("ENCUT", "Energy", "Max force"))
print("{0:5s}    {1:7s}    {2:9s}".format("", "[eV]", "[eV/Ang]"))
print("-----------------------------")
for i, energy, force in zip(ENCUTS, energies_en, forces_en):
    print("{0:5d}    {1:7.3f}    {2:9.3f}".format(i, energy, force.max()))

print("\n2.")
print("{0:11s}    {1:7s}    {2:9s}".format("Cell vacuum", "Energy", "Max force"))
print("{0:11s}    {1:7s}    {2:9s}".format("", "[eV]", "[eV/Ang]"))
print("-----------------------------------")
for i, energy, force in zip(cells, energies_L, forces_L):
    print("{0:11.1f}    {1:7.3f}    {2:9.3f}".format(i, energy, force.max()))
#+END_SRC

#+RESULTS:

** TODO Better movies
- What is the best format for this?
** 2016-05-31: View atoms
#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
    
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]

def view_atoms(name):
    images = []
    for i, h in enumerate(heights):
	with jasp('./dft/' + name + '/d={0:0.2f}'.format(h)) as calc:
	    atoms = calc.get_atoms()
	    images.append(atoms)
    view(images)

base_name = 'transport/g-mono/3x3/pore=1/molec=CO2/'

name_free = base_name + 'linear-unconst_all'
#view_atoms(name_free)

name_uncon = base_name + 'linear-unconst_G'
#view_atoms(name_uncon)

name_con = base_name + 'linear-const'
view_atoms(name_con)
#+END_SRC

#+RESULTS:

* DFT
** Parameters
- Vaccuum space between gas and 

** Material
*** Graphene monolayer
**** Pristine

#+BEGIN_SRC python :results output
from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

name = 'material/g-mono'

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
: Final structure calculation: In progress.
: [[./img/material/g-mono.png]]

**** Pore=1 (One carbon defect)
***** Final project

#+BEGIN_SRC python :results output
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys
JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 3
atoms = unitcell.repeat((i,i,1))

print('Graphene 3x3 pore=1:'.format(i))

del atoms[0]

name = 'material/g-mono/3x3/pore=1/vac=10-nsw=50'

with jasp('./dft/' + name,
            encut=450,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
: Graphene 3x3 pore=1:
: Final structure calculation: Atoms: 17. Energy/f.u. = -8.762. Calculation time: 192 min.
: [[./img/material/g-mono/3x3/pore=1/vac=10-nsw=50.png]]

***** Standard spacing

#+BEGIN_SRC python :results output
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys
#JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 3
atoms = unitcell.repeat((i,i,1))

print('Graphene 3x3 pore=1:'.format(i))

del atoms[0]

name = 'material/g-mono/3x3/pore=1/vac=10'

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
: Graphene 3x3 pore=1:
: Final structure calculation: Atoms: 17. Energy/f.u. = -8.759. Calculation time: 188 min.
: [[./img/material/g-mono/3x3/pore=1/vac=10.png]]

***** Wide vaccuum

#+BEGIN_SRC python :results output
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 20.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 3
atoms = unitcell.repeat((i,i,1))

print('Graphene 3x3 pore=1:'.format(i))

del atoms[0]

name = 'material/g-mono/3x3/pore=1/vac=20'
file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=100,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass
#+END_SRC

#+RESULTS:
: Graphene 3x3 pore=1:
: [[./img/material/g-mono/3x3/pore=1/vac=20.png]]
: Final structure calculation: Atoms: 17. Energy/f.u. = -8.760. Calculation time: 589 min.

**** Pore=10 (Ten carbon defect)
***** 4x4
#+BEGIN_SRC python :results output
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys
#JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 20.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 4
atoms = unitcell.repeat((i,i,1))

print('Graphene 4x4 pore=10:'.format(i))
del atoms[26]
del atoms[17:21]
del atoms[11:15]
del atoms[5]

name = 'material/g-mono/4x4/pore=10/vac=16'

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms.repeat((3,3,1)))
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
: Graphene 4x4 pore=10:
: Final structure calculation: Atoms: 22. Energy/f.u. = -8.167. Calculation time: 1933 min.
: [[./img/material/g-mono/4x4/pore=10/vac=16.png]]

***** 5x5
#+BEGIN_SRC python :results output
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys
#JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 20.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 5
atoms = unitcell.repeat((i,i,1))

print('Graphene 5x5 pore=10:'.format(i))
del atoms[32:35]
del atoms[23:27]
del atoms[15:18]

name = 'material/g-mono/5x5/pore=10/vac=16'

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms.repeat((3,3,1)))
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
: Graphene 5x5 pore=10:
: Final structure calculation: In progress.
: [[./img/material/g-mono/5x5/pore=10/vac=16.png]]

***** 6x6
#+BEGIN_SRC python :results output
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys
#JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")

cell_height = 16.
a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., cell_height])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 6
atoms = unitcell.repeat((i,i,1))

print('Graphene {0:1.1f}x{0:1.1f} pore=10:'.format(i))
del atoms[52]
del atoms[39:43]
del atoms[29:33]
del atoms[19]


name = 'material/g-mono/6x6/pore=10/vac=16'

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms.repeat((3,3,1)))
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
: Graphene 6.0x6.0 pore=10:
: Final structure calculation: In progress.
: [[./img/material/g-mono/6x6/pore=10/vac=16.png]]

*** Graphene bilayer

**** Pristine
Structure obtained from https://www.tfkp.physik.uni-erlangen.de/download/theses/master_daniel-branski.pdf.

#+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

name = 'material/g-bi'

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Final structure calculation: In progress.
[[./img/material/g-bi.png]]
:END:

**** Pore=1

#+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

i = 3
atoms = atoms.repeat([i,i,1])
del atoms[17:19]

name = 'material/g-bi/3x3/pore=1'
view(atoms)
with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

**** Pore=10

#+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

i = 6
atoms = atoms.repeat([i,i,1])
# layer 1 pore
del atoms[108]
del atoms[104]
del atoms[84:86]
del atoms[80:82]
del atoms[60:62]
del atoms[56:58]

# layer 2 pore
del atoms[75:79]
del atoms[55:60]
del atoms[35]
name = 'material/g-bi/6x6/pore=10'
view(atoms)
sys.exit()
with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:


*** Graphene trilayer

** Transport
*** Graphene monolayer
**** 3x3 pore=1 - linear
***** H2

#+BEGIN_SRC python
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('dft/material/g-mono/3x3/pore=1/vac=20') as calc:
    graphene = calc.get_atoms()
plane_height = 10.
defect_pos = np.array([0, 0., plane_height]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
HH_bond = 0.74 # Bond length [Ang]
for i, h in enumerate(heights):
    H2 = Atoms([Atom('H', defect_pos + (0, 0, h - HH_bond/2.)),
                Atom('H', defect_pos + (0, 0, h + HH_bond/2.))])
    atoms[i].extend(H2)


# Hydrogen fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'H':
        hydrogen_constraint = [FixAtoms(indices=[atom.index])]
        break

# Graphene constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Make images with constraints
atoms_free = copy.deepcopy(atoms)

atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(hydrogen_constraint)

atoms_con = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_con[i].set_constraint(hydrogen_constraint + graphene_constraint)

ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./dft/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/'

print('Unconstrained graphene, unconstrained hydrogen:')
name_free = base_name + 'linear-unconst_all'
TE_free = []
calculate(name_free, atoms_free, TE_free)

print('')
print('Unconstrained graphene, constrained leading hydrogen:')
name_uncon = base_name + 'linear-unconst_G'
TE_uncon = []
calculate(name_uncon, atoms_uncon, TE_uncon)

print('')
print('Constrained graphene, constrained leading hydrogen:')
name_con = base_name + 'linear-const'
TE_con = []
calculate(name_con, atoms_con, TE_con)

if not ready:
    sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
TE_uncon = np.array(TE_uncon)
TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(0,10,1000)
    plt.plot(x_lin, spline(x_lin), style)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
h_lin = np.linspace(0,10,1000)
spline_free = interp1d(heights, TE_free, kind='cubic')
plt.plot(heights, TE_free, 'ro', label='No constraints')
plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
#+begin_example
Unconstrained graphene, unconstrained hydrogen:
Distance: 10.00. Energy = -155.683. Calculation time: 199 min.
Distance:  9.00. Energy = -155.683. Calculation time: 628 min.
Distance:  8.00. Energy = -155.683. Calculation time: 105 min.
Distance:  7.00. Energy = -155.684. Calculation time: 103 min.
Distance:  6.00. Energy = -155.684. Calculation time: 105 min.
Distance:  5.00. Energy = -155.687. Calculation time: 106 min.
Distance:  4.00. Energy = -155.695. Calculation time: 350 min.
Distance:  3.00. Energy = -155.690. Calculation time: 356 min.
Distance:  2.50. Energy = -155.637. Calculation time: 798 min.
Distance:  2.00. Energy = -155.677. Calculation time: 1715 min.
Distance:  1.50. Energy = -155.677. Calculation time: 2157 min.
Distance:  1.00. Energy = -155.238. Calculation time: 2113 min.
Distance:  0.50. Energy = -155.239. Calculation time: 1454 min.
Distance:  0.00. Energy = -155.239. Calculation time: 888 min.

Unconstrained graphene, constrained leading hydrogen:
Distance: 10.00. Energy = -155.683. Calculation time: 355 min.
Distance:  9.00. Energy = -155.683. Calculation time: 374 min.
Distance:  8.00. Energy = -155.683. Calculation time: 169 min.
Distance:  7.00. Energy = -155.683. Calculation time: 168 min.
Distance:  6.00. Energy = -155.684. Calculation time: 169 min.
Distance:  5.00. Energy = -155.686. Calculation time: 170 min.
Distance:  4.00. Energy = -155.694. Calculation time: 169 min.
Distance:  3.00. Energy = -155.690. Calculation time: 169 min.
Distance:  2.50. Energy = -155.613. Calculation time: 210 min.
Distance:  2.00. Energy = -155.674. Calculation time: 1248 min.
Distance:  1.50. Energy = -155.605. Calculation time: 2107 min.
Distance:  1.00. Energy = -153.879. Calculation time: 411 min.
Distance:  0.50. Energy = -155.118. Calculation time:  82 min.
Distance:  0.00. Energy = -155.238. Calculation time: 1181 min.

Constrained graphene, constrained leading hydrogen:
Distance: 10.00. Energy = -155.683. Calculation time: 157 min.
Distance:  9.00. Energy = -155.683. Calculation time: 157 min.
Distance:  8.00. Energy = -155.683. Calculation time: 165 min.
Distance:  7.00. Energy = -155.684. Calculation time: 156 min.
Distance:  6.00. Energy = -155.684. Calculation time: 361 min.
Distance:  5.00. Energy = -155.687. Calculation time: 352 min.
Distance:  4.00. Energy = -155.695. Calculation time: 362 min.
Distance:  3.00. Energy = -155.690. Calculation time: 363 min.
Distance:  2.50. Energy = -155.611. Calculation time: 370 min.
Distance:  2.00. Energy = -155.283. Calculation time: 349 min.
Distance:  1.50. Energy = -154.461. Calculation time: 377 min.
Distance:  1.00. Energy = -153.815. Calculation time: 298 min.
Distance:  0.50. Energy = -154.247. Calculation time: 316 min.
Distance:  0.00. Energy = -154.990. Calculation time: 232 min.

[[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison.png]]
#+end_example

***** H2 (NEB)

#+BEGIN_SRC python
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.neb import NEB
from ase.visualize import view
from jasp import *

def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('dft/material/g-mono/3x3/pore=1/vac=20') as calc:
    graphene = calc.get_atoms()
plane_height = 10.
defect_pos = np.array([0, 0., plane_height]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
HH_bond = 0.74 # Bond length [Ang]
for i, h in enumerate(heights):
    H2 = Atoms([Atom('H', defect_pos + (0, 0, h - HH_bond/2.)),
                Atom('H', defect_pos + (0, 0, h + HH_bond/2.))])
    atoms[i].extend(H2)


# Hydrogen fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'H':
        hydrogen_constraint = [FixAtoms(indices=[atom.index])]
        break

# Graphene constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Make images with constraints
atoms_free = copy.deepcopy(atoms)


ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./dft/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/'


name_free = base_name + 'linear-unconst_all'
TE_free = []
calculate(name_free, atoms_free, TE_free)


if not ready:
    sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
TE_uncon = np.array(TE_uncon)
TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(0,10,1000)
    plt.plot(x_lin, spline(x_lin), style)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
h_lin = np.linspace(0,10,1000)
spline_free = interp1d(heights, TE_free, kind='cubic')
plt.plot(heights, TE_free, 'ro', label='No constraints')
plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
#+begin_example
Unconstrained graphene, unconstrained hydrogen:
Distance: 10.00. Energy = -155.683. Calculation time: 199 min.
Distance:  9.00. Energy = -155.683. Calculation time: 628 min.
Distance:  8.00. Energy = -155.683. Calculation time: 105 min.
Distance:  7.00. Energy = -155.684. Calculation time: 103 min.
Distance:  6.00. Energy = -155.684. Calculation time: 105 min.
Distance:  5.00. Energy = -155.687. Calculation time: 106 min.
Distance:  4.00. Energy = -155.695. Calculation time: 350 min.
Distance:  3.00. Energy = -155.690. Calculation time: 356 min.
Distance:  2.50. Energy = -155.637. Calculation time: 798 min.
Distance:  2.00. Energy = -155.677. Calculation time: 1715 min.
Distance:  1.50. Energy = -155.677. Calculation time: 2157 min.
Distance:  1.00. Energy = -155.238. Calculation time: 2113 min.
Distance:  0.50. Energy = -155.239. Calculation time: 1454 min.
Distance:  0.00. Energy = -155.239. Calculation time: 888 min.

Unconstrained graphene, constrained leading hydrogen:
Distance: 10.00. Energy = -155.683. Calculation time: 355 min.
Distance:  9.00. Energy = -155.683. Calculation time: 374 min.
Distance:  8.00. Energy = -155.683. Calculation time: 169 min.
Distance:  7.00. Energy = -155.683. Calculation time: 168 min.
Distance:  6.00. Energy = -155.684. Calculation time: 169 min.
Distance:  5.00. Energy = -155.686. Calculation time: 170 min.
Distance:  4.00. Energy = -155.694. Calculation time: 169 min.
Distance:  3.00. Energy = -155.690. Calculation time: 169 min.
Distance:  2.50. Energy = -155.613. Calculation time: 210 min.
Distance:  2.00. Energy = -155.674. Calculation time: 1248 min.
Distance:  1.50. Energy = -155.605. Calculation time: 2107 min.
Distance:  1.00. Energy = -153.879. Calculation time: 411 min.
Distance:  0.50. Energy = -155.118. Calculation time:  82 min.
Distance:  0.00. Energy = -155.238. Calculation time: 1181 min.

Constrained graphene, constrained leading hydrogen:
Distance: 10.00. Energy = -155.683. Calculation time: 157 min.
Distance:  9.00. Energy = -155.683. Calculation time: 157 min.
Distance:  8.00. Energy = -155.683. Calculation time: 165 min.
Distance:  7.00. Energy = -155.684. Calculation time: 156 min.
Distance:  6.00. Energy = -155.684. Calculation time: 361 min.
Distance:  5.00. Energy = -155.687. Calculation time: 352 min.
Distance:  4.00. Energy = -155.695. Calculation time: 362 min.
Distance:  3.00. Energy = -155.690. Calculation time: 363 min.
Distance:  2.50. Energy = -155.611. Calculation time: 370 min.
Distance:  2.00. Energy = -155.283. Calculation time: 349 min.
Distance:  1.50. Energy = -154.461. Calculation time: 377 min.
Distance:  1.00. Energy = -153.815. Calculation time: 298 min.
Distance:  0.50. Energy = -154.247. Calculation time: 316 min.
Distance:  0.00. Energy = -154.990. Calculation time: 232 min.

[[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison.png]]
#+end_example
      
***** N2

#+BEGIN_SRC python
import copy
import numpy as np
import matplotlib.pyplot as plt
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('dft/material/g-mono/3x3/pore=1/vac=20') as calc:
    graphene = calc.get_atoms()
plane_height = 10.
defect_pos = np.array([0, 0., plane_height]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
bond1 = 1.13 # Bond length [Ang]
for i, h in enumerate(heights):
    N2 = Atoms([Atom('N', defect_pos + (0, 0, h - bond1/2.)),
                Atom('N', defect_pos + (0, 0, h + bond1/2.))])
    atoms[i].extend(N2)


# Fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'N':
        molecule_constraint = [FixAtoms(indices=[atom.index])]
        break

# Graphene constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Make images with constraints
atoms_free = copy.deepcopy(atoms)

atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(molecule_constraint)

atoms_con = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_con[i].set_constraint(molecule_constraint + graphene_constraint)

ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./dft/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=N2/'

#print('Unconstrained graphene, unconstrained hydrogen:')
#name_free = base_name + 'linear-unconst_all'
#TE_free = []
#calculate(name_free, atoms_free, TE_free)
#
#print('')
#print('Unconstrained graphene, constrained leading hydrogen:')
#name_uncon = base_name + 'linear-unconst_G'
#TE_uncon = []
#calculate(name_uncon, atoms_uncon, TE_uncon)

print('')
print('Constrained graphene, constrained leading atom:')
name_con = base_name + 'linear-const'
TE_con = []
calculate(name_con, atoms_con, TE_con)

if not ready:
    sys.exit()
sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
TE_uncon = np.array(TE_uncon)
TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.plot(heights, TE_free, label='No constraints')
plt.plot(heights, TE_uncon, label='Leading H atom constrained')
plt.plot(heights, TE_con, label='All constrained')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
#+begin_example

Constrained graphene, constrained leading hydrogen:
Distance: 10.00. Energy = -165.547. Calculation time: 202 min.
Distance:  9.00. Energy = -165.547. Calculation time: 194 min.
Distance:  8.00. Energy = -165.547. Calculation time: 203 min.
Distance:  7.00. Energy = -165.546. Calculation time: 201 min.
Distance:  6.00. Energy = -165.547. Calculation time: 202 min.
Distance:  5.00. Energy = -165.549. Calculation time: 202 min.
Distance:  4.00. Energy = -165.540. Calculation time: 199 min.
Distance:  3.00. Energy = -165.243. Calculation time: 174 min.
Distance:  2.50. Energy = -164.484. Calculation time: 154 min.
Distance:  2.00. Energy = -163.579. Calculation time: 175 min.
Distance:  1.50. Energy = -164.350. Calculation time: 303 min.
Distance:  1.00. Energy = -165.976. Calculation time: 415 min.
Distance:  0.50. Energy = -165.759. Calculation time: 313 min.
Distance:  0.00. Energy = -165.145. Calculation time: 262 min.
#+end_example

***** CO2

#+BEGIN_SRC python
import copy
import numpy as np
import matplotlib.pyplot as plt
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('dft/material/g-mono/3x3/pore=1/vac=20') as calc:
    graphene = calc.get_atoms()
plane_height = 10.
defect_pos = np.array([0, 0., plane_height]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]
CO_bond = 1.21 # Bond length [Ang]
atoms =  [Atoms(graphene) for i in range(len(heights))]
for i, h in enumerate(heights):
    CO2 = Atoms([Atom('O', defect_pos + (0., 0., h - CO_bond)),
                 Atom('C', defect_pos + (0., 0., h)),
                 Atom('O', defect_pos + (0., 0., h + CO_bond))])
    atoms[i].extend(CO2)

# Fixed position constraint
for i, atom in enumerate(atoms[0]):
    if atom.symbol == 'O':
        molecule_constraint = [FixAtoms(indices=[atom.index+1])]
        break

# Graphene constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Make images with constraints
atoms_free = copy.deepcopy(atoms)

atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(molecule_constraint)

atoms_con = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_con[i].set_constraint(molecule_constraint + graphene_constraint)


ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./dft/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=CO2/'

print('Unconstrained graphene, unconstrained molecule:')
name_free = base_name + 'linear-unconst_all'
TE_free = []
calculate(name_free, atoms_free, TE_free)

print('')
print('Unconstrained graphene, constrained CO2 carbon:')
name_uncon = base_name + 'linear-unconst_G'
TE_uncon = []
calculate(name_uncon, atoms_uncon, TE_uncon)

print('')
print('Constrained graphene, constrained CO2 carbon:')
name_con = base_name + 'linear-const'
TE_con = []
calculate(name_con, atoms_con, TE_con)

if not ready:
    sys.exit()
sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
TE_uncon = np.array(TE_uncon)
TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.plot(heights, TE_free, label='No constraints')
plt.plot(heights, TE_uncon, label='Leading H atom constrained')
plt.plot(heights, TE_con, label='All constrained')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
#+begin_example
Unconstrained graphene, unconstrained molecule:
Distance: 10.00. Energy = -171.861. Calculation time: 387 min.
Distance:  9.00. Energy = -171.861. Calculation time: 604 min.
Distance:  8.00. Energy = -171.861. Calculation time: 556 min.
Distance:  7.00. Energy = -171.861. Calculation time: 339 min.
Distance:  6.00. Energy = -171.861. Calculation time: 347 min.
Distance:  5.00. Energy = -171.863. Calculation time: 381 min.
Distance:  4.00. Energy = -171.803. Calculation time: 355 min.
Distance:  3.00. Energy = -171.800. Calculation time: 2632 min.
Distance:  2.50. Energy = -171.741. Calculation time: 4954 min.
Distance:  2.00. Energy = -171.777. Calculation time: 4830 min.
Distance:  1.50. Energy = -173.486. Calculation time: 2459 min.
Distance:  1.00. Energy = -172.259. Calculation time: 1947 min.
Distance:  0.50. Energy = -172.258. Calculation time: 2127 min.
Distance:  0.00. Energy = -170.043. Calculation time: 1282 min.

Unconstrained graphene, constrained CO2 carbon:
Distance: 10.00. Energy = -171.861. Calculation time: 265 min.
Distance:  9.00. Energy = -171.861. Calculation time: 277 min.
Distance:  8.00. Energy = -171.861. Calculation time: 291 min.
Distance:  7.00. Energy = -171.861. Calculation time: 275 min.
Distance:  6.00. Energy = -171.861. Calculation time: 267 min.
Distance:  5.00. Energy = -171.863. Calculation time: 284 min.
Distance:  4.00. Energy = -171.803. Calculation time: 273 min.
Distance:  3.00. Energy = -171.757. Calculation time: 2732 min.
Distance:  2.50. Energy = -171.796. Calculation time: 4690 min.
Distance:  2.00. Energy = -171.787. Calculation time: 4402 min.
Distance:  1.50. In progress.
Distance:  1.00. Energy = -172.244. Calculation time: 814 min.
Distance:  0.50. Energy = -172.256. Calculation time: 2039 min.
Distance:  0.00. Energy = -170.043. Calculation time: 786 min.

Constrained graphene, constrained CO2 carbon:
Distance: 10.00. Energy = -171.861. Calculation time: 300 min.
Distance:  9.00. Energy = -171.861. Calculation time: 303 min.
Distance:  8.00. Energy = -171.861. Calculation time: 325 min.
Distance:  7.00. Energy = -171.861. Calculation time: 323 min.
Distance:  6.00. Energy = -171.861. Calculation time: 313 min.
Distance:  5.00. Energy = -171.863. Calculation time: 318 min.
Distance:  4.00. Energy = -171.803. Calculation time: 215 min.
Distance:  3.00. Energy = -170.736. Calculation time: 249 min.
Distance:  2.50. Energy = -168.686. Calculation time: 247 min.
Distance:  2.00. Energy = -166.160. Calculation time: 122 min.
Distance:  1.50. Energy = -171.428. Calculation time: 432 min.
Distance:  1.00. Energy = -171.304. Calculation time: 306 min.
Distance:  0.50. Energy = -170.840. Calculation time: 504 min.
Distance:  0.00. Energy = -169.706. Calculation time: 424 min.
#+end_example

* Results
** Final project
*** Bond length

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

fp_dir = '~/techela/s16-06640/final-project/' # Directory of final project.

# Distance of the molecule normal to the graphene plane
heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]

# Calculated distance after relaxation
h_rel = []

BL_h = []
BL_co2 = [[], []]
for i, h in enumerate(heights):

    with jasp(fp_dir + 'transport/G-c-HHc-constraints-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        bond_dist = atoms.get_distance(17,18)
        BL_h.append(bond_dist)
        h_fixed = atoms[17].position[2]
        h_graphene = atoms[0].position[2]
        h_rel_i = h_fixed + (bond_dist / 2.) - h_graphene
        h_rel.append(h_rel_i)

    with jasp(fp_dir + 'transport/G-c-CO2-transport-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        BL_co2[0].append(atoms.get_distance(17,18))
        BL_co2[1].append(atoms.get_distance(18,19))


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(x[0],x[-1],200)
    plt.plot(x_lin, spline(x_lin), style)

file_path = './img/final-project/G-bond-length.png'
plt.plot(h_rel, BL_h, 'ro', label='H2')
plt.plot(heights, BL_co2[0], 'go', label='CO2 #1')
plt.plot(heights, BL_co2[1], 'bo', label='CO2 #2')
plot_spline(h_rel, BL_h, plt, 'r-')
plot_spline(heights, BL_co2[0], plt, 'g-')
plot_spline(heights, BL_co2[1], plt, 'b-')
plt.xlabel('Molecule distance from graphene plane ($\AA$)')
plt.ylabel('Bond length ($\AA$)')
plt.ylim([0.5,3])
plt.xlim([-3,3])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
: [[./img/final-project/G-bond-length.png]]

*** Barrier energy

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

fp_dir = '~/techela/s16-06640/final-project/' # Directory of final project.

# Distance of the molecule normal to the graphene plane
heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]

# Calculated distance after relaxation
h_rel = []

TE_h = []
TE_co2 = []
for i, h in enumerate(heights):

    with jasp(fp_dir + 'transport/G-c-HHc-constraints-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        energy = atoms.get_potential_energy()
        TE_h.append(energy)
        bond_dist = atoms.get_distance(17,18)
        h_fixed = atoms[17].position[2]
        h_graphene = atoms[0].position[2]
        h_rel_i = h_fixed + (bond_dist / 2.) - h_graphene
        h_rel.append(h_rel_i)

    with jasp(fp_dir + 'transport/G-c-CO2-transport-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        energy = atoms.get_potential_energy()
        TE_co2.append(energy)

TE_h = np.array(TE_h)
TE_h -= min(TE_h)
TE_co2 = np.array(TE_co2)
TE_co2 -= min(TE_co2)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(x[0],x[-1],200)
    print('Max energy: {:0.3f} eV'.format(max(spline(x_lin)))) 
    plt.plot(x_lin, spline(x_lin), style)

print('')
print('Energy barriers:')
file_path = './img/final-project/total_energy-comparison.png'
plt.plot(h_rel, TE_h, 'ro', label='H2')
plt.plot(heights, TE_co2, 'go', label='CO2')
plot_spline(h_rel, TE_h, plt, 'r-')
plot_spline(heights, TE_co2, plt, 'g-')
plt.xlabel('Molecule distance from graphene plane ($\AA$)')
plt.ylabel('$\Delta$ Energy (eV)')
plt.xlim([-3.,3.])
plt.ylim([0,5.5])
plt.legend(loc='upper center')
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
: 
: Energy barriers:
: Max energy: 1.879 eV
: Max energy: 4.643 eV
: [[./img/final-project/total_energy-comparison.png]]

** Transport. Pore=1

#+BEGIN_SRC python
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Transport initial images. Distance of molecule's center from grahene plane
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]

def calculate(name, TE):
    for i, h in enumerate(heights):
        with jasp('./dft/' + name + '/d={0:0.2f}'.format(h)) as calc:
            calc.calculate()
            atoms = calc.get_atoms()
            energy = atoms.get_potential_energy()
            TE.append(energy)


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/'

name_free = base_name + 'linear-unconst_all'
TE_free = []
calculate(name_free, TE_free)

name_uncon = base_name + 'linear-unconst_G'
TE_uncon = []
calculate(name_uncon, TE_uncon)

name_con = base_name + 'linear-const'
TE_con = []
calculate(name_con, TE_con)

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
TE_uncon = np.array(TE_uncon)
TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(0,10,1000)
    plt.plot(x_lin, spline(x_lin), style)


print('')
print('Normal view')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.figure(1)
plt.plot(heights, TE_free, 'ro', label='No constraints')
plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')

print('')
print('Lennard-Jones potential well and convergence view')
file_path = './img/' + base_name + 'TE-comparison-LJ_zoom.png'
plt.figure(2)
plt.plot(heights, TE_free, 'ro', label='No constraints')
plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,8])
plt.ylim([-0.15,0.2])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
: 
: Normal view
: [[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison.png]]
: 
: Lennard-Jones potential well and convergence view
: [[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison-LJ_zoom.png]]

** Vaccuum distance convergence
Look at the distance the molecule away from the graphene plane is to know when it appears to be a free molecule in space and does not exhibit changes in energy due to interaction.

#+BEGIN_SRC python :results drawer
import numpy as np
import matplotlib.pyplot as plt

from ase import Atom, Atoms
from ase.visualize import view
from jasp import *


def closest_atom_distance(atoms):
    pos = atoms.get_positions()
    dist = (pos[17] - pos[0])[2] # leading atom was always #17 in these calculations
    return dist


def calculate(molec, dist, TE, heights):
    for h in heights:
        with jasp('./dft/transport/g-mono/3x3/pore=1/molec=' + molec + '/linear-const/d={0:0.2f}'.format(h)) as calc:
	    calc.calculate()
	    atoms = calc.get_atoms()
	    dist.append(closest_atom_distance(atoms))
	    energy = atoms.get_potential_energy()
	    TE.append(energy)


dists = [[] for i in range(3)]
TEs = [[] for i in range(3)]
molecs = ['H2', 'N2', 'CO2']
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]
for i, (molec, dist, TE) in enumerate(zip(molecs, dists, TEs)):
    calculate(molec, dist, TE, heights)
    TE = np.array(TE)
    TE -= min(TE)
    TEs[i] = TE


file_path = './img/results/convergence-vaccuum-pore=1.png'
print('#+CAPTION: Vaccuum distance convergence. Height represents distance between closest atom and the graphene plane.')
print('#+NAME: fig:vaccuum-distance')
for dist, TE in zip(dists, TEs):
#    plt.plot(heights, TE)
    plt.plot(dist, TE)
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,8])
plt.ylim([-0.5,2])
plt.legend(molecs)
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
#+CAPTION: Vaccuum distance convergence. Height represents distance between closest atom and the graphene plane.
#+NAME: fig:vaccuum-distance
[[./img/results/convergence-vaccuum-pore=1.png]]
:END:

It appears that when the leading atom is 4 Å away from the graphene plane, there is no interaction. Since most molecules that we'll be testing are about 2-4 Å in length, it seems reasonable to make the z-direction vaccuum space of the calculations to be 9 Å on either side of the graphene plane. 

* Meetings
** DONE 2016-03-08 4pm
   CLOSED: [2016-03-09 Wed 09:26] DEADLINE: <2016-03-08 Tue 16:00>
*** Questions
quantum mechanics:
- can we adsorb molecules to the surface which impart favorable changes to the electron density around diffusion sites?

neural network:
- can we use a neural network to address properties that dft doesn't model well, such as charging the material with a potential?

org-ref:
- can you later attach a pdf?
- duplicate current bibliography into default bibliography?
- do you highlight pdfs or just type into the notes file?

*** Actions
1. Table outlining separation data

** DONE 2016-04-15 11am
   CLOSED: [2016-05-11 Wed 16:02] DEADLINE: <2016-04-15 Fri 11:00>
*** Final project suggestion
- develop a suggestion related to research
- look into what jasp is lacking

*** Neural networks
Behler-Parrinello paper from 2007
- inputs are atom positions
- questions
  - how is it not overfit with an 8200 optimizing set and 800 test set?
  - is there a way to use different inputs or generalize them? (ie. an input could be the position or presence of a functional group)

** DONE 2016-05-12 11am
*** Final project feedback
[[file:~/techela/s16-06640/final-project/final-project.org::*Transport of carbon dioxide]]

*** Correct constraints for a molecule

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.constraints import FixAtoms, Hookean
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
import sys

JASPRC['queue.walltime'] = '10:00:00'

def print_converged(i, energy, time):
#    print(i, energy, time)
    print("CO2 Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("CO2 Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("CO2 Distance: {:5.2f}. Did not converge.".format(i))


# Height of the fixed atom
heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]


# Build base images
with jasp('graphene/G-c-final') as calc:
    G_defect = calc.get_atoms()
def_pos = np.array([5.681, 0., 5.]) # defect position

# http://en.wikipedia.org/wiki/Carbon_dioxide_(data_page)
CO_bond = 1.16 # Ang. C=O bond length in CO2

atoms =  [Atoms(G_defect) for i in range(len(heights))]
for i, h in enumerate(heights):
    CO2 = Atoms([Atom('O', def_pos + (0., 0., h - CO_bond)),
                 Atom('C', def_pos + (0., 0., h)),
                 Atom('O', def_pos + (0., 0., h + CO_bond))])

    atoms[i].extend(CO2)

# Constraint - fix all carbons (including the CO2 carbon)
carbon_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Hookean constraint
# Values for constants rt [Ang] and k [eV/Ang^-2] are from https://wiki.fysik.dtu.dk/ase/ase/constraints.html for a C=O bond
for atom in atoms[0]:
    if atom.symbol == 'O':
        hook_constraint = [Hookean(a1=atom.index, a2=atom.index+1, rt=1.58, k=10.),
                           Hookean(a1=atom.index+1, a2=atom.index+2, rt=1.58, k=10.)]
        break

ready = True

# Constrained graphene, constrained carbon in CO2
print('Unconstrained graphene, constrained carbon in CO2:')

atoms_yy = [Atoms(atoms[i]) for i in range(len(heights))]
#for i in range(len(heights)):
#    atoms_yy[i].set_constraint(carbon_constraint)





with jasp('transport/G-c-CO2-transport-no-yes-d=1.00a'.format(h),
                encut=450,         # From convergence check
                kpts=(6,6,1),      # From convergence check
                xc='PBE',          # GGA functional type. Important for the defect.
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms_yy[i]) as calc:
        try:
            calc.calculate()
            energy = atoms_yy[i].get_potential_energy()
            print_converged(h, energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            print_inprogress(h)
            ready = False
            pass
sys.exit()





TE_yy = []
BO_yy = [[], []]
for i, h in enumerate(heights):
    with jasp('transport/G-c-CO2-transport-no-yes-d={0:0.2f}'.format(h),
                encut=450,         # From convergence check
                kpts=(6,6,1),      # From convergence check
                xc='PBE',          # GGA functional type. Important for the defect.
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms_yy[i]) as calc:
        try:
            calc.calculate()
            energy = atoms_yy[i].get_potential_energy()
            TE_yy.append(energy)
            BO_yy[0].append(atoms_yy[i].get_distance(17,18))
            BO_yy[1].append(atoms_yy[i].get_distance(18,19))
            print_converged(h, energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            print_inprogress(h)
            ready = False
            pass


# Constrained graphene, constrained carbon in CO2 + Hookean oxygen
print('')
print('Unconstrained graphene, constrained carbon + Hookean oxygen:')

atoms_yh = [Atoms(atoms[i]) for i in range(len(heights))]
#for i in range(len(heights)):
#    atoms_yh[i].set_constraint(carbon_constraint + hook_constraint)

TE_yh = []
BO_yh = [[], []]
for i, h in enumerate(heights):
    with jasp('transport/G-c-CO2-transport-no-hook-d={0:0.2f}'.format(h),
                encut=450,         # From convergence check
                kpts=(6,6,1),      # From convergence check
                xc='PBE',          # GGA functional type. Important for the defect.
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms_yh[i]) as calc:
        try:
            calc.calculate()
            energy = atoms_yh[i].get_potential_energy()
            TE_yh.append(energy)
            BO_yh[0].append(atoms_yh[i].get_distance(17,18))
            BO_yh[1].append(atoms_yh[i].get_distance(18,19))
            print_converged(h, energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            print_inprogress(h)
            ready = False
            pass

if not ready:
    import sys; sys.exit()

import matplotlib.pyplot as plt

# Consider the change in energy from lowest energy state
TE_yy = np.array(TE_yy)
TE_yh = np.array(TE_yh)
TE_yy -= min(TE_yy)
TE_yh -= min(TE_yh)

print('')
print('Comparison of constraint techniques:')
file_path = './img/G-c-C-linear.png'
plt.figure(0)
plt.plot(heights, TE_yy, label='O uconstrained')
plt.plot(heights, TE_yh, label='Hookean constraint')
plt.xlabel('Height (Ang)')
plt.ylabel('$\Delta$ Energy (eV)')
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#view(atoms_yy)
#view(atoms_yh)
#+END_SRC

#+RESULTS:
: Unconstrained graphene, constrained carbon in CO2:
: CO2 Distance: -3.00. In progress.

*** Bilayer / Trilayer graphene
**** Bilayer

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys

def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

layer_dist = 3.32
b1 = a1
b2 = a * np.array([1./2., 3.0**0.5/2., 0.])
b3 = a3 - 2 * np.array([0., 0., layer_dist])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3),
                  Atom('C', 1./2. * b3),
                  Atom('C', 1./3. * b1 + 1./3. * b2 + 1./2. * b3)],
                  cell=[a1, a2, a3])


atoms = unitcell
#atoms = unitcell.repeat((3,3,1))
view(atoms)
sys.exit()

defect_pos = atoms[9].position
del atoms[9]

ready = True
with jasp('graphene/G-c-final',
            encut=450,         # From convergence check
            kpts=(6,6,1),      # From convergence check
            xc='PBE',          # GGA functional type. Important for the defect.
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

if not ready:
    sys.exit()

print('')
print('Defect position: {}'.format(defect_pos))

print('')
file_path = './img/bilayer.png'
#file_path = './img/G-c-final-repeat-present.png'
#atoms = atoms.repeat((3,3,1))
#atoms.rotate('x', -np.pi/4)
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
view(atoms)
#+END_SRC

#+RESULTS:
** DONE 2016-05-27 3pm Group meeting presentation
   CLOSED: [2016-05-31 Tue 15:07] DEADLINE: <2016-05-27 Fri 3pm>

(Meeting cancelled)

*** Concept of gas phase transport

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
import sys

heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]

def movie(constraint):
    images = []
    for i, h in enumerate(heights):
        with jasp('./dft/transport/g-mono/3x3/pore=1/molec=CO2/' + constraint + '/d={0:0.2f}'.format(h)) as calc:
            atoms = calc.get_atoms()
            images.append(atoms)
    view(images)

free = 'linear-unconst_all'
unconst_G = 'linear-unconst_G'
const_all = 'linear-const'

#movie(free)
#movie(unconst_G)
movie(const_all)
#+END_SRC

#+RESULTS:

*** Bond length of molecules change as they transport

[[./img/final-project/G-bond-length.png]]

*** Total energy difference between H2 and CO2

[[./img/final-project/total_energy-comparison.png]]

*** How constraints effect total energy

Hydrogen transport through monolayer graphene. Pore=1
[[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison.png]]

*** Non-interaction distance convergence
[[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison-LJ_zoom.png]]

How does this well distance change with other molecules?
- Running comparisons with CO2 and N2.

*** Pore distance convergence
What pore interaction distance is acceptable?

[[./img/material/g-mono/4x4/pore=10/vac=16.png]]

[[./img/material/g-mono/5x5/pore=10/vac=16.png]]

[[./img/material/g-mono/6x6/pore=10/vac=16.png]]

*** Questions
- How well is DFT handling multiple species?
- - Smearing: sigma is not dependent on per molecule basis

- Pressure can change diffusion pathways (gas phase vs adsorption)
- - cite:du-2011-separ-hydrog
- - cite:drahushuk-2012-mechan-gas

* Research
** Questions
*** Are the kinetic diameters used in Blankenberg correct?
cite:blankenburg-2010-porous-graph uses cite:leeuwen-1994-deriv-stock for kinetic diameter of ammonia, even though they're stated for liquids.
cite:tsuru-2010-permeat-proper shows that certain kinetic diameter calculations may not apply to certain separations.
*** What is the unit GPU?
Gas permeance unit
1 GPU = 0.33 mol/(m^2*s*Pa)
*** What's a dispersion correction in dft?
Dipoles occur as a molecule passes through the membrane. They need to be accounted for in the energy calculations.
*** Ryd compared to eV?
Stands for Rydberg constant.
1 eV = 7.350e-2 Ryd
300 eV = 22.096 Ryd
*** TODO Best way to calculate a pore's diameter?
** Properties
*** Bond lengths

| Molecule | Bond | Bond Length (Å) |
| H2       | H-H  |            0.74 |
| CO2      | C=O  |            1.21 |
| N2       | N=-N |            1.13 |

**** References
CO2 C=O, H2, N2: CRC Handbook, Section 9, Characteristic Bond Lengths in Free Molecules

*** Common molecules
Useful numbers:
- Average energy of a gas particle at room temperature: ~0.037 eV (need cite)
  - calculated as $E=(3/2)kT$, where $k$ is the Boltzmann constant

#+caption: Properties of common industrial gases.
#+name: tab:properties-common_gases
| Molecule      |  Kinetic |
|               | diameter |
|               |      (Å) |
|---------------+----------|
| He            |     2.60 |
| H2O           |     2.65 |
| Ne            |     2.79 |
| H2            |     2.89 |
| NH3           |     3.26 |
| CO2           |     3.30 |
| Ar            |     3.42 |
| O2            |     3.46 |
| Kr            |     3.60 |
| H2S           |     3.60 |
| N2            |     3.64 |
| CO            |     3.76 |
| CH4           |     3.80 |
|---------------+----------|
| CH4           |      3.8 |
| C2H6          |      --- |
| C2H4          |      3.9 |
| C3H8          |      4.3 |
| n-C4H10       |      4.3 |
| C3H6          |      4.5 |
| i-C4H10       |        6 |
|---------------+----------|
| Benzene       |     5.85 |
| Toluene       |     5.85 |
| p-xylene      |     5.85 |
| Ethyl-benzene |     6.00 |
| Cyclohexane   |      6.0 |
| o-xylene      |     6.80 |
| m-xylene      |     6.80 |

**** References
Kinetic diameter
- He, H2S, CO: [[https://en.wikipedia.org/wiki/Kinetic_diameter][Wiki]]
- CO2, O2, N2, H2O, CH4, H2: cite:ismail-2015-fundam-gas p14
- CO2, CO, CH4: cite:li-2010-two-dimen-polyp
- NH3: cite:blankenburg-2010-porous-graph 
- Ne, Ar: [[http://www.kayelaby.npl.co.uk/general_physics/2_2/2_2_4.html][NPL]]
- Kr: [[https://smartech.gatech.edu/handle/1853/50383][Crawford-2013]]
- He, H2, O2, N2, CO, CO2, CH4, C2H6, C2H4, C3H8, C3H6, n-C4H10, i-C4H10: cite:matteucci-2006-trans-gases Has L-J parameters in same table
- benz, tol, eth-benz, xylene: cite:baertsch-1996-permeat-aromat
- cyclohexane: cite:sing-2004-use-molec

*** 2D materials

Structure
| Material | Stack | Lattice      |
|          |       | Constant [Å] |
|----------+-------+--------------|
| Graphene | Mono  | 2.460        |
|          |       |              |


Stability
| Material | Stack | Production | Temperature   | Ref                       |
|          |       |            | Stability [K] |                           |
|----------+-------+------------+---------------+---------------------------|
| Graphene | Mono  | CVD        | 2600          | cite:kim-2010-high-temper |



| Material | Features    | Pore     |
|          |             | Size (Å) |
|----------+-------------+----------|
| Graphene | Pristine    |          |
| PG       |             | 2.48     |
| PG-ES1   |             |          |
| PG-ES2   |             |          |
| PG-ES3   |             |          |
| hBN      |             |          |

**** References

Structure
- Lattice constant
  - Graphene mono: cite:partoens-2006-from-graph

Pore size
- Graphene, Pristine: 
- PG: cite:li-2010-two-dimen-polyp
** Separations

Materials to research
- Graphene Monolayer
- Graphene Bilayer
- Graphene oxide
- Boron nitride monolayer
- Boron nitride bilayer

*** Master Table

Table legend:
- 2D Material:
  - hBN: hexagonal boron nitride
  - PG: Polyphenylene (porous graphene)
  - PG-ES1: Porous Graphene-E-Stilbene-1
- Features: Distinctive variations of the material.
  - Porous: Intentially engineered pores
  - Defects: Naturally occuring defects from the production process.
- Func. Groups: Functional groups attached around a pore.
  - CNT: Carbon nanotubes
- Methods:
  - DFT: Density functional theory
  - Exp: Experimental
  - MD: Molecular dynamics simulation
  - TST: Transition state theory
- Molecules: Numbers denote separation groups. Members of "a" can be separated from "b" and both can be separated from "c". Additionally, "a" transfers across the barrier before "b".

#+caption: Table of separation selectivity groupings found in literature with molecule columns ordered by kinetic diameter.
#+name: tab:separations-common_gases
| Reference                          | Methods  | 2D             | Stack   | Features | Func.  | He | H2O | Ne | H2 | NH3 | CO2 | Ar | O2 | N2 | Kr | H2S | CO | CH4 | Note |
|                                    |          | Material       |         |          | Groups |    |     |    |    |     |     |    |    |    |    |     |    |     |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:jiang-2009-porous-graph       | DFT, MD  | Graphene       | Mono    | Porous   | N/H, H |    |     |    | a  |     |     |    |    |    |    |     |    | b   |      |
| cite:wesołowski-2011-pillar-graph  | MD       | Graphene       | Multi   | Porous   | CNT    | c  |     |    |    |     |     | b  |    |    | a  |     |    |     |      |
| cite:du-2011-separ-hydrog          | MD       | Graphene       | Mono    | Porous   |        |    |     |    | a  |     |     |    |    | b  |    |     |    |     |      |
| cite:koenig-2012-selec-molec       | Exp      | Graphene       | Bilayer | Porous   |        |    |     |    | a  |     | a   | b  |    | b  |    |     |    | b   |      |
| cite:kim-2013-selec-gas            | Exp      | Graphene       | Multi   | Defects  |        |    |     |    |    |     |     |    | a  | b  |    |     |    |     |      |
| cite:celebi-2014-ultim-permeat     | Exp      | Graphene       | Bilayer | Porous   |        |    |     |    | a  |     | b   |    |    |    |    |     |    |     |      |
| cite:lei-2014-separ-hydrog         | DFT      | Graphene       | Mono    | Porous   |        |    |     |    |    |     |     |    |    |    |    | a   |    | b   |    3 |
| cite:liu-2015-selec-trend          | MD       | Graphene       | Mono    | Porous   | N/H    |    |     |    | a  |     | a   | b  |    | b  |    |     |    | b   |      |
| cite:sun-2015-applic-nanop         | MD       | Graphene       | Mono    | Porous   | N/H    |    |     |    |    |     | a   |    |    | a  |    | a   |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:blankenburg-2010-porous-graph | DFT, MD  | PG             | Mono    |          |        | a  |     | a  | a  | c   | b   | d  | b  | c  |    |     | c  |     |      |
| cite:li-2010-two-dimen-polyp       | DFT      | PG             | Mono    |          |        |    |     |    | a  |     | b   |    |    |    |    |     | b  | b   |      |
| cite:huang-2014-improv-permeab     | DFT, MD  | PG             | Bilayer |          |        |    |     |    | a  |     |     |    |    |    |    |     |    | b   |      |
| cite:schrier-2012-carbon-dioxid    | MD       | PG-ES1         | Mono    |          |        |    |     |    |    |     | a   |    | b  | b  |    |     |    |     |      |
| cite:brockway-2013-noble-gas       | DFT, MD  | PG-ES1         | Mono    |          |        | a  |     | a  |    |     | b   | b  | b  | b  |    |     |    | c   |      |
| cite:tao-2014-tunab-hydrog         | DFT, MD  | PG-ES1         | Mono    |          |        |    |     |    | a  |     | b   |    |    | b  |    |     |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:nair-2012-unimp-permeat       | Exp, MD  | Graphene oxide | 1 µm    |          |        | b  | a   |    | b  |     |     | b  |    | b  |    |     |    |     |      |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 2-18 nm |          |        |    |     |    | a  |     | b   |    |    |    |    |     |    |     |      |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 2-18 nm |          |        |    |     |    | a  |     |     |    |    | b  |    |     |    |     |      |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 18 nm   |          |        | a  |     |    | a  |     | b   |    | b  | b  |    |     | b  | b   |    1 |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide | 3-7 nm  |          |        |    |     |    | a  |     | b   |    |    |    |    |     |    |     |    2 |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide | 3-7 nm  |          |        | b  |     |    | b  |     | a   |    | b  | b  |    |     |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:zhang-2015-hexag-boron        | DFT, MD  | hBN            | Mono    | Porous   | N/H    |    |     |    | a  |     |     |    |    |    |    |     |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:jiao-2011-graph               | DFT, TST | Graphdiyne     | Mono    |          |        |    |     |    | a  |     | b   |    |    |    |    |     |    | b   |      |
| cite:zhu-2015-c-n                  | DFT      | C2N            | Mono    |          |        | a  | b   | b  |    |     | b   | b  | b  | b  |    | b   |    | b   |      |
| cite:li-2015-effic-helium          | DFT, MD  | g-C3N4         | Mono    |          |        | a  |     | b  | b  |     | b   | b  |    | b  |    |     | b  | b   |      |

Notes:
1. Extrapolated from single-gas permeation results.
2. Long time scale ~1 hr. At short time scales <0.1 hr, the permeance rate is reversed.
3. Pore carbons had negative charge (-0.241 e).

*** Atmospheric separations
N2, O2, Ar, CO2, Ne, He, CH4 

| Reference                          | Methods  | 2D             | Stack   | Features | Func.  | N2 | O2 | Ar | CO2 | Ne | He | CH4 |
|                                    |          | Material       |         |          | Groups |    |    |    |     |    |    |     |
|------------------------------------+----------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:koenig-2012-selec-molec       | Exp      | Graphene       | Bilayer | Porous   |        | b  |    | b  | a   |    |    | b   |
| cite:kim-2013-selec-gas            | Exp      | Graphene       | Multi   | Defects  |        | b  | a  |    |     |    |    |     |
| cite:liu-2015-selec-trend          | MD       | Graphene       | Mono    | Porous   | N/H    | b  |    | b  | a   |    |    | b   |
| cite:sun-2015-applic-nanop         | MD       | Graphene       | Mono    | Porous   | N/H    | a  |    |    | a   |    |    | b   |
|------------------------------------+----------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:blankenburg-2010-porous-graph | DFT, MD  | PG             | Mono    |          |        | c  | b  | d  | b   | a  | a  |     |
| cite:schrier-2012-carbon-dioxid    | MD       | PG-ES1         | Mono    |          |        | b  | b  |    | a   |    |    |     |
| cite:brockway-2013-noble-gas       | DFT, MD  | PG-ES1         | Mono    |          |        | b  | b  | b  | b   | a  | a  | c   |
|------------------------------------+----------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 18 nm   |          |        | b  | b  |    | b   |    | a  | b   |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide | 3-7 nm  |          |        | b  | b  |    | a   |    | b  | b   |
|------------------------------------+----------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:zhu-2015-c-n                  | DFT      | C2N            | Mono    |          |        | b  | b  | b  | b   | b  | a  | b   |
| cite:li-2015-effic-helium          | DFT, MD  | g-C3N4         | Mono    |          |        | b  |    | b  | b   | b  | a  | b   |

*** Water-gas shift
CO + H2O -> CO2 + H2

| Reference                          | Methods  | 2D             | CO | H2O | CO2 | H2 |
|                                    |          | Material       |    |     |     |    |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:celebi-2014-ultim-permeat     | Exp      | Graphene       |    |     | b   | a  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:blankenburg-2010-porous-graph | DFT      | PG             | c  |     | b   | a  |
| cite:li-2010-two-dimen-polyp       | DFT      | PG             | b  |     | b   | a  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:tao-2014-tunab-hydrog         | DFT, MD  | PG-ES1         |    |     | b   | a  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:nair-2012-unimp-permeat       | Exp, MD  | Graphene oxide |    | a   |     | b  |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide |    |     | b   | a  |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | b  |     | b   | a  |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide |    |     | b   | a  |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide |    |     | a   | b  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:jiao-2011-graph               | DFT, TST | Graphdiyne     |    |     | b   | a  |

*** Nobel gas separation
He, Ne, Ar, Kr

| Reference                          | Methods  | 2D             | He | Ne | Ar | Kr |
|                                    |          | Material       |    |    |    |    |
|------------------------------------+----------+----------------+----+----+----+----|
| cite:wesołowski-2011-pillar-graph  | MD       | Graphene       | c  |    | b  | a  |
|------------------------------------+----------+----------------+----+----+----+----|
| cite:blankenburg-2010-porous-graph | DFT      | PG             | a  | a  | d  |    |
|------------------------------------+----------+----------------+----+----+----+----|
| cite:zhu-2015-c-n                  | DFT      | C2N            | a  | b  | b  |    |
| cite:li-2015-effic-helium          | DFT, MD  | g-C3N4         | a  | b  | b  |    |

* Papers
** Graphene
*** cite:novoselov-2005-two-dimen
*** cite:geim-2009-graph
*** *cite:jiang-2009-porous-graph DFT porous graphene separation of H2/CH4
Selectivity results
| Graphene monolayer porous N/H functionalized |  10^8 |
| Graphene monolayer porous H functionalized   | 10^23 |
| Traditional polymer / silica membranes       |  10^8 |
*** cite:pontes-2009-barrier-free DFT HCN production with substitutional doping using boron
*** cite:du-2011-separ-hydrog DFT H2/N2 separation
*** *cite:koenig-2012-selec-molec Experimental separation of common gases
*** cite:shan-2012-influen-chemic CO2/N2 separation using cite:jiang-2009-porous-graph funcitonalized groups
*** TODO cite:drahushuk-2012-mechan-gas MD H2/N2 separation. Explains mechanisms for gases crossing the membrane
*** cite:kim-2013-selec-gas  Exp O2/N2. Most work done on GO.
*** cite:miao-2013-first-princ DFT proton/H separation
*** cite:qin-2013-graph-with H2&He separation from air. Octogon pore + secondary small pore.
*** cite:ambrosetti-2014-gas-separ Water filtration through porous graphene. No permeation/selectivity data.
*** cite:celebi-2014-ultim-permeat Exp separation of H2/CO2 with bilayer G. Also a water permeance comparison to Goretex.
*** cite:tsetseris-2014-graph DFT Boron can pass through pristine graphene under moderate annealing conditions
*** cite:sun-2015-applic-nanop DFT separation for gases in natural gas processing
*** cite:wen-2015-inhib-effec Inhibition effect of non-permeating components
*** cite:achtyl-2015-aqueous-proton Exp/DFT Defect detection. Aqueous proton transfer

*** TODO partoens graphene structure
** Polyphenylene (Porous Graphene (PG))
*** TODO cite:bieri-2009-porous-graph Synthesis of PG
*** *cite:blankenburg-2010-porous-graph Selectivity study of common gases with DFT
[[./img/blankenburg-2010-porous-graph-3.png]]
*** cite:schrier-2010-helium-separ Helium isotope separation
*** cite:li-2010-two-dimen-polyp H2 separation from CO2, CO, CH4
*** TODO cite:lu-2014-promis-monol DFT O2 separation from harmful gases
*** cite:huang-2014-improv-permeab Bilayer porous graphene. H2/CH4 separation. High permeance and selectivity
*** cite:tao-2014-tunab-hydrog DFT PG-ESX study on hydrogen purification
| Molecule |     Kinetic |
|          | Diam. (Ang) |
|----------+-------------|
| H2       |         2.9 |
| N2       |        3.64 |
| CO       |        3.76 |
| CH4      |         3.8 |
Note: Agrees with common molecules table.

*** *cite:brockway-2013-noble-gas DFT PG-ESX study similar to Blankenberg's
*** Notes 
High temperatures required for permeance of H2 and He would destroy a PG monolayer. cite:huang-2014-improv-permeab
** hexagonal Boron Nitride (hBN)
*** cite:corso-2004-boron-nitrid-nanom Boron nitride nanomesh
Hole in mesh: size 20 Å
- 'likely driven by the lattice mismatch of the film and the rhodium substrate'
*** cite:jin-2009-fabric-frees monolayer fabrication with electron irradiation
*** cite:nag-2010-graph-analog-bn properties of hBN compared to graphene
*** cite:hu-2014-proton-trans proton transport of graphene, hBN, MoS2
*** *cite:zhang-2015-hexag-boron H2/CH4 separation. Triangular pores.
Drahushuk, L. W.; Strano, M. S. Mechanisms of Gas Permeation
through Single Layer Graphene. Langmuir 2012, 28, 16671−16678.
** Graphene oxide
*** *cite:kim-2013-selec-gas
*** *cite:li-2013-ultrat-molec
*** cite:yoo-2013-graph-graph
** Molybdenum disulphide (MoS2)
*** cite:hong-2015-explor-atomic 
** Quantum mechanics
*** Lennard-Jones potential
[[http://chemwiki.ucdavis.edu/Core/Physical_Chemistry/Physical_Properties_of_Matter/Atomic_and_Molecular_Properties/Intermolecular_Forces/Specific_Interactions/Lennard-Jones_Potential][ChemWiki - UC Davis]]

*** van der Waals radius
[[http://chemwiki.ucdavis.edu/Core/Theoretical_Chemistry/Chemical_Bonding/General_Principles_of_Chemical_Bonding/Covalent_Bond_Distance%2C_Radius_and_van_der_Waals_Radius][ChemWiki - UC Davis]]
** Neural networks
*** *cite:behler-2007-gener-neural
*** TODO cite:behler-2008-press-induc
*** TODO cite:behler-2011-neural-networ
*** TODO cite:behler-2014-repres-poten
** Review articles
*** cite:yoo-2013-graph-graph Graphene and graphene oxide uses as barriers
** Patents
*** TODO Aperture
http://www.google.com/patents/US20140263035
** Non-pertinent
*** TODO cite:britnell-2012-elect-tunnel hBN as a dielectric
** To Read
*** TODO cite:elstner-1998-self-consis
*** TODO cite:zhu-2006-permean-shoul
*** TODO cite:zhang-2012-tunab-hydrog
*** TODO cite:drahushuk-2012-mechan-gas
*** TODO cite:nieszporek-2015-alkan-separ
*** TODO cite:liu-2014-mechan-proper
*** TODO cite:tao-2014-tunab-hydrog
*** TODO cite:wang-2014-trans-metal
*** TODO cite:bunch-2008-imper-atomic
*** TODO cite:leeuwen-1994-deriv-stock Derivation of L-J lengths of liquids.
*** TODO cite:hauser-2012-methan-selec Methane transfer through graphene, DFT
* References
bibliographystyle:unsrtnat
bibliography:references.bib
* Tasks :noexport:
** Research
*** TODO What should this project be?
** DFT
*** TODO Relaxed graphene plane atoms transport
Perform the same calculations as the final project but while also relaxing the atoms in the graphene plane.

*** TODO Find limit where gases appear to be in vaccuum before transport
*** TODO Bilayer / trilayer graphene structures
** Snippets
*** TODO Python script for generating good movies
