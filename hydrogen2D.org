#+title: MS Research Project
#+author: Devon Walker
#+email: devonw@andrew.cmu.edu
#+TODO: TODO(t) INPROGRESS(w!) | DONE(d!) CANCELED(c!)

* Journal
** 2016-05-19 Thu
- cite:zan-2012-graph-reknit Graphene Reknits Its Holes - Zan, Novoselov*

Competing possible research avenues:
1. Repairing graphene
2. Stacked-graphene aperture effect
  2.1. Neural network?

** 2016-05-20 Fri
- cite:drahushuk-2012-mechan-gas Mechanisms of Gas Permeation through Single Layer Graphene Membranes - Drahushuk, Strano*

** 2016-05-23 Mon
- cite:du-2011-separ-hydrog Separation of Hydrogen and Nitrogen Gases With  Porous Graphene Membrane - Du, Zhao*

** 2016-05-24 Tue
- cite:koenig-2012-selec-molec Selective Molecular Sieving Through Porous Graphene - Keonig, Bunch*

** 2016-05-25 Wed
- cite:liu-2013-permean-h2 

Simulators meeting
- Jake presented neural network vs reaxff with Au

** 2016-05-26 Thu
- cite:jiang-2009-porous-graph

** 2016-05-27 Fri
- cite:sun-2014-mechan-molec

Prepared for a group meeting presentation. Ended up not having one.

** 2016-05-31 Tue
- cite:drahushuk-2016-analy-time Analysis of Time-Varying, Stochastic Gas Transport Through Graphene Membranes - Drahushuk, Keonig, Bunch*, Strano*

Created vaccuum distance graph to deteremine interaction distance of leading atoms in a molecule.

Bilayer graphene unit cell in queue for relaxation.

Need to redo some of the 'free' transport. The graphene plane simply shifted down as the molecules approached. Might help to fix carbons around the outside edge.

*** DONE Check in on monolayer 5x5 and 6x6 pore=10 calculations
    CLOSED: [2016-06-01 Wed 12:26]
** 2016-06-01 Wed
- cite:shan-2012-influen-chemic
- cite:schrier-2012-carbon-dioxid
cite:koenig-2012-selec-molec

- cite:wang-2015-molec-valves Molecular valves for controlling gas phase transport made from discrete ångström-sized pores in graphene - Wang, Drahushuk, Strano*
   
- cite:partoens-2007-from-graph


Possible research idea: Look into pore stability of different passivating molecules, including what it takes to remove a passivated species (ie. if N is a more stable passivating species than H, what is the energy barrier for replacing H with N?).

*** DONE Finish structure of pore=10 for bilayer
    CLOSED: [2016-06-01 Wed 12:26]

** 2016-06-02 Thu


*** DONE Finish pore=10 for bilayer
    CLOSED: [2016-06-01 Wed 12:26]

** 2016-06-03 Fri
** 2016-06-06 Mon
** 2016-06-07 Tue
** 2016-06-08 Wed
** 2016-06-09 Thu
* Meetings
** DONE 2016-03-08 4pm
   CLOSED: [2016-03-09 Wed 09:26] DEADLINE: <2016-03-08 Tue 16:00>
*** Questions
quantum mechanics:
- can we adsorb molecules to the surface which impart favorable changes to the electron density around diffusion sites?

neural network:
- can we use a neural network to address properties that dft doesn't model well, such as charging the material with a potential?

org-ref:
- can you later attach a pdf?
- duplicate current bibliography into default bibliography?
- do you highlight pdfs or just type into the notes file?

*** Actions
1. Table outlining separation data

** DONE 2016-04-15 11am
   CLOSED: [2016-05-11 Wed 16:02] DEADLINE: <2016-04-15 Fri 11:00>
*** Final project suggestion
- develop a suggestion related to research
- look into what jasp is lacking

*** Neural networks
Behler-Parrinello paper from 2007
- inputs are atom positions
- questions
  - how is it not overfit with an 8200 optimizing set and 800 test set?
  - is there a way to use different inputs or generalize them? (ie. an input could be the position or presence of a functional group)

** DONE 2016-05-12 11am
*** Final project feedback
[[file:~/techela/s16-06640/final-project/final-project.org::*Transport of carbon dioxide]]

*** Correct constraints for a molecule

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.constraints import FixAtoms, Hookean
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
import sys

JASPRC['queue.walltime'] = '10:00:00'

def print_converged(i, energy, time):
#    print(i, energy, time)
    print("CO2 Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("CO2 Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("CO2 Distance: {:5.2f}. Did not converge.".format(i))


# Height of the fixed atom
heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]


# Build base images
with jasp('graphene/G-c-final') as calc:
    G_defect = calc.get_atoms()
def_pos = np.array([5.681, 0., 5.]) # defect position

# http://en.wikipedia.org/wiki/Carbon_dioxide_(data_page)
CO_bond = 1.16 # Ang. C=O bond length in CO2

atoms =  [Atoms(G_defect) for i in range(len(heights))]
for i, h in enumerate(heights):
    CO2 = Atoms([Atom('O', def_pos + (0., 0., h - CO_bond)),
                 Atom('C', def_pos + (0., 0., h)),
                 Atom('O', def_pos + (0., 0., h + CO_bond))])

    atoms[i].extend(CO2)

# Constraint - fix all carbons (including the CO2 carbon)
carbon_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Hookean constraint
# Values for constants rt [Ang] and k [eV/Ang^-2] are from https://wiki.fysik.dtu.dk/ase/ase/constraints.html for a C=O bond
for atom in atoms[0]:
    if atom.symbol == 'O':
        hook_constraint = [Hookean(a1=atom.index, a2=atom.index+1, rt=1.58, k=10.),
                           Hookean(a1=atom.index+1, a2=atom.index+2, rt=1.58, k=10.)]
        break

ready = True

# Constrained graphene, constrained carbon in CO2
print('Unconstrained graphene, constrained carbon in CO2:')

atoms_yy = [Atoms(atoms[i]) for i in range(len(heights))]
#for i in range(len(heights)):
#    atoms_yy[i].set_constraint(carbon_constraint)





with jasp('transport/G-c-CO2-transport-no-yes-d=1.00a'.format(h),
                encut=450,         # From convergence check
                kpts=(6,6,1),      # From convergence check
                xc='PBE',          # GGA functional type. Important for the defect.
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms_yy[i]) as calc:
        try:
            calc.calculate()
            energy = atoms_yy[i].get_potential_energy()
            print_converged(h, energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            print_inprogress(h)
            ready = False
            pass
sys.exit()





TE_yy = []
BO_yy = [[], []]
for i, h in enumerate(heights):
    with jasp('transport/G-c-CO2-transport-no-yes-d={0:0.2f}'.format(h),
                encut=450,         # From convergence check
                kpts=(6,6,1),      # From convergence check
                xc='PBE',          # GGA functional type. Important for the defect.
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms_yy[i]) as calc:
        try:
            calc.calculate()
            energy = atoms_yy[i].get_potential_energy()
            TE_yy.append(energy)
            BO_yy[0].append(atoms_yy[i].get_distance(17,18))
            BO_yy[1].append(atoms_yy[i].get_distance(18,19))
            print_converged(h, energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            print_inprogress(h)
            ready = False
            pass


# Constrained graphene, constrained carbon in CO2 + Hookean oxygen
print('')
print('Unconstrained graphene, constrained carbon + Hookean oxygen:')

atoms_yh = [Atoms(atoms[i]) for i in range(len(heights))]
#for i in range(len(heights)):
#    atoms_yh[i].set_constraint(carbon_constraint + hook_constraint)

TE_yh = []
BO_yh = [[], []]
for i, h in enumerate(heights):
    with jasp('transport/G-c-CO2-transport-no-hook-d={0:0.2f}'.format(h),
                encut=450,         # From convergence check
                kpts=(6,6,1),      # From convergence check
                xc='PBE',          # GGA functional type. Important for the defect.
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms_yh[i]) as calc:
        try:
            calc.calculate()
            energy = atoms_yh[i].get_potential_energy()
            TE_yh.append(energy)
            BO_yh[0].append(atoms_yh[i].get_distance(17,18))
            BO_yh[1].append(atoms_yh[i].get_distance(18,19))
            print_converged(h, energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            print_inprogress(h)
            ready = False
            pass

if not ready:
    import sys; sys.exit()

import matplotlib.pyplot as plt

# Consider the change in energy from lowest energy state
TE_yy = np.array(TE_yy)
TE_yh = np.array(TE_yh)
TE_yy -= min(TE_yy)
TE_yh -= min(TE_yh)

print('')
print('Comparison of constraint techniques:')
file_path = './img/G-c-C-linear.png'
plt.figure(0)
plt.plot(heights, TE_yy, label='O uconstrained')
plt.plot(heights, TE_yh, label='Hookean constraint')
plt.xlabel('Height (Ang)')
plt.ylabel('$\Delta$ Energy (eV)')
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#view(atoms_yy)
#view(atoms_yh)
#+END_SRC

#+RESULTS:
: Unconstrained graphene, constrained carbon in CO2:
: CO2 Distance: -3.00. In progress.

*** Bilayer / Trilayer graphene
**** Bilayer

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys

def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

layer_dist = 3.32
b1 = a1
b2 = a * np.array([1./2., 3.0**0.5/2., 0.])
b3 = a3 - 2 * np.array([0., 0., layer_dist])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3),
                  Atom('C', 1./2. * b3),
                  Atom('C', 1./3. * b1 + 1./3. * b2 + 1./2. * b3)],
                  cell=[a1, a2, a3])


atoms = unitcell
#atoms = unitcell.repeat((3,3,1))
view(atoms)
sys.exit()

defect_pos = atoms[9].position
del atoms[9]

ready = True
with jasp('graphene/G-c-final',
            encut=450,         # From convergence check
            kpts=(6,6,1),      # From convergence check
            xc='PBE',          # GGA functional type. Important for the defect.
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

if not ready:
    sys.exit()

print('')
print('Defect position: {}'.format(defect_pos))

print('')
file_path = './img/bilayer.png'
#file_path = './img/G-c-final-repeat-present.png'
#atoms = atoms.repeat((3,3,1))
#atoms.rotate('x', -np.pi/4)
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
view(atoms)
#+END_SRC

#+RESULTS:
** DONE 2016-05-27 3pm Presentation Prep
   CLOSED: [2016-05-31 Tue 15:07] DEADLINE: <2016-05-27 Fri 3pm>

(Meeting cancelled)

*** Concept of gas phase transport

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
import sys

heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]

def movie(constraint):
    images = []
    for i, h in enumerate(heights):
        with jasp('./dft/transport/g-mono/3x3/pore=1/molec=CO2/' + constraint + '/d={0:0.2f}'.format(h)) as calc:
            atoms = calc.get_atoms()
            images.append(atoms)
    view(images)

free = 'linear-unconst_all'
unconst_G = 'linear-unconst_G'
const_all = 'linear-const'

#movie(free)
#movie(unconst_G)
movie(const_all)
#+END_SRC

#+RESULTS:

*** Bond length of molecules change as they transport

[[./img/final-project/G-bond-length.png]]

*** Total energy difference between H2 and CO2

[[./img/final-project/total_energy-comparison.png]]

*** How constraints effect total energy

Hydrogen transport through monolayer graphene. Pore=1
[[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison.png]]

*** Non-interaction distance convergence
[[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison-LJ_zoom.png]]

How does this well distance change with other molecules?
- Running comparisons with CO2 and N2.

*** Pore distance convergence
What pore interaction distance is acceptable?

[[./img/material/g-mono/4x4/pore=10/vac=16.png]]

[[./img/material/g-mono/5x5/pore=10/vac=16.png]]

[[./img/material/g-mono/6x6/pore=10/vac=16.png]]

*** Questions
- How well is DFT handling multiple species?
- - Smearing: sigma is not dependent on per molecule basis

- Pressure can change diffusion pathways (gas phase vs adsorption)
- - cite:du-2011-separ-hydrog
- - cite:drahushuk-2012-mechan-gas
** DONE 2016-05-27 3pm Group meeting presentation
   CLOSED: [2016-05-31 Tue 15:07] DEADLINE: <2016-05-27 Fri 3pm>

(Meeting cancelled)

*** Concept of gas phase transport

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
import sys

heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]

def movie(constraint):
    images = []
    for i, h in enumerate(heights):
        with jasp('./dft/transport/g-mono/3x3/pore=1/molec=CO2/' + constraint + '/d={0:0.2f}'.format(h)) as calc:
            atoms = calc.get_atoms()
            images.append(atoms)
    view(images)

free = 'linear-unconst_all'
unconst_G = 'linear-unconst_G'
const_all = 'linear-const'

#movie(free)
#movie(unconst_G)
movie(const_all)
#+END_SRC

#+RESULTS:

*** Bond length of molecules change as they transport

[[./img/final-project/G-bond-length.png]]

*** Total energy difference between H2 and CO2

[[./img/final-project/total_energy-comparison.png]]

*** How constraints effect total energy

Hydrogen transport through monolayer graphene. Pore=1
[[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison.png]]

*** Non-interaction distance convergence
[[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison-LJ_zoom.png]]

How does this well distance change with other molecules?
- Running comparisons with CO2 and N2.

*** Pore distance convergence
What pore interaction distance is acceptable?

[[./img/material/g-mono/4x4/pore=10/vac=16.png]]

[[./img/material/g-mono/5x5/pore=10/vac=16.png]]

[[./img/material/g-mono/6x6/pore=10/vac=16.png]]

*** Questions
- How well is DFT handling multiple species?
- - Smearing: sigma is not dependent on per molecule basis

- Pressure can change diffusion pathways (gas phase vs adsorption)
- - cite:du-2011-separ-hydrog
- - cite:drahushuk-2012-mechan-gas

* Research
** Literature
*** Graphene
**** cite:novoselov-2005-two-dimen
**** cite:partoens-2006-from-graph graphene structure unitcell
**** cite:geim-2009-graph
**** *cite:jiang-2009-porous-graph DFT porous graphene separation of H2/CH4
 Selectivity results
 | Graphene monolayer porous N/H functionalized |  10^8 |
 | Graphene monolayer porous H functionalized   | 10^23 |
 | Traditional polymer / silica membranes       |  10^8 |
**** cite:pontes-2009-barrier-free DFT HCN production with substitutional doping using boron
**** DONE cite:du-2011-separ-hydrog DFT H2/N2 separation
     CLOSED: [2016-06-01 Wed 14:59]
**** DONE *cite:koenig-2012-selec-molec Experimental separation of common gases
     CLOSED: [2016-06-01 Wed 14:59]
**** cite:shan-2012-influen-chemic CO2/N2 separation using cite:jiang-2009-porous-graph funcitonalized groups
**** DONE cite:drahushuk-2012-mechan-gas MD H2/N2 separation. Explains mechanisms for gases crossing the membrane
     CLOSED: [2016-06-01 Wed 14:59]
**** cite:kim-2013-selec-gas  Exp O2/N2. Most work done on GO.
**** cite:miao-2013-first-princ DFT proton/H separation
**** cite:qin-2013-graph-with H2&He separation from air. Octogon pore + secondary small pore.
**** cite:ambrosetti-2014-gas-separ Water filtration through porous graphene. No permeation/selectivity data.
**** cite:celebi-2014-ultim-permeat Exp separation of H2/CO2 with bilayer G. Also a water permeance comparison to Goretex.
**** cite:tsetseris-2014-graph DFT Boron can pass through pristine graphene under moderate annealing conditions
**** cite:sun-2015-applic-nanop DFT separation for gases in natural gas processing
**** cite:wen-2015-inhib-effec Inhibition effect of non-permeating components
**** cite:achtyl-2015-aqueous-proton Exp/DFT Defect detection. Aqueous proton transfer

*** Polyphenylene (Porous Graphene (PG))
**** cite:bieri-2009-porous-graph Synthesis of PG
**** *cite:blankenburg-2010-porous-graph Selectivity study of common gases with DFT
 [[./img/blankenburg-2010-porous-graph-3.png]]
**** cite:schrier-2010-helium-separ Helium isotope separation
**** cite:li-2010-two-dimen-polyp H2 separation from CO2, CO, CH4
**** cite:lu-2014-promis-monol DFT O2 separation from harmful gases
**** cite:huang-2014-improv-permeab Bilayer porous graphene. H2/CH4 separation. High permeance and selectivity
**** cite:tao-2014-tunab-hydrog DFT PG-ESX study on hydrogen purification
 | Molecule |     Kinetic |
 |          | Diam. (Ang) |
 |----------+-------------|
 | H2       |         2.9 |
 | N2       |        3.64 |
 | CO       |        3.76 |
 | CH4      |         3.8 |
 Note: Agrees with common molecules table.

**** *cite:brockway-2013-noble-gas DFT PG-ESX study similar to Blankenberg's
**** Notes 
 High temperatures required for permeance of H2 and He would destroy a PG monolayer. cite:huang-2014-improv-permeab
*** hexagonal Boron Nitride (hBN)
**** cite:corso-2004-boron-nitrid-nanom Boron nitride nanomesh
 Hole in mesh: size 20 Å
 - 'likely driven by the lattice mismatch of the film and the rhodium substrate'
**** cite:jin-2009-fabric-frees monolayer fabrication with electron irradiation
**** cite:nag-2010-graph-analog-bn properties of hBN compared to graphene
**** cite:hu-2014-proton-trans proton transport of graphene, hBN, MoS2
**** *cite:zhang-2015-hexag-boron H2/CH4 separation. Triangular pores.
 Drahushuk, L. W.; Strano, M. S. Mechanisms of Gas Permeation
 through Single Layer Graphene. Langmuir 2012, 28, 16671−16678.
*** Graphene oxide
**** *cite:kim-2013-selec-gas
**** *cite:li-2013-ultrat-molec
**** cite:yoo-2013-graph-graph
*** Molybdenum disulphide (MoS2)
**** cite:hong-2015-explor-atomic 
*** Quantum mechanics
**** Lennard-Jones potential
 [[http://chemwiki.ucdavis.edu/Core/Physical_Chemistry/Physical_Properties_of_Matter/Atomic_and_Molecular_Properties/Intermolecular_Forces/Specific_Interactions/Lennard-Jones_Potential][ChemWiki - UC Davis]]

**** van der Waals radius
 [[http://chemwiki.ucdavis.edu/Core/Theoretical_Chemistry/Chemical_Bonding/General_Principles_of_Chemical_Bonding/Covalent_Bond_Distance%2C_Radius_and_van_der_Waals_Radius][ChemWiki - UC Davis]]
*** Neural networks
**** *cite:behler-2007-gener-neural
**** TODO cite:behler-2008-press-induc
**** TODO cite:behler-2011-neural-networ
**** TODO cite:behler-2014-repres-poten
*** Review articles
**** cite:yoo-2013-graph-graph Graphene and graphene oxide uses as barriers
*** Patents
**** TODO Aperture
 http://www.google.com/patents/US20140263035
*** Non-pertinent
**** TODO cite:britnell-2012-elect-tunnel hBN as a dielectric
*** To Read
**** TODO cite:elstner-1998-self-consis
**** TODO cite:zhu-2006-permean-shoul
**** TODO cite:zhang-2012-tunab-hydrog
**** TODO cite:drahushuk-2012-mechan-gas
**** TODO cite:nieszporek-2015-alkan-separ
**** TODO cite:liu-2014-mechan-proper
**** TODO cite:tao-2014-tunab-hydrog
**** TODO cite:wang-2014-trans-metal
**** TODO cite:bunch-2008-imper-atomic
**** TODO cite:leeuwen-1994-deriv-stock Derivation of L-J lengths of liquids.
**** TODO cite:hauser-2012-methan-selec Methane transfer through graphene, DFT
** Questions
** Are the kinetic diameters used in Blankenberg correct?
cite:blankenburg-2010-porous-graph uses cite:leeuwen-1994-deriv-stock for kinetic diameter of ammonia, even though they're stated for liquids.
cite:tsuru-2010-permeat-proper shows that certain kinetic diameter calculations may not apply to certain separations.
** What is the unit GPU?
Gas permeance unit
1 GPU = 0.33 mol/(m^2*s*Pa)
** What's a dispersion correction in dft?
Dipoles occur as a molecule passes through the membrane. They need to be accounted for in the energy calculations.
** Ryd compared to eV?
Stands for Rydberg constant.
1 eV = 7.350e-2 Ryd
300 eV = 22.096 Ryd
** TODO Best way to calculate a pore's diameter?
** What should I compare H2 transport with?
- cite:koenig-2012-selec-molec 
- cite:jiang-2009-porous-graph 
- cite:blankenburg-2010-porous-graph

** Properties
*** Bond lengths

| Molecule | Bond | Bond Length (Å) |
| H2       | H-H  |            0.74 |
| CO2      | C=O  |            1.21 |
| N2       | N=-N |            1.13 |

**** References
CO2 C=O, H2, N2: CRC Handbook, Section 9, Characteristic Bond Lengths in Free Molecules

*** Common molecules
Useful numbers:
- Average energy of a gas particle at room temperature: ~0.037 eV (need cite)
  - calculated as $E=(3/2)kT$, where $k$ is the Boltzmann constant

#+caption: Properties of common industrial gases.
#+name: tab:properties-common_gases
| Molecule      |  Kinetic |
|               | diameter |
|               |      (Å) |
|---------------+----------|
| He            |     2.60 |
| H2O           |     2.65 |
| Ne            |     2.79 |
| H2            |     2.89 |
| NH3           |     3.26 |
| CO2           |     3.30 |
| Ar            |     3.42 |
| O2            |     3.46 |
| Kr            |     3.60 |
| H2S           |     3.60 |
| N2            |     3.64 |
| CO            |     3.76 |
| CH4           |     3.80 |
|---------------+----------|
| CH4           |      3.8 |
| C2H6          |      --- |
| C2H4          |      3.9 |
| C3H8          |      4.3 |
| n-C4H10       |      4.3 |
| C3H6          |      4.5 |
| i-C4H10       |        6 |
|---------------+----------|
| Benzene       |     5.85 |
| Toluene       |     5.85 |
| p-xylene      |     5.85 |
| Ethyl-benzene |     6.00 |
| Cyclohexane   |      6.0 |
| o-xylene      |     6.80 |
| m-xylene      |     6.80 |

**** References
Kinetic diameter
- He, H2S, CO: [[https://en.wikipedia.org/wiki/Kinetic_diameter][Wiki]]
- CO2, O2, N2, H2O, CH4, H2: cite:ismail-2015-fundam-gas p14
- CO2, CO, CH4: cite:li-2010-two-dimen-polyp
- NH3: cite:blankenburg-2010-porous-graph 
- Ne, Ar: [[http://www.kayelaby.npl.co.uk/general_physics/2_2/2_2_4.html][NPL]]
- Kr: [[https://smartech.gatech.edu/handle/1853/50383][Crawford-2013]]
- He, H2, O2, N2, CO, CO2, CH4, C2H6, C2H4, C3H8, C3H6, n-C4H10, i-C4H10: cite:matteucci-2006-trans-gases Has L-J parameters in same table
- benz, tol, eth-benz, xylene: cite:baertsch-1996-permeat-aromat
- cyclohexane: cite:sing-2004-use-molec

*** 2D materials

Structure
| Material | Stack | Lattice      |
|          |       | Constant [Å] |
|----------+-------+--------------|
| Graphene | Mono  | 2.460        |
|          |       |              |


Stability
| Material | Stack | Production | Temperature   | Ref                       |
|          |       |            | Stability [K] |                           |
|----------+-------+------------+---------------+---------------------------|
| Graphene | Mono  | CVD        | 2600          | cite:kim-2010-high-temper |



| Material | Features    | Pore     |
|          |             | Size (Å) |
|----------+-------------+----------|
| Graphene | Pristine    |          |
| PG       |             | 2.48     |
| PG-ES1   |             |          |
| PG-ES2   |             |          |
| PG-ES3   |             |          |
| hBN      |             |          |

**** References

Structure
- Lattice constant
  - Graphene mono: cite:partoens-2006-from-graph

Pore size
- Graphene, Pristine: 
- PG: cite:li-2010-two-dimen-polyp
** Separations

Materials to research
- Graphene Monolayer
- Graphene Bilayer
- Graphene oxide
- Boron nitride monolayer
- Boron nitride bilayer

*** Master Table

Table legend:
- 2D Material:
  - hBN: hexagonal boron nitride
  - PG: Polyphenylene (porous graphene)
  - PG-ES1: Porous Graphene-E-Stilbene-1
- Features: Distinctive variations of the material.
  - Porous: Intentially engineered pores
  - Defects: Naturally occuring defects from the production process.
- Func. Groups: Functional groups attached around a pore.
  - CNT: Carbon nanotubes
- Methods:
  - DFT: Density functional theory
  - Exp: Experimental
  - MD: Molecular dynamics simulation
  - TST: Transition state theory
- Molecules: Numbers denote separation groups. Members of "a" can be separated from "b" and both can be separated from "c". Additionally, "a" transfers across the barrier before "b".

#+caption: Table of separation selectivity groupings found in literature with molecule columns ordered by kinetic diameter.
#+name: tab:separations-common_gases
| Reference                          | Methods  | 2D             | Stack   | Features | Func.  | He | H2O | Ne | H2 | NH3 | CO2 | Ar | O2 | N2 | Kr | H2S | CO | CH4 | Note |
|                                    |          | Material       |         |          | Groups |    |     |    |    |     |     |    |    |    |    |     |    |     |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:jiang-2009-porous-graph       | DFT, MD  | Graphene       | Mono    | Porous   | N/H, H |    |     |    | a  |     |     |    |    |    |    |     |    | b   |      |
| cite:wesołowski-2011-pillar-graph  | MD       | Graphene       | Multi   | Porous   | CNT    | c  |     |    |    |     |     | b  |    |    | a  |     |    |     |      |
| cite:du-2011-separ-hydrog          | MD       | Graphene       | Mono    | Porous   |        |    |     |    | a  |     |     |    |    | b  |    |     |    |     |      |
| cite:koenig-2012-selec-molec       | Exp      | Graphene       | Bilayer | Porous   |        |    |     |    | a  |     | a   | b  |    | b  |    |     |    | b   |      |
| cite:kim-2013-selec-gas            | Exp      | Graphene       | Multi   | Defects  |        |    |     |    |    |     |     |    | a  | b  |    |     |    |     |      |
| cite:celebi-2014-ultim-permeat     | Exp      | Graphene       | Bilayer | Porous   |        |    |     |    | a  |     | b   |    |    |    |    |     |    |     |      |
| cite:lei-2014-separ-hydrog         | DFT      | Graphene       | Mono    | Porous   |        |    |     |    |    |     |     |    |    |    |    | a   |    | b   |    3 |
| cite:liu-2015-selec-trend          | MD       | Graphene       | Mono    | Porous   | N/H    |    |     |    | a  |     | a   | b  |    | b  |    |     |    | b   |      |
| cite:sun-2015-applic-nanop         | MD       | Graphene       | Mono    | Porous   | N/H    |    |     |    |    |     | a   |    |    | a  |    | a   |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:blankenburg-2010-porous-graph | DFT, MD  | PG             | Mono    |          |        | a  |     | a  | a  | c   | b   | d  | b  | c  |    |     | c  |     |      |
| cite:li-2010-two-dimen-polyp       | DFT      | PG             | Mono    |          |        |    |     |    | a  |     | b   |    |    |    |    |     | b  | b   |      |
| cite:huang-2014-improv-permeab     | DFT, MD  | PG             | Bilayer |          |        |    |     |    | a  |     |     |    |    |    |    |     |    | b   |      |
| cite:schrier-2012-carbon-dioxid    | MD       | PG-ES1         | Mono    |          |        |    |     |    |    |     | a   |    | b  | b  |    |     |    |     |      |
| cite:brockway-2013-noble-gas       | DFT, MD  | PG-ES1         | Mono    |          |        | a  |     | a  |    |     | b   | b  | b  | b  |    |     |    | c   |      |
| cite:tao-2014-tunab-hydrog         | DFT, MD  | PG-ES1         | Mono    |          |        |    |     |    | a  |     | b   |    |    | b  |    |     |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:nair-2012-unimp-permeat       | Exp, MD  | Graphene oxide | 1 µm    |          |        | b  | a   |    | b  |     |     | b  |    | b  |    |     |    |     |      |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 2-18 nm |          |        |    |     |    | a  |     | b   |    |    |    |    |     |    |     |      |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 2-18 nm |          |        |    |     |    | a  |     |     |    |    | b  |    |     |    |     |      |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 18 nm   |          |        | a  |     |    | a  |     | b   |    | b  | b  |    |     | b  | b   |    1 |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide | 3-7 nm  |          |        |    |     |    | a  |     | b   |    |    |    |    |     |    |     |    2 |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide | 3-7 nm  |          |        | b  |     |    | b  |     | a   |    | b  | b  |    |     |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:zhang-2015-hexag-boron        | DFT, MD  | hBN            | Mono    | Porous   | N/H    |    |     |    | a  |     |     |    |    |    |    |     |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:jiao-2011-graph               | DFT, TST | Graphdiyne     | Mono    |          |        |    |     |    | a  |     | b   |    |    |    |    |     |    | b   |      |
| cite:zhu-2015-c-n                  | DFT      | C2N            | Mono    |          |        | a  | b   | b  |    |     | b   | b  | b  | b  |    | b   |    | b   |      |
| cite:li-2015-effic-helium          | DFT, MD  | g-C3N4         | Mono    |          |        | a  |     | b  | b  |     | b   | b  |    | b  |    |     | b  | b   |      |

Notes:
1. Extrapolated from single-gas permeation results.
2. Long time scale ~1 hr. At short time scales <0.1 hr, the permeance rate is reversed.
3. Pore carbons had negative charge (-0.241 e).

*** Atmospheric separations
N2, O2, Ar, CO2, Ne, He, CH4 

| Reference                          | Methods  | 2D             | Stack   | Features | Func.  | N2 | O2 | Ar | CO2 | Ne | He | CH4 |
|                                    |          | Material       |         |          | Groups |    |    |    |     |    |    |     |
|------------------------------------+----------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:koenig-2012-selec-molec       | Exp      | Graphene       | Bilayer | Porous   |        | b  |    | b  | a   |    |    | b   |
| cite:kim-2013-selec-gas            | Exp      | Graphene       | Multi   | Defects  |        | b  | a  |    |     |    |    |     |
| cite:liu-2015-selec-trend          | MD       | Graphene       | Mono    | Porous   | N/H    | b  |    | b  | a   |    |    | b   |
| cite:sun-2015-applic-nanop         | MD       | Graphene       | Mono    | Porous   | N/H    | a  |    |    | a   |    |    | b   |
|------------------------------------+----------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:blankenburg-2010-porous-graph | DFT, MD  | PG             | Mono    |          |        | c  | b  | d  | b   | a  | a  |     |
| cite:schrier-2012-carbon-dioxid    | MD       | PG-ES1         | Mono    |          |        | b  | b  |    | a   |    |    |     |
| cite:brockway-2013-noble-gas       | DFT, MD  | PG-ES1         | Mono    |          |        | b  | b  | b  | b   | a  | a  | c   |
|------------------------------------+----------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 18 nm   |          |        | b  | b  |    | b   |    | a  | b   |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide | 3-7 nm  |          |        | b  | b  |    | a   |    | b  | b   |
|------------------------------------+----------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:zhu-2015-c-n                  | DFT      | C2N            | Mono    |          |        | b  | b  | b  | b   | b  | a  | b   |
| cite:li-2015-effic-helium          | DFT, MD  | g-C3N4         | Mono    |          |        | b  |    | b  | b   | b  | a  | b   |

*** Water-gas shift
CO + H2O -> CO2 + H2

| Reference                          | Methods  | 2D             | CO | H2O | CO2 | H2 |
|                                    |          | Material       |    |     |     |    |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:celebi-2014-ultim-permeat     | Exp      | Graphene       |    |     | b   | a  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:blankenburg-2010-porous-graph | DFT      | PG             | c  |     | b   | a  |
| cite:li-2010-two-dimen-polyp       | DFT      | PG             | b  |     | b   | a  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:tao-2014-tunab-hydrog         | DFT, MD  | PG-ES1         |    |     | b   | a  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:nair-2012-unimp-permeat       | Exp, MD  | Graphene oxide |    | a   |     | b  |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide |    |     | b   | a  |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | b  |     | b   | a  |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide |    |     | b   | a  |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide |    |     | a   | b  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:jiao-2011-graph               | DFT, TST | Graphdiyne     |    |     | b   | a  |

*** Nobel gas separation
He, Ne, Ar, Kr

| Reference                          | Methods  | 2D             | He | Ne | Ar | Kr |
|                                    |          | Material       |    |    |    |    |
|------------------------------------+----------+----------------+----+----+----+----|
| cite:wesołowski-2011-pillar-graph  | MD       | Graphene       | c  |    | b  | a  |
|------------------------------------+----------+----------------+----+----+----+----|
| cite:blankenburg-2010-porous-graph | DFT      | PG             | a  | a  | d  |    |
|------------------------------------+----------+----------------+----+----+----+----|
| cite:zhu-2015-c-n                  | DFT      | C2N            | a  | b  | b  |    |
| cite:li-2015-effic-helium          | DFT, MD  | g-C3N4         | a  | b  | b  |    |

** TODO H2 transport comparison
Use the following works to generate a table with comparisons of H2 transport
- cite:koenig-2012-selec-molec 
- cite:jiang-2009-porous-graph 
- cite:blankenburg-2010-porous-graph

* Scripts
** Toolbox
#+BEGIN_SRC python :tangle devon_toolbox.py
import os
import sys
import numpy as np

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *


def bp(info=None):
    """A breakpoint to view something and stop the rest of the script."""
    if isinstance(info, Atoms):
        view(info)    
    elif isinstance(info, list):
        for i in info:
            print(i)
            print("")
    else:
        print(info)

    sys.exit()


def paint_atoms(atoms, indices, symbol="N"):
    """Update the chemical symbol of atoms in the list of indices."""
    for i in indices:
        atoms[i].symbol = symbol


def make_pore(atoms, indices):
    """Delete atoms at indices to create a pore."""
    for index in sorted(indices, reverse=True):
        del atoms[index]


def status_converged(energy, time):
    print("Final structure calculation: Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(energy, time/60.))


def status_inprogress():
    print("Final structure calculation: In progress.")


def status_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


def set_vacuum(atoms, vacuum):
    """Center atoms in the z-direction in a cell of size vacuum.

    Centers atoms in a unitcell with space above and below of 1/2 * vacuum. Assumes the current unitcell is centered and cell length changes only in the z-direction.
    
    Args:
        atoms (Atoms): Unitcell of atoms
        vacuum (float): Height of new unitcell

    Returns:
        An Atoms object with the new cell height.
    """
    cell = atoms.get_cell()
    center_old = cell[2][2] / 2.
    center_new = vacuum / 2.
    cell[2][2] = vacuum
    atoms.set_cell(cell)

    for atom in atoms:
        atom.position[2] = center_new - (center_old - atom.position[2])


def structure(atoms, layers=1, molecs=0, thresh=2.0):
    """Return lists of the indices of different structures in a unitcell.
    
    Specifically used for my 2D material transport structures to retrieve layers and molecules. Starts from height of z=0 and moves upwards. Note: A k-means algorithm could work well here, but the one currently (2016-06-06) in scipy did not work reliably here due to some randomness. It may be worthwhile to look into it more if we want to define molecules in 3D space.

    Args:
        atoms (Atoms): Unitcell of atoms
        layers (int): Number of layers
        molecs (int): Number of molecules. 0 or 1. >1 not implemented.
        thresh (float): Total height of a layer.

    Returns:
        Dict containing indices of atoms representing layers and molecules.
        
        Example:
        {'layers': [[0, 1, 4, 5], [2, 3, 6, 7]]
         'molecs': [8,9]}
    """
    structure = {}
    structure['layers'] = []
    structure['molecs'] = []
    unaccounted = [atom for atom in atoms]
    
    for layer in range(layers):
        anchor = closest_atom_to_height(unaccounted, 0)

        group = []
        for atom in unaccounted:
            dist = abs(anchor.position[2] - atom.position[2])
            if dist <= thresh:
                group.append(atom)


        indices = [g.index for g in group]
        structure['layers'].append(indices)
        unaccounted = [a for a in unaccounted if a.index not in indices]
    
    if molecs > 0:
        structure['molecs'].append([a.index for a in unaccounted])

    return structure


def closest_atom_to_height(atoms, height):
    """Return the first atom closest to height in the z-direction."""
    closest = atoms[0]
    min_dist = abs(height - closest.position[2])

    for atom in atoms:
        dist = abs(height - atom.position[2])
        if dist < min_dist:
            closest = atom
            min_dist = dist

    return closest


def print_image(name, atoms):
    print(write_image(name, atoms))


def write_image(name, atoms):
    file_path = './img/' + name + '.png'
    directory = file_path[:file_path.rfind('/')]
    if not os.path.exists(directory):
        os.makedirs(directory)
#    atoms.rotate('x', np.pi/-5) # TODO: do a .copy() instead of this
    ase_write(file_path, atoms)
    return '[[' + file_path + ']]'
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

** 2016-03-07: Remote copying
*Note 2016-05-18* - Copying is better done by maintaining the git repo. 

To Gilgamesh:
#+BEGIN_SRC sh
scp ~/Google_Drive/projects/hydrogen2D/hydrogen2D.org devonw@gilgamesh.cheme.cmu.edu:projects/hydrogen2D
#+END_SRC

#+RESULTS:

To host:
#+BEGIN_SRC sh
scp devonw@gilgamesh.cheme.cmu.edu:projects/hydrogen2D/hydrogen2D.org ~/Google_Drive/projects/hydrogen2D
#+END_SRC

To update buffer
#+BEGIN_SRC 
M-x revert-buffer
#+END_SRC

** 2016-05-10: Tramp remote execution
This is a way to run code on a remote server while maintaining the code locally. It works for basic things that have text output. It doesn't work for things like ASE's view, which spawns a gui, and I haven't tried it for running vasp codes (not sure how directories would work out exactly -> may need to use absolute paths).

Check tramp works
#+begin_src sh :dir /devonw@gilgamesh.cheme.cmu.edu: :results output
echo "Executed by `whoami` on `hostname` in `pwd`"
#+end_srC

#+RESULTS:
: Executed by devonw on gilgamesh.cheme.cmu.edu in /home-guest/devonw

Test what $PATH is defined as. May need to copy the remote's path to the tramp path (Don't know why they'd want this to be different except for speed(?)).
#+begin_src sh :dir /ssh:devonw@gilgamesh.cheme.cmu.edu: :results output
#source ~/.bash_profile
#echo $PATH
#source .bash_profile
echo $PATH
#+end_src

#+RESULTS:
: /opt/kitchingroup/vasp-5.3.5/vtstscripts-914:/home-research/jkitchin/bin:/opt/vtk/bin:/opt/kitchingroup/vasp-5.3.5/ase-s16/tools:/opt/kitchingroup/vasp-5.3.5/jasp-s16/jasp/bin:/opt/kitchingroup/vasp-5.3.5/bin:/usr/mpi/intel/openmpi-1.4-qlc/bin:/opt/kitchingroup/CANOPY/Canopy_64bit/User/bin:/opt/maui/bin:/opt/fav/bin:/usr/local/texlive/2012/bin/x86_64-linux:/opt/intel/Compiler/11.1/072/bin/intel64:/opt/intel/impi/4.0.0.028/intel64/bin:/usr/lib64/qt-3.3/bin:/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/usr/share/pvm3/lib:/sbin:/usr/sbin:/usr/local/sbin

Modules are used to load in python code (?). Weird that this doesn't print what it does in shell.
#+begin_src sh :dir /devonw@gilgamesh.cheme.cmu.edu: :results output
source ~/.bash_profile
module list
#+end_src

#+RESULTS:

Test remote execution of a python file. The import statements working is the important part.
#+BEGIN_SRC python :results output :dir /devonw@gilgamesh.cheme.cmu.edu:
import os
from ase import Atoms
import numpy as np
from jasp import *
a = 5
print(a)
#+END_SRC

#+RESULTS:
: 5

Local python test. Unless you've installed ase and jasp locally, this shouln't work but the previous block should have.
#+BEGIN_SRC python :results output
import numpy as np
from ase import Atoms
from jasp import *
a = 5
print(a)
#+END_SRC

#+RESULTS:

** 2016-05-23: Test vasp is working on the server

#+BEGIN_SRC python
import sys

from ase import Atoms, Atom
from ase.structure import molecule
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
JASPRC['queue.walltime'] = '00:30:00'

atoms = molecule('C2H6')
atoms.center(vacuum=4)

ENCUTS = [300]
energies_en = []
forces_en = []
ready = True
for en in ENCUTS:
    job_name = '~/tmp/vasp_test/molecules/c2h6-en-{0}'.format(en)
    with jasp(job_name,
              encut=en,
              xc='PBE',
              atoms=atoms) as calc:
        try:
            energies_en.append(atoms.get_potential_energy())
            forces_en.append(atoms.get_forces())
        except (VaspSubmitted, VaspQueued):
            ready = False
            print("Still processing: {}".format(job_name))

if not ready:
    import sys; sys.exit()

print("{0:5s}    {1:7s}    {2:9s}".format("ENCUT", "Energy", "Max force"))
print("{0:5s}    {1:7s}    {2:9s}".format("", "[eV]", "[eV/Ang]"))
print("-----------------------------")
for i, energy, force in zip(ENCUTS, energies_en, forces_en):
    print("{0:5d}    {1:7.3f}    {2:9.3f}".format(i, energy, force.max()))
#+END_SRC

#+RESULTS:
: Still processing: ~/tmp/vasp_test/molecules/c2h6-en-300

** TODO Better movies

** 2016-05-31: View atoms
#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
    
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]

def view_atoms(name):
    images = []
    for i, h in enumerate(heights):
	with jasp('./dft/' + name + '/d={0:0.2f}'.format(h)) as calc:
	    atoms = calc.get_atoms()
	    images.append(atoms)
    view(images)

base_name = 'transport/g-mono/3x3/pore=1/molec=CO2/'

name_free = base_name + 'linear-unconst_all'
#view_atoms(name_free)

name_uncon = base_name + 'linear-unconst_G'
#view_atoms(name_uncon)

name_con = base_name + 'linear-const'
view_atoms(name_con)
#+END_SRC

#+RESULTS:

** TODO 2016-06-02: Improve energy curve resolution at curves
Suggest more points to improve the resolution of a total energy curve for a transporting molecule through a 2D material plane.

#+BEGIN_SRC python


#+END_SRC

* DFT
** Parameters
- Vaccuum space between gas and 

** Material
*** Graphene monolayer
**** Pristine

#+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

name = 'material/g-mono/final'

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Final structure calculation: Atoms: 2. Energy/f.u. = -9.228. Calculation time: 6 min.
[[./img/material/g-mono/final.png]]
:END:

**** Pore=1 (One carbon defect)
***** DONE 3x3. Non-centered, standard spacing
      CLOSED: [2016-06-02 Thu 14:44]
Looking back, the non-centered versions of these calculations are not as intuitive to watch in a movie format. Also, the desired ease of having the symmetry point being at the gamma point does not carry to pore sizes greater than 1.

#+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys
#JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 3
atoms = unitcell.repeat((i,i,1))

print('Graphene 3x3 pore=1:'.format(i))

del atoms[0]

name = 'material/g-mono/3x3/pore=1/non-centered/vac=10'

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Graphene 3x3 pore=1:
Final structure calculation: Atoms: 17. Energy/f.u. = -8.759. Calculation time: 188 min.
[[./img/material/g-mono/3x3/pore=1/non-centered/vac=10.png]]
:END:

***** DONE 3x3. Non-centered, wide vaccuum
      CLOSED: [2016-06-02 Thu 14:43]
Looking back, it doesn't really make sense to run these calculations with a vacuum any wider than the distance where planes of the superstructure do not interact.

#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *

import devon_toolbox as dtb


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 20.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 3
atoms = unitcell.repeat((i,i,1))

print('Graphene 3x3 pore=1:'.format(i))

del atoms[0]

name = 'material/g-mono/3x3/pore=1/non-centered/vac=20'
print(dtb.write_image(name, atoms))

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=100,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass
#+END_SRC

#+RESULTS:
:RESULTS:
Graphene 3x3 pore=1:
[[./img/material/g-mono/3x3/pore=1/non-centered/vac=20.png]]
Final structure calculation: Energy/f.u. = -8.760. Calculation time: 589 min.
:END:

***** DONE 3x3. Centered
      CLOSED: [2016-06-02 Thu 14:44]
Based on the gas transport graph, a distance of 8 Angstrom between graphene planes should be more than sufficient to say the planes are not interacting. 

#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'

import devon_toolbox as dtb


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 8.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 3
atoms = atoms.repeat((i,i,1))

print("Position of defect: {}".format(atoms[9].position))
del atoms[9]

name = 'material/g-mono/3x3/pore=1/final'
dtb.print_image(name, atoms)

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=100,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass
#+END_SRC

#+RESULTS:
:RESULTS:
Position of defect: [ 5.681  0.     4.   ]
[[./img/material/g-mono/3x3/pore=1/final.png]]
Final structure calculation: Energy/f.u. = -8.759. Calculation time: 207 min.
:END:

As expected, the energy is the same as the energies of the non-centered calculations.

***** TODO 4x4, 5x5, 6x6
****** TODO Same kpts
Calculate the energies for a monolayer of graphene with a single carbon pore for larger unitcells (more spacing between the pores).

#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '4GB'

import devon_toolbox as dtb


def calculate(name):
    ready = True
    with jasp('./dft/' + name,
                encut=520,
                kpts=(3,3,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=0,             # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            dtb.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            dtb.status_inprogress()
            ready = False
            pass

    return ready


with jasp("dft/material/g-mono/final") as calc:
    graphene = calc.get_atoms()

sizes = [2, 3, 4, 5, 6]
pores = [6, 9, 20, 24, 29]


for i, p in zip(sizes, pores):
    atoms = graphene.copy()
    atoms = atoms.repeat((i,i,1))
    dtb.make_pore(atoms, [p])

    print("size={0}x{0}".format(i))
    name = 'material/g-mono/{0:0.0f}x{0:0.0f}/pore=1/convergence/size'.format(i)
    dtb.print_image(name, atoms)
    calculate(name)
#+END_SRC

#+RESULTS:
:RESULTS:
size=2x2
[[./img/material/g-mono/2x2/pore=1/convergence/size.png]]
Final structure calculation: Energy/f.u. = -8.139. Calculation time: 3 min.
size=3x3
[[./img/material/g-mono/3x3/pore=1/convergence/size.png]]
Final structure calculation: Energy/f.u. = -8.743. Calculation time: 16 min.
size=4x4
[[./img/material/g-mono/4x4/pore=1/convergence/size.png]]
Errors found:
Ions/cell Converged: True

Final structure calculation: Energy/f.u. = -8.959. Calculation time: 87 min.
size=5x5
[[./img/material/g-mono/5x5/pore=1/convergence/size.png]]
Final structure calculation: In progress.
size=6x6
[[./img/material/g-mono/6x6/pore=1/convergence/size.png]]
Final structure calculation: In progress.
:END:

****** TODO kpts differing by size
Calculate the energies for a monolayer of graphene with a single carbon pore for larger unitcells (more spacing between the pores).

#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '4GB'

import devon_toolbox as dtb


def calculate(name, k):
    ready = True
    with jasp('./dft/' + name,
                encut=520,
                kpts=(k,k,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=0,             # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            dtb.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            dtb.status_inprogress()
            ready = False
            pass

    return ready


with jasp("dft/material/g-mono/final") as calc:
    graphene = calc.get_atoms()

sizes = [2, 3, 4, 5, 6]
pores = [6, 9, 20, 24, 29]
kpts =  [5, 5, 5, 1, 1]

for i, p, k in zip(sizes, pores, kpts):
    atoms = graphene.copy()
    atoms = atoms.repeat((i,i,1))
    dtb.make_pore(atoms, [p])

    print("size={0}x{0}".format(i))
    name = 'material/g-mono/{0:0.0f}x{0:0.0f}/pore=1/convergence/size/kpts={1:0.0f}'.format(i, k)
    dtb.print_image(name, atoms)
    calculate(name, k)
#+END_SRC

#+RESULTS:
:RESULTS:
size=2x2
[[./img/material/g-mono/2x2/pore=1/convergence/size/kpts=5.png]]
Final structure calculation: In progress.
size=3x3
[[./img/material/g-mono/3x3/pore=1/convergence/size/kpts=5.png]]
Final structure calculation: In progress.
size=4x4
[[./img/material/g-mono/4x4/pore=1/convergence/size/kpts=5.png]]
Final structure calculation: In progress.
size=5x5
[[./img/material/g-mono/5x5/pore=1/convergence/size/kpts=1.png]]
Final structure calculation: In progress.
size=6x6
[[./img/material/g-mono/6x6/pore=1/convergence/size/kpts=1.png]]
Final structure calculation: In progress.
:END:

**** Pore=10 (Ten carbon defect)
***** DONE 4x4
      CLOSED: [2016-06-02 Thu 14:47]
#+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys
#JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 20.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 4
atoms = unitcell.repeat((i,i,1))

print('Graphene 4x4 pore=10:'.format(i))
del atoms[26]
del atoms[17:21]
del atoms[11:15]
del atoms[5]

name = 'material/g-mono/4x4/pore=10/vac=16'

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms.repeat((3,3,1)))
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Graphene 4x4 pore=10:
Final structure calculation: Atoms: 22. Energy/f.u. = -8.167. Calculation time: 1933 min.
[[./img/material/g-mono/4x4/pore=10/vac=16.png]]
:END:

***** TODO 5x5
****** DONE final
       CLOSED: [2016-06-08 Wed 15:42]
#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
JASPRC['queue.mem'] = '4GB'

import devon_toolbox as dtb


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 5
atoms = unitcell.repeat((i,i,1))

print('Graphene 5x5 pore=10:'.format(i))
del atoms[32:35]
del atoms[23:27]
del atoms[15:18]

name = 'material/g-mono/5x5/pore=10/final'

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=0,             # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass

dtb.print_image(name, atoms)
#+END_SRC

#+RESULTS:
:RESULTS:
Graphene 5x5 pore=10:
Final structure calculation: Energy/f.u. = -8.604. Calculation time: 2933 min.
[[./img/material/g-mono/5x5/pore=10/final.png]]
:END:

****** TODO Convergence: kpts

#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '4GB'

import devon_toolbox as dtb


with jasp("dft/material/g-mono/final") as calc:
    atoms = calc.get_atoms()

i = 5
atoms = atoms.repeat((i,i,1))

print('Graphene 5x5 pore=10:'.format(i))
del atoms[32:35]
del atoms[23:27]
del atoms[15:18]


kpts = [1, 3, 5]

name = 'material/g-mono/5x5/pore=10/convergence'
dtb.print_image(name, atoms)

def calculate(k):
    with jasp('./dft/' + name + '/kpts={0:0.0f}'.format(k),
                encut=520,
                kpts=(k,k,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=0,             # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            dtb.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            dtb.status_inprogress()
            ready = False
            pass

for k in kpts:
    print("kpts={0}x{0}x1".format(k))
    calculate(k)
#+END_SRC

#+RESULTS:
:RESULTS:
Graphene 5x5 pore=10:
[[./img/material/g-mono/5x5/pore=10/convergence.png]]
kpts=1x1x1
Final structure calculation: Energy/f.u. = -8.580. Calculation time: 96 min.
kpts=3x3x1
Final structure calculation: In progress.
kpts=5x5x1
Final structure calculation: In progress.
:END:

***** TODO 6x6
Note the k-point grid in this case has been changed from 6x6x1 to 1x1x1.

#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '8GB'

import devon_toolbox as dtb


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")

with jasp('dft/material/g-mono/final') as calc:
    atoms = calc.get_atoms()
dtb.set_vacuum(atoms, 16)
i = 6
atoms = atoms.repeat((i,i,1))
pore = [19, 29, 30, 31, 32, 39, 40, 41, 42, 52]
dtb.make_pore(atoms, pore)

print('Graphene {0:1.1f}x{0:1.1f} pore=10:'.format(i))

name = 'material/g-mono/6x6/pore=10/vac=16/kpts=1'
dtb.print_image(name, atoms)

with jasp('./dft/' + name,
            encut=520,
            kpts=(1,1,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass

#+END_SRC

#+RESULTS:
:RESULTS:
Graphene 6.0x6.0 pore=10:
[[./img/material/g-mono/6x6/pore=10/vac=16/kpts=1.png]]
Final structure calculation: In progress.
:END:

*** Graphene bilayer
**** DONE Pristine
     CLOSED: [2016-06-02 Thu 14:42]
Structure obtained from https://www.tfkp.physik.uni-erlangen.de/download/theses/master_daniel-branski.pdf.

#+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

name = 'material/g-bi/final'

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Final structure calculation: Atoms: 4. Energy/f.u. = -9.225. Calculation time: 14 min.
[[./img/material/g-bi/final.png]]
:END:

**** TODO Pore=1

***** DONE 3x3
      CLOSED: [2016-06-08 Wed 16:55]

#+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

i = 3
atoms = atoms.repeat([i,i,1])
del atoms[17:19]

name = 'material/g-bi/3x3/pore=1'

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=150,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Final structure calculation: Atoms: 34. Energy/f.u. = -8.759. Calculation time: 277 min.
[[./img/material/g-bi/3x3/pore=1.png]]
:END:

***** TODO 4x4

#+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from jasp import *

import devon_toolbox as dtb


with jasp('dft/material/g-bi/final') as calc:
    atoms = calc.get_atoms()
dtb.set_vacuum(atoms, 16)
i = 4
atoms = atoms.repeat([i,i,1])
pore = [41, 42]
dtb.make_pore(atoms, pore)

name = 'material/g-bi/{0:0.0f}x{0:0.0f}/pore=1'.format(i)
dtb.print_image(name, atoms)

with jasp('./dft/' + name,
            encut=520,
            kpts=(3,3,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass
#+END_SRC

#+RESULTS:
:RESULTS:
[[./img/material/g-bi/4x4/pore=1.png]]
Final structure calculation: In progress.
:END:

**** TODO Pore=1 nsw test

#+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *

import devon_toolbox as dtb


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

i = 3
atoms = atoms.repeat([i,i,1])
del atoms[17:19]

nsw = [0]
print("Did not converge: [10]")

def calculate(nsw):
    name = 'material/g-bi/3x3/pore=1/test/nsw={:0.0f}'.format(nsw)
    dtb.print_image(name, atoms)

    with jasp('./dft/' + name,
                encut=520,
                kpts=(6,6,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=nsw,             # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            dtb.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            dtb.status_inprogress()
            ready = False
            pass


for n in nsw:
    print("nsw: {:}".format(n))
    calculate(n)
#+END_SRC

#+RESULTS:
:RESULTS:
Did not converge: [10]
nsw: 0
[[./img/material/g-bi/3x3/pore=1/test/nsw=0.png]]
Final structure calculation: Energy/f.u. = -8.742. Calculation time: 308 min.
:END:

The calculation did not converge for nsw=10 (probably should have expected).

**** TODO Pore=10
***** Final

#+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
JASPRC['queue.mem'] = '8GB'

import devon_toolbox as dtb


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 16. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

i = 6
atoms = atoms.repeat([i,i,1])

pore_l1 = [57, 60, 61, 80, 81, 84, 85, 104, 105, 108]
pore_l2 = [35, 38, 39, 58, 59, 62, 63, 82, 83, 86]
pore = pore_l1 + pore_l2
pore.sort()
for p in reversed(pore):
#    atoms[p].symbol = "N"
    del atoms[p]


name = 'material/g-bi/6x6/pore=10/final'
dtb.print_image(name, atoms)

with jasp('./dft/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=100,           # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass
#+END_SRC

#+RESULTS:
:RESULTS:
[[./img/material/g-bi/6x6/pore=10/final.png]]
Final structure calculation: In progress.
:END:

***** Kpts test

#+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
JASPRC['queue.mem'] = '8GB'

import devon_toolbox as dtb


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 16. # vaccuum height between material planes

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

i = 6
atoms = atoms.repeat([i,i,1])

pore_l1 = [57, 60, 61, 80, 81, 84, 85, 104, 105, 108]
pore_l2 = [35, 38, 39, 58, 59, 62, 63, 82, 83, 86]
pore = pore_l1 + pore_l2
pore.sort()
for p in reversed(pore):
#    atoms[p].symbol = "N"
    del atoms[p]


name = 'material/g-bi/6x6/pore=10'
dtb.print_image(name, atoms)

kpts = [3, 5] 
print("Failed to complete: [1, 2, 4, 7]")

def calculate(k):
    with jasp('./dft/' + name + '/kpts={:0.0f}'.format(k),
                encut=520,
                kpts=(k,k,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=100,           # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            dtb.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            dtb.status_inprogress()
            ready = False
            pass

for k in kpts:
    print("kpts=({0},{0},1):".format(k))
    calculate(k)
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

| k-points (ixix1) | Memory requested [GB] |
|                1 |                   0.9 |
|                2 |                   3.0 |
|                3 |                   2.5 |
|                4 |                  10.4 |
|                5 |                   5.9 |
|                6 |                  22.9 |
|                7 |                  10.8 |

***** Minimal resource use
Run a calculation with the least possible resources. It's okay if the energy is a poor calculation, let's just see if time-wise this type of calculation is feasible.

Some notes
- sigma for bi-layer smaller than monolayer 


#+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '2GB'

import devon_toolbox as dtb


with jasp('dft/material/g-bi/final') as calc:
    atoms = calc.get_atoms()
dtb.set_vacuum(atoms, 16)
i = 6
atoms = atoms.repeat([i,i,1])

pore_l1 = [57, 60, 61, 80, 81, 84, 85, 104, 105, 108]
pore_l2 = [35, 38, 39, 58, 59, 62, 63, 82, 83, 86]
pore = pore_l1 + pore_l2
dtb.make_pore(atoms, pore)


name = 'material/g-bi/6x6/pore=10/convergence/minimal'
dtb.print_image(name, atoms)

with jasp('./dft/' + name,
            encut=350,
            kpts=(1,1,1),
            xc='LDA',
            ismear=0,
            sigma=0.2,
            isif=2,
            ibrion=1,
            nsw=50,
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

** Transport
*** Graphene monolayer
**** TODO Linear NEB
***** TODO H2 linear-const-const

#+BEGIN_SRC python :results drawer
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

import devon_toolbox as dtb


def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('dft/material/g-mono/3x3/pore=1/final') as calc:
    graphene = calc.get_atoms()

dtb.set_vacuum(graphene, 20)
defect_pos = np.array([5.681, 0., 10.]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
#heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2.]
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1.5, -2.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
HH_bond = 0.74 # Bond length [Ang]
for i, h in enumerate(heights):
    H2 = Atoms([Atom('H', defect_pos + (0, 0, h - HH_bond/2.)),
                Atom('H', defect_pos + (0, 0, h + HH_bond/2.))])
    atoms[i].extend(H2)


# Hydrogen fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'H':
        hydrogen_constraint = [FixAtoms(indices=[atom.index])]
        break


# Graphene total constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Unconstrained graphene, unconstrained molecule
# Constraint one carbon so the entire plane doesn't shift as the molecule approaches
atoms_free = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_free[i].set_constraint([FixAtoms(indices=[0])])

# Unconstrained graphene, constrained molecule
atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(hydrogen_constraint)

# Constrained graphene, constrained molecule
atoms_con = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_con[i].set_constraint(hydrogen_constraint + graphene_constraint)

ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./dft/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/'

print('Unconstrained graphene, unconstrained hydrogen:')
name_free = base_name + 'linear-free-free'
TE_free = []
calculate(name_free, atoms_free, TE_free)

#print('')
#print('Unconstrained graphene, constrained leading hydrogen:')
#name_uncon = base_name + 'linear-free-const'
#TE_uncon = []
#calculate(name_uncon, atoms_uncon, TE_uncon)

print('')
print('Constrained graphene, constrained leading hydrogen:')
name_con = base_name + 'linear-const-const'
TE_con = []
calculate(name_con, atoms_con, TE_con)

if not ready:
    sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
#TE_uncon = np.array(TE_uncon)
#TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(-2,10,200)
    plt.plot(x_lin, spline(x_lin), style)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
spline_free = interp1d(heights, TE_free, kind='cubic')
plt.plot(heights, TE_free, 'ro', label='No constraints')
#plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
#plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Center of molecule height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Unconstrained graphene, unconstrained hydrogen:
Distance: 10.00. Energy = -155.683. Calculation time: 807 min.
Distance:  9.00. Energy = -155.683. Calculation time: 811 min.
Distance:  8.00. Energy = -155.683. Calculation time: 422 min.
Distance:  7.00. Energy = -155.684. Calculation time: 421 min.
Distance:  6.00. Energy = -155.684. Calculation time: 582 min.
Distance:  5.00. Energy = -155.687. Calculation time: 582 min.
Distance:  4.00. Energy = -155.695. Calculation time: 307 min.
Distance:  3.00. Energy = -155.690. Calculation time: 299 min.
Distance:  2.50. Energy = -155.681. Calculation time: 1802 min.
Distance:  2.00. Energy = -155.707. Calculation time: 2886 min.
Distance:  1.50. Energy = -155.696. Calculation time: 2803 min.
Distance:  1.00. Energy = -158.272. Calculation time: 6159 min.
Distance:  0.50. Energy = -158.278. Calculation time: 5042 min.
Distance:  0.00. Energy = -155.239. Calculation time: 1338 min.
Distance: -0.50. Energy = -158.278. Calculation time: 5150 min.
Distance: -1.50. Energy = -155.695. Calculation time: 3496 min.
Distance: -2.00. Energy = -155.671. Calculation time: 2967 min.

Constrained graphene, constrained leading hydrogen:
Distance: 10.00. Energy = -155.683. Calculation time: 484 min.
Distance:  9.00. Energy = -155.683. Calculation time: 574 min.
Distance:  8.00. Energy = -155.683. Calculation time: 834 min.
Distance:  7.00. Energy = -155.684. Calculation time: 415 min.
Distance:  6.00. Energy = -155.684. Calculation time: 849 min.
Distance:  5.00. Energy = -155.687. Calculation time: 622 min.
Distance:  4.00. Energy = -155.695. Calculation time: 587 min.
Distance:  3.00. Energy = -155.690. Calculation time: 757 min.
Distance:  2.50. Energy = -155.611. Calculation time: 1040 min.
Distance:  2.00. Energy = -155.283. Calculation time: 981 min.
Distance:  1.50. Energy = -154.461. Calculation time: 1070 min.
Distance:  1.00. Energy = -153.815. Calculation time: 508 min.
Distance:  0.50. Energy = -154.247. Calculation time: 515 min.
Distance:  0.00. Energy = -154.990. Calculation time: 509 min.
Distance: -0.50. Energy = -155.130. Calculation time: 787 min.
Distance: -1.50. Energy = -154.380. Calculation time: 464 min.
Distance: -2.00. Energy = -155.269. Calculation time: 477 min.

[[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison.png]]
:END:

The free-free calculation did not converge at a molecule height of -1.0 Ang.

**** DONE 3x3 pore=1 - linear
     CLOSED: [2016-06-08 Wed 16:41]
This is the type of transport I used for the final project in 0640. Essentially, I believe it tries to simulate an ab-initio MD calculation, which I need to look into.

Pros:
- Better than a L-J MD at each point.

Cons:
- This should be setup as a NEB calculation
- Meaningful calculations are too costly.
- Pore distances must be kept small.

***** DONE H2
      CLOSED: [2016-06-08 Wed 16:00]

Somewhat done for now. The unconstrained graphene + constrained H2 molecule calculations did not finish in time. Unfortunately, that is the one that would be most accurate to what is really going on with the transport.

#+BEGIN_SRC python :results drawer
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

import devon_toolbox as dtb


def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('dft/material/g-mono/3x3/pore=1/final') as calc:
    graphene = calc.get_atoms()

dtb.set_vacuum(graphene, 20)
defect_pos = np.array([5.681, 0., 10.]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
#heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2.]
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1.5, -2.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
HH_bond = 0.74 # Bond length [Ang]
for i, h in enumerate(heights):
    H2 = Atoms([Atom('H', defect_pos + (0, 0, h - HH_bond/2.)),
                Atom('H', defect_pos + (0, 0, h + HH_bond/2.))])
    atoms[i].extend(H2)


# Hydrogen fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'H':
        hydrogen_constraint = [FixAtoms(indices=[atom.index])]
        break


# Graphene total constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Unconstrained graphene, unconstrained molecule
# Constraint one carbon so the entire plane doesn't shift as the molecule approaches
atoms_free = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_free[i].set_constraint([FixAtoms(indices=[0])])

# Unconstrained graphene, constrained molecule
atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(hydrogen_constraint)

# Constrained graphene, constrained molecule
atoms_con = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_con[i].set_constraint(hydrogen_constraint + graphene_constraint)

ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./dft/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/'

print('Unconstrained graphene, unconstrained hydrogen:')
name_free = base_name + 'linear-free-free'
TE_free = []
calculate(name_free, atoms_free, TE_free)

#print('')
#print('Unconstrained graphene, constrained leading hydrogen:')
#name_uncon = base_name + 'linear-free-const'
#TE_uncon = []
#calculate(name_uncon, atoms_uncon, TE_uncon)

print('')
print('Constrained graphene, constrained leading hydrogen:')
name_con = base_name + 'linear-const-const'
TE_con = []
calculate(name_con, atoms_con, TE_con)

if not ready:
    sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
#TE_uncon = np.array(TE_uncon)
#TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(-2,10,200)
    plt.plot(x_lin, spline(x_lin), style)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
spline_free = interp1d(heights, TE_free, kind='cubic')
plt.plot(heights, TE_free, 'ro', label='No constraints')
#plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
#plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Center of molecule height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Unconstrained graphene, unconstrained hydrogen:
Distance: 10.00. Energy = -155.683. Calculation time: 807 min.
Distance:  9.00. Energy = -155.683. Calculation time: 811 min.
Distance:  8.00. Energy = -155.683. Calculation time: 422 min.
Distance:  7.00. Energy = -155.684. Calculation time: 421 min.
Distance:  6.00. Energy = -155.684. Calculation time: 582 min.
Distance:  5.00. Energy = -155.687. Calculation time: 582 min.
Distance:  4.00. Energy = -155.695. Calculation time: 307 min.
Distance:  3.00. Energy = -155.690. Calculation time: 299 min.
Distance:  2.50. Energy = -155.681. Calculation time: 1802 min.
Distance:  2.00. Energy = -155.707. Calculation time: 2886 min.
Distance:  1.50. Energy = -155.696. Calculation time: 2803 min.
Distance:  1.00. Energy = -158.272. Calculation time: 6159 min.
Distance:  0.50. Energy = -158.278. Calculation time: 5042 min.
Distance:  0.00. Energy = -155.239. Calculation time: 1338 min.
Distance: -0.50. Energy = -158.278. Calculation time: 5150 min.
Distance: -1.50. Energy = -155.695. Calculation time: 3496 min.
Distance: -2.00. Energy = -155.671. Calculation time: 2967 min.

Constrained graphene, constrained leading hydrogen:
Distance: 10.00. Energy = -155.683. Calculation time: 484 min.
Distance:  9.00. Energy = -155.683. Calculation time: 574 min.
Distance:  8.00. Energy = -155.683. Calculation time: 834 min.
Distance:  7.00. Energy = -155.684. Calculation time: 415 min.
Distance:  6.00. Energy = -155.684. Calculation time: 849 min.
Distance:  5.00. Energy = -155.687. Calculation time: 622 min.
Distance:  4.00. Energy = -155.695. Calculation time: 587 min.
Distance:  3.00. Energy = -155.690. Calculation time: 757 min.
Distance:  2.50. Energy = -155.611. Calculation time: 1040 min.
Distance:  2.00. Energy = -155.283. Calculation time: 981 min.
Distance:  1.50. Energy = -154.461. Calculation time: 1070 min.
Distance:  1.00. Energy = -153.815. Calculation time: 508 min.
Distance:  0.50. Energy = -154.247. Calculation time: 515 min.
Distance:  0.00. Energy = -154.990. Calculation time: 509 min.
Distance: -0.50. Energy = -155.130. Calculation time: 787 min.
Distance: -1.50. Energy = -154.380. Calculation time: 464 min.
Distance: -2.00. Energy = -155.269. Calculation time: 477 min.

[[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison.png]]
:END:

The free-free calculation did not converge at a molecule height of -1.0 Ang.

***** DONE N2
      CLOSED: [2016-06-08 Wed 16:05]

Only ran the       


#+BEGIN_SRC python
import copy
import numpy as np
import matplotlib.pyplot as plt
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('dft/material/g-mono/3x3/pore=1/non-centered/vac=20') as calc:
    graphene = calc.get_atoms()
plane_height = 10.
defect_pos = np.array([0, 0., plane_height]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
bond1 = 1.13 # Bond length [Ang]
for i, h in enumerate(heights):
    N2 = Atoms([Atom('N', defect_pos + (0, 0, h - bond1/2.)),
                Atom('N', defect_pos + (0, 0, h + bond1/2.))])
    atoms[i].extend(N2)


# Fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'N':
        molecule_constraint = [FixAtoms(indices=[atom.index])]
        break

# Graphene constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Make images with constraints
atoms_free = copy.deepcopy(atoms)

atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(molecule_constraint)

atoms_con = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_con[i].set_constraint(molecule_constraint + graphene_constraint)

ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./dft/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=N2/'

#print('Unconstrained graphene, unconstrained hydrogen:')
#name_free = base_name + 'linear-unconst_all'
#TE_free = []
#calculate(name_free, atoms_free, TE_free)
#
#print('')
#print('Unconstrained graphene, constrained leading hydrogen:')
#name_uncon = base_name + 'linear-unconst_G'
#TE_uncon = []
#calculate(name_uncon, atoms_uncon, TE_uncon)

print('')
print('Constrained graphene, constrained leading atom:')
name_con = base_name + 'linear-const'
TE_con = []
calculate(name_con, atoms_con, TE_con)

if not ready:
    sys.exit()
sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
TE_uncon = np.array(TE_uncon)
TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.plot(heights, TE_free, label='No constraints')
plt.plot(heights, TE_uncon, label='Leading H atom constrained')
plt.plot(heights, TE_con, label='All constrained')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:

***** DONE CO2
      CLOSED: [2016-06-08 Wed 16:05]

#+BEGIN_SRC python
import copy
import numpy as np
import matplotlib.pyplot as plt
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('dft/material/g-mono/3x3/pore=1/vac=20') as calc:
    graphene = calc.get_atoms()
plane_height = 10.
defect_pos = np.array([0, 0., plane_height]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]
CO_bond = 1.21 # Bond length [Ang]
atoms =  [Atoms(graphene) for i in range(len(heights))]
for i, h in enumerate(heights):
    CO2 = Atoms([Atom('O', defect_pos + (0., 0., h - CO_bond)),
                 Atom('C', defect_pos + (0., 0., h)),
                 Atom('O', defect_pos + (0., 0., h + CO_bond))])
    atoms[i].extend(CO2)

# Fixed position constraint
for i, atom in enumerate(atoms[0]):
    if atom.symbol == 'O':
        molecule_constraint = [FixAtoms(indices=[atom.index+1])]
        break

# Graphene constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Make images with constraints
atoms_free = copy.deepcopy(atoms)

atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(molecule_constraint)

atoms_con = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_con[i].set_constraint(molecule_constraint + graphene_constraint)


ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./dft/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=CO2/'

print('Unconstrained graphene, unconstrained molecule:')
name_free = base_name + 'linear-unconst_all'
TE_free = []
calculate(name_free, atoms_free, TE_free)

print('')
print('Unconstrained graphene, constrained CO2 carbon:')
name_uncon = base_name + 'linear-unconst_G'
TE_uncon = []
calculate(name_uncon, atoms_uncon, TE_uncon)

print('')
print('Constrained graphene, constrained CO2 carbon:')
name_con = base_name + 'linear-const'
TE_con = []
calculate(name_con, atoms_con, TE_con)

if not ready:
    sys.exit()
sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
TE_uncon = np.array(TE_uncon)
TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.plot(heights, TE_free, label='No constraints')
plt.plot(heights, TE_uncon, label='Leading H atom constrained')
plt.plot(heights, TE_con, label='All constrained')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
#+begin_example
Unconstrained graphene, unconstrained molecule:
Distance: 10.00. Energy = -171.861. Calculation time: 387 min.
Distance:  9.00. Energy = -171.861. Calculation time: 604 min.
Distance:  8.00. Energy = -171.861. Calculation time: 556 min.
Distance:  7.00. Energy = -171.861. Calculation time: 339 min.
Distance:  6.00. Energy = -171.861. Calculation time: 347 min.
Distance:  5.00. Energy = -171.863. Calculation time: 381 min.
Distance:  4.00. Energy = -171.803. Calculation time: 355 min.
Distance:  3.00. Energy = -171.800. Calculation time: 2632 min.
Distance:  2.50. Energy = -171.741. Calculation time: 4954 min.
Distance:  2.00. Energy = -171.777. Calculation time: 4830 min.
Distance:  1.50. Energy = -173.486. Calculation time: 2459 min.
Distance:  1.00. Energy = -172.259. Calculation time: 1947 min.
Distance:  0.50. Energy = -172.258. Calculation time: 2127 min.
Distance:  0.00. Energy = -170.043. Calculation time: 1282 min.

Unconstrained graphene, constrained CO2 carbon:
Distance: 10.00. Energy = -171.861. Calculation time: 265 min.
Distance:  9.00. Energy = -171.861. Calculation time: 277 min.
Distance:  8.00. Energy = -171.861. Calculation time: 291 min.
Distance:  7.00. Energy = -171.861. Calculation time: 275 min.
Distance:  6.00. Energy = -171.861. Calculation time: 267 min.
Distance:  5.00. Energy = -171.863. Calculation time: 284 min.
Distance:  4.00. Energy = -171.803. Calculation time: 273 min.
Distance:  3.00. Energy = -171.757. Calculation time: 2732 min.
Distance:  2.50. Energy = -171.796. Calculation time: 4690 min.
Distance:  2.00. Energy = -171.787. Calculation time: 4402 min.
Distance:  1.50. In progress.
Distance:  1.00. Energy = -172.244. Calculation time: 814 min.
Distance:  0.50. Energy = -172.256. Calculation time: 2039 min.
Distance:  0.00. Energy = -170.043. Calculation time: 786 min.

Constrained graphene, constrained CO2 carbon:
Distance: 10.00. Energy = -171.861. Calculation time: 300 min.
Distance:  9.00. Energy = -171.861. Calculation time: 303 min.
Distance:  8.00. Energy = -171.861. Calculation time: 325 min.
Distance:  7.00. Energy = -171.861. Calculation time: 323 min.
Distance:  6.00. Energy = -171.861. Calculation time: 313 min.
Distance:  5.00. Energy = -171.863. Calculation time: 318 min.
Distance:  4.00. Energy = -171.803. Calculation time: 215 min.
Distance:  3.00. Energy = -170.736. Calculation time: 249 min.
Distance:  2.50. Energy = -168.686. Calculation time: 247 min.
Distance:  2.00. Energy = -166.160. Calculation time: 122 min.
Distance:  1.50. Energy = -171.428. Calculation time: 432 min.
Distance:  1.00. Energy = -171.304. Calculation time: 306 min.
Distance:  0.50. Energy = -170.840. Calculation time: 504 min.
Distance:  0.00. Energy = -169.706. Calculation time: 424 min.
#+end_example

* Results
** TODO Final project
*** Bond length

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

fp_dir = '~/techela/s16-06640/final-project/' # Directory of final project.

# Distance of the molecule normal to the graphene plane
heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]

# Calculated distance after relaxation
h_rel = []

BL_h = []
BL_co2 = [[], []]
for i, h in enumerate(heights):

    with jasp(fp_dir + 'transport/G-c-HHc-constraints-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        bond_dist = atoms.get_distance(17,18)
        BL_h.append(bond_dist)
        h_fixed = atoms[17].position[2]
        h_graphene = atoms[0].position[2]
        h_rel_i = h_fixed + (bond_dist / 2.) - h_graphene
        h_rel.append(h_rel_i)

    with jasp(fp_dir + 'transport/G-c-CO2-transport-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        BL_co2[0].append(atoms.get_distance(17,18))
        BL_co2[1].append(atoms.get_distance(18,19))


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(x[0],x[-1],200)
    plt.plot(x_lin, spline(x_lin), style)

file_path = './img/final-project/G-bond-length.png'
plt.plot(h_rel, BL_h, 'ro', label='H2')
plt.plot(heights, BL_co2[0], 'go', label='CO2 #1')
plt.plot(heights, BL_co2[1], 'bo', label='CO2 #2')
plot_spline(h_rel, BL_h, plt, 'r-')
plot_spline(heights, BL_co2[0], plt, 'g-')
plot_spline(heights, BL_co2[1], plt, 'b-')
plt.xlabel('Molecule distance from graphene plane ($\AA$)')
plt.ylabel('Bond length ($\AA$)')
plt.ylim([0.5,3])
plt.xlim([-3,3])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
: [[./img/final-project/G-bond-length.png]]

*** Barrier energy

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

fp_dir = '~/techela/s16-06640/final-project/' # Directory of final project.

# Distance of the molecule normal to the graphene plane
heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]

# Calculated distance after relaxation
h_rel = []

TE_h = []
TE_co2 = []
for i, h in enumerate(heights):

    with jasp(fp_dir + 'transport/G-c-HHc-constraints-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        energy = atoms.get_potential_energy()
        TE_h.append(energy)
        bond_dist = atoms.get_distance(17,18)
        h_fixed = atoms[17].position[2]
        h_graphene = atoms[0].position[2]
        h_rel_i = h_fixed + (bond_dist / 2.) - h_graphene
        h_rel.append(h_rel_i)

    with jasp(fp_dir + 'transport/G-c-CO2-transport-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        energy = atoms.get_potential_energy()
        TE_co2.append(energy)

TE_h = np.array(TE_h)
TE_h -= min(TE_h)
TE_co2 = np.array(TE_co2)
TE_co2 -= min(TE_co2)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(x[0],x[-1],200)
    print('Max energy: {:0.3f} eV'.format(max(spline(x_lin)))) 
    plt.plot(x_lin, spline(x_lin), style)

print('')
print('Energy barriers:')
file_path = './img/final-project/total_energy-comparison.png'
plt.plot(h_rel, TE_h, 'ro', label='H2')
plt.plot(heights, TE_co2, 'go', label='CO2')
plot_spline(h_rel, TE_h, plt, 'r-')
plot_spline(heights, TE_co2, plt, 'g-')
plt.xlabel('Molecule distance from graphene plane ($\AA$)')
plt.ylabel('$\Delta$ Energy (eV)')
plt.xlim([-3.,3.])
plt.ylim([0,5.5])
plt.legend(loc='upper center')
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
: 
: Energy barriers:
: Max energy: 1.879 eV
: Max energy: 4.643 eV
: [[./img/final-project/total_energy-comparison.png]]

** TODO Transport. Pore=1

#+BEGIN_SRC python
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Transport initial images. Distance of molecule's center from grahene plane
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]

def calculate(name, TE):
    for i, h in enumerate(heights):
        with jasp('./dft/' + name + '/d={0:0.2f}'.format(h)) as calc:
            calc.calculate()
            atoms = calc.get_atoms()
            energy = atoms.get_potential_energy()
            TE.append(energy)


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/'

name_free = base_name + 'linear-unconst_all'
TE_free = []
calculate(name_free, TE_free)

#name_uncon = base_name + 'linear-unconst_G'
#TE_uncon = []
#calculate(name_uncon, TE_uncon)

name_con = base_name + 'linear-const'
TE_con = []
calculate(name_con, TE_con)

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
#TE_uncon = np.array(TE_uncon)
#TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(0,10,1000)
    plt.plot(x_lin, spline(x_lin), style)


print('')
print('Normal view')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.figure(1)
plt.plot(heights, TE_free, 'ro', label='No constraints')
#plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')

print('')
print('Lennard-Jones potential well and convergence view')
file_path = './img/' + base_name + 'TE-comparison-LJ_zoom.png'
plt.figure(2)
plt.plot(heights, TE_free, 'ro', label='No constraints')
#plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
#plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,8])
plt.ylim([-0.15,0.2])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:

** DONE Vaccuum distance convergence
   CLOSED: [2016-06-08 Wed 15:59]
Look at the distance the molecule away from the graphene plane is to know when it appears to be a free molecule in space and does not exhibit changes in energy due to interaction.

#+BEGIN_SRC python :results drawer
import numpy as np
import matplotlib.pyplot as plt

from ase import Atom, Atoms
from ase.visualize import view
from jasp import *


def closest_atom_distance(atoms):
    pos = atoms.get_positions()
    dist = (pos[17] - pos[0])[2] # leading atom was always #17 in these calculations
    return dist


def calculate(molec, dist, TE, heights):
    for h in heights:
        with jasp('./dft/transport/g-mono/3x3/pore=1/molec=' + molec + '/linear-const-const/d={0:0.2f}'.format(h)) as calc:
	    calc.calculate()
	    atoms = calc.get_atoms()
	    dist.append(closest_atom_distance(atoms))
	    energy = atoms.get_potential_energy()
	    TE.append(energy)


dists = [[] for i in range(3)]
TEs = [[] for i in range(3)]
molecs = ['H2', 'N2', 'CO2']
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]
for i, (molec, dist, TE) in enumerate(zip(molecs, dists, TEs)):
    calculate(molec, dist, TE, heights)
    TE = np.array(TE)
    TE -= min(TE)
    TEs[i] = TE


file_path = './img/results/convergence-vaccuum-pore=1.png'
print('#+CAPTION: Vaccuum distance convergence. Height represents distance between closest atom and the graphene plane.')
print('#+NAME: fig:vaccuum-distance')
for dist, TE in zip(dists, TEs):
#    plt.plot(heights, TE)
    plt.plot(dist, TE)
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,8])
plt.ylim([-0.5,2])
plt.legend(molecs)
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
#+CAPTION: Vaccuum distance convergence. Height represents distance between closest atom and the graphene plane.
#+NAME: fig:vaccuum-distance
[[./img/results/convergence-vaccuum-pore=1.png]]
:END:

It appears that when the leading atom is 4 Å away from the graphene plane, there is no interaction. Since most molecules that we'll be testing are about 2-4 Å in length, it seems reasonable to make the z-direction vaccuum space of the calculations to be 9 Å on either side of the graphene plane. 

cite:sun-2014-mechan-molec reports between 5-6 Å is the distance of non-interaction for these molecules. They used classical MD with LJ potentials.


** TODO Monolayer graphene pore distance convergence

#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '4GB'

import devon_toolbox as dtb

sizes = [2, 3, 4, 5, 6]

energies = []
times = []

for i in sizes:
    name = 'material/g-mono/{0:0.0f}x{0:0.0f}/pore=1/convergence/size'.format(i)
    with jasp("dft/" + name) as calc:
        atoms = calc.get_atoms()
        energy = atoms.get_potential_energy()/len(atoms)
        time = float(get_elapsed_time(calc))

        energies.append(energy)
        times.append(time)
        

file_path = './img/results/monolayer-energy_vs_pore_distance.png'
plt.plot(i, energies, 'b-')
plt.plot(i, times, 'r-')
plt.xlabel("Repeated cell size (ixix1)")
#+END_SRC


It would be better to plot the distance between pore centers on the x-axis.

** TODO Charge density view of monolayer graphene pore=10

Show what the charge density looks like about a pore.

#+BEGIN_SRC python
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from ase.data import vdw_radii
from ase.data.colors import cpk_colors
from enthought.mayavi import mlab
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '2GB'

import devon_toolbox as dtb


with jasp('dft/material/g-mono/5x5/pore=10/final') as calc:
    atoms = calc.get_atoms()
    x, y, z, cd = calc.get_charge_density()

mlab.contour3d(x,y,z,cd)

dtb.bp()
mlab.figure(bgcolor=(1, 1, 1))

# plot the atoms as spheres
for atom in atoms:
    mlab.points3d(atom.x,
                  atom.y,
                  atom.z,
                  scale_factor=vdw_radii[atom.number]/5,
                  resolution=20,
                  # a tuple is required for the color
                  color=tuple(cpk_colors[atom.number]),
                  scale_mode='none')

# draw the unit cell - there are 8 corners, and 12 connections
a1, a2, a3 = atoms.get_cell()
origin = [0, 0, 0]
cell_matrix = [[origin,  a1],
               [origin,  a2],
               [origin,  a3],
               [a1,      a1 + a2],
               [a1,      a1 + a3],
               [a2,      a2 + a1],
               [a2,      a2 + a3],
               [a3,      a1 + a3],
               [a3,      a2 + a3],
               [a1 + a2, a1 + a2 + a3],
               [a2 + a3, a1 + a2 + a3],
               [a1 + a3, a1 + a3 + a2]]

for p1, p2 in cell_matrix:
    mlab.plot3d([p1[0], p2[0]], # x-positions
                [p1[1], p2[1]], # y-positions
                [p1[2], p2[2]], # z-positions
                tube_radius=0.02)


# Now plot the charge density
mlab.contour3d(x, y, z, cd, transparent=True)

# this view was empirically found by iteration
mlab.view(azimuth=-90, elevation=90, distance='auto')

file_path = 'tmp/test_charge.png'
mlab.savefig(file_path)
#mlab.show()
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:

