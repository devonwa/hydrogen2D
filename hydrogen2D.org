#+title: MS Research Project
#+author: Devon Walker
#+email: devonw@andrew.cmu.edu
#+TODO: TODO(t) INPROGRESS(w) | DONE(d) CANCELED(c)
#+STARTUP: hideblocks

* Journal
** 2016-05-19 Thu
- cite:zan-2012-graph-reknit Graphene Reknits Its Holes - Zan, Novoselov*

Competing possible research avenues:
1. Repairing graphene
2. Stacked-graphene aperture effect
  2.1. Neural network?

** 2016-05-20 Fri
- cite:drahushuk-2012-mechan-gas Mechanisms of Gas Permeation through Single Layer Graphene Membranes - Drahushuk, Strano*

** 2016-05-23 Mon
- cite:du-2011-separ-hydrog Separation of Hydrogen and Nitrogen Gases With  Porous Graphene Membrane - Du, Zhao*

** 2016-05-24 Tue
- cite:koenig-2012-selec-molec Selective Molecular Sieving Through Porous Graphene - Keonig, Bunch*

** 2016-05-25 Wed
- cite:liu-2013-permean-h2 

Simulators meeting
- Jake presented neural network vs reaxff with Au

** 2016-05-26 Thu
- cite:jiang-2009-porous-graph

** 2016-05-27 Fri
- cite:sun-2014-mechan-molec

Prepared for a group meeting presentation. Ended up not having one.

*** 2016-05-27 3pm Presentation Prep
    DEADLINE: <2016-05-27 Fri 3pm>
 (Meeting cancelled)

**** Concept of gas phase transport

 #+BEGIN_SRC python
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
import sys

heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]

def movie(constraint):
    images = []
    for i, h in enumerate(heights):
        with jasp('./dft/transport/g-mono/3x3/pore=1/molec=CO2/' + constraint + '/d={0:0.2f}'.format(h)) as calc:
            atoms = calc.get_atoms()
            images.append(atoms)
    view(images)

free = 'linear-unconst_all'
unconst_G = 'linear-unconst_G'
const_all = 'linear-const'

#movie(free)
#movie(unconst_G)
movie(const_all)
 #+END_SRC

 #+RESULTS:

**** Bond length of molecules change as they transport

 [[./img/final-project/G-bond-length.png]]

**** Total energy difference between H2 and CO2

 [[./img/final-project/total_energy-comparison.png]]

**** How constraints effect total energy

 Hydrogen transport through monolayer graphene. Pore=1
 [[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison.png]]

**** Non-interaction distance convergence
 [[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison-LJ_zoom.png]]

 How does this well distance change with other molecules?
 - Running comparisons with CO2 and N2.

**** Pore distance convergence
 What pore interaction distance is acceptable?

 [[./img/material/g-mono/4x4/pore=10/vac=16.png]]

 [[./img/material/g-mono/5x5/pore=10/vac=16.png]]

 [[./img/material/g-mono/6x6/pore=10/vac=16.png]]

**** Questions
 - How well is DFT handling multiple species?
 - - Smearing: sigma is not dependent on per molecule basis

 - Pressure can change diffusion pathways (gas phase vs adsorption)
 - - cite:du-2011-separ-hydrog
 - - cite:drahushuk-2012-mechan-gas

** 2016-05-31 Tue
- cite:drahushuk-2016-analy-time Analysis of Time-Varying, Stochastic Gas Transport Through Graphene Membranes - Drahushuk, Keonig, Bunch*, Strano*

Created vaccuum distance graph to deteremine interaction distance of leading atoms in a molecule.

Bilayer graphene unit cell in queue for relaxation.

Need to redo some of the 'free' transport. The graphene plane simply shifted down as the molecules approached. Might help to fix carbons around the outside edge.

*** DONE Check in on monolayer 5x5 and 6x6 pore=10 calculations
    CLOSED: [2016-06-01 Wed 12:26]
** 2016-06-01 Wed
- cite:shan-2012-influen-chemic
- cite:schrier-2012-carbon-dioxid
cite:koenig-2012-selec-molec

- cite:wang-2015-molec-valves Molecular valves for controlling gas phase transport made from discrete ångström-sized pores in graphene - Wang, Drahushuk, Strano*
   
- cite:partoens-2007-from-graph


Possible research idea: Look into pore stability of different passivating molecules, including what it takes to remove a passivated species (ie. if N is a more stable passivating species than H, what is the energy barrier for replacing H with N?).

*** DONE Finish structure of pore=10 for bilayer
    CLOSED: [2016-06-01 Wed 12:26]

** 2016-06-02 Thu
*** DONE Finish pore=10 for bilayer
    CLOSED: [2016-06-01 Wed 12:26]

** 2016-06-03 Fri
** 2016-06-06 Mon
** 2016-06-07 Tue
** 2016-06-08 Wed
** 2016-06-09 Thu
Prepared for group meeting research update tomorrow.
** 2016-06-10 Fri
Group meeting.

** 2016-06-13 Mon
** 2016-06-14 Tue
** 2016-06-15 Wed
** 2016-06-16 Thu
To build:
- pick edge atoms
- pick center atom
- tie into ase database to see if structure has been run
- top layer pore candidates

Would the atoms removed necessarily need to be next to eachother?

Paper motivation:
http://pubs.acs.org/doi/abs/10.1021/acsnano.5b01762

Paper to compare my results to (maybe):
http://pubs.acs.org/doi/abs/10.1021/acsnano.5b01762

*** Choosing unique solutions for graphene pores

#+BEGIN_SRC python
from ase import Atoms, Atom
from jasp import *
import numpy as np

import devon_toolbox as dtb


with jasp('dft/material/g-mono/final') as calc:
    atoms = calc.get_atoms()
atoms.center()
atoms = atoms.repeat((3,3,1))

def is_the_same(x, fun, *args):
    """True if the object is unchanged during the function call."""
    import copy
    y = copy.deepcopy(x)
    fun(*args)
    return x == y

def closest_atom(atoms, position, exclude=None):
    """Return the index of the atom closest to a position."""
    choices = [a.index for a in atoms]

    if exclude is not None:
        choices = [i for i in choices if i not in exclude]

    closest = None
    min_dist = None
    for i in choices:
        dist = np.linalg.norm(atoms[i].position - position)
        if np.absolute(dist) < min_dist or closest is None:
            min_dist = dist
            closest = i

    return closest

def center(atoms):
    """Return the position (x,y,z) of the center of the cell."""
    cell = np.array(atoms.get_cell())
    center = (cell[0] + cell[1]) / 2
    center += cell[2] / 2
    return center

def center_layer(atoms):
    """Return the position (x,y,z) of the center of a layer of atoms."""
    cell = np.array(atoms.get_cell())
    center = (cell[0] + cell[1]) / 2
    center += [0, 0, np.mean([a.position[2] for a in atoms])]
    return center


pore = [9]
#pore = [3, 8, 9, 14]
#pore = [6, 7, 8, 9, 12, 13, 14, 15]
dtb.paint_atoms(atoms, pore)
dtb.bp(atoms)
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
import numpy as np

a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

print(a, a1*3, a2*3, a3*3)
#+END_SRC

#+RESULTS:
: (2.46, array([ 6.39126748, -3.69      ,  0.        ]), array([ 6.39126748,  3.69      ,  0.        ]), array([  0.,   0.,  30.]))

*** New vasp vs jasp error

Temporary simple-co with new vasp:
#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp
import numpy as np
np.set_printoptions(precision=3, suppress=True)

co = Atoms([Atom('C', [0, 0, 0]),
            Atom('O', [1.2, 0, 0])],
           cell=(6., 6., 6.))

calc = Vasp('~/tmp/molecules/simple-co',  # output dir
            xc='PBE',  # the exchange-correlation functional
            nbands=6,    # number of bands
            encut=350,    # planewave cutoff
            ismear=1,    # Methfessel-Paxton smearing
            sigma=0.01,  # very small smearing factor for a molecule
            atoms=co)
print('energy = {0} eV'.format(co.get_potential_energy()))
print(co.get_forces())
#+END_SRC

#+RESULTS:
: energy = -14.69111507 eV
: [[ 5.091  0.     0.   ]
:  [-5.091  0.     0.   ]]

This works:
#+BEGIN_SRC python
from ase import Atoms, Atom
from jasp import *

with jasp('~/dft-book/molecules/simple-co') as calc:
    atoms = calc.get_atoms()
#+END_SRC

#+RESULTS:

This doesn't:
#+BEGIN_SRC python
from ase import Atoms, Atom
from vasp import Vasp

print(Vasp.default_parameters) # this works.

calc = Vasp('~/dft-book/molecules/simple-co')
atoms = calc.get_atoms()
#+END_SRC

#+RESULTS:

Trace:
#+BEGIN_SRC screen
Traceback (most recent call last):
  File "<stdin>", line 6, in <module>
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 45, in inner
    return func(self, *args, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp_core.py", line 242, in __init__
    str(label), atoms)
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 51, in inner
    return self.exception_handler(self, *sys.exc_info())
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 48, in inner
    return func(self, *args, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/ase-s16/ase/calculators/calculator.py", line 513, in __init__
    atoms, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 51, in inner
    return self.exception_handler(self, *sys.exc_info())
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 48, in inner
    return func(self, *args, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/ase-s16/ase/calculators/calculator.py", line 184, in __init__
    self.read(restart)  # read parameters, atoms and results
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 51, in inner
    return self.exception_handler(self, *sys.exc_info())
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 48, in inner
    return func(self, *args, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/readers.py", line 322, in read
    atoms = self.read_atoms()
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 51, in inner
    return self.exception_handler(self, *sys.exc_info())
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/vasp.py", line 48, in inner
    return func(self, *args, **kwargs)
  File "/opt/kitchingroup/vasp-5.3.5/vaspy/vasp/readers.py", line 249, in read_atoms
    atoms.positions = xatoms.positions[resort]
AttributeError: 'NoneType' object has no attribute 'positions'
#+END_SRC

*** Monolayer graphene pore selector

*What is it?*
A script that takes a pristine monolayer of graphene and generates Atoms objects for all unique pores, up to the edge atoms.

It should start with the most central carbon and systematically expand from that point, removing more and more adjacent carbons.

/Input/
Size of the ixi repeated monolayer graphene.

/Output/
A list of Atoms objects with all the possibile pore configurations. (Might have scalability issues here.)

*Function list*
- 


*Next step*

** 2016-06-21 Tue
** 2016-06-22 Wed

Job scraper test string:
/home-guest/devonw/hydrogen2D/vasp/base/mat=graphene/layers=2 Queued: 1412411.gilgamesh.cheme.cmu.edu

*** Jasp Vasp comparison
**** New Vasp() view atoms bug
     CLOSED: [2016-06-22 Wed 11:39]

 #+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from vasp import Vasp
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '10:00:00'

from ase.visualize import view
import devon_toolbox as dtb


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3.5 * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

name = 'tmp/vasp/base/mat=graphene/layers=1'
calc = Vasp(name,
            xc='PBE',          # GGA functional type
            encut=520,
            kpts=[11,11,1],
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms)


print(atoms.get_potential_energy())
print(atoms.get_forces())
dtb.bp(atoms)
dtb.bp()

print(atoms.get_potential_energy())
#calc.view()
atoms2 = calc.get_atoms()

atoms2.set_calculator()
#view(atoms2)
print(atoms2)
#dtb.print_image(name, atoms)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 -18.44792199
 [[ 0.077 -0.017  0.   ]
  [-0.077  0.017  0.   ]]
 :END:

**** New Vasp() view atoms bug - in Jasp
     CLOSED: [2016-06-22 Wed 11:39]

 #+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'

from ase.visualize import view
import devon_toolbox as dtb


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3.5 * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

#dtb.bp(atoms)
name = 'tmp/jasp/base/mat=graphene/layers=1'
with jasp(name,
            xc='PBE',          # GGA functional type
            encut=520,
            kpts=(11,11,1),
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms) as calc:
    print(atoms.get_potential_energy())
    print(atoms.get_forces())
#    dtb.bp(calc.get_atoms())


#calc.view()

#atoms2.set_calculator()
#view(atoms2)
#print(atoms2)
#dtb.print_image(name, atoms)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 -18.44792199
 [[ 0.077 -0.017  0.   ]
  [-0.077  0.017  0.   ]]
 :END:

** 2016-06-23 Thu

* Meetings
** DONE 2016-03-08 4pm
   CLOSED: [2016-03-09 Wed 09:26] DEADLINE: <2016-03-08 Tue 16:00>
*** Questions
quantum mechanics:
- can we adsorb molecules to the surface which impart favorable changes to the electron density around diffusion sites?

neural network:
- can we use a neural network to address properties that dft doesn't model well, such as charging the material with a potential?

org-ref:
- can you later attach a pdf?
- duplicate current bibliography into default bibliography?
- do you highlight pdfs or just type into the notes file?

*** Actions
1. Table outlining separation data

** DONE 2016-04-15 11am
   CLOSED: [2016-05-11 Wed 16:02] DEADLINE: <2016-04-15 Fri 11:00>
*** Final project suggestion
- develop a suggestion related to research
- look into what jasp is lacking

*** Neural networks
Behler-Parrinello paper from 2007
- inputs are atom positions
- questions
  - how is it not overfit with an 8200 optimizing set and 800 test set?
  - is there a way to use different inputs or generalize them? (ie. an input could be the position or presence of a functional group)

** DONE 2016-05-12 11am
*** Final project feedback
[[file:~/techela/s16-06640/final-project/final-project.org::*Transport of carbon dioxide]]

*** Correct constraints for a molecule

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.constraints import FixAtoms, Hookean
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
import sys

JASPRC['queue.walltime'] = '10:00:00'

def print_converged(i, energy, time):
#    print(i, energy, time)
    print("CO2 Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("CO2 Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("CO2 Distance: {:5.2f}. Did not converge.".format(i))


# Height of the fixed atom
heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]


# Build base images
with jasp('graphene/G-c-final') as calc:
    G_defect = calc.get_atoms()
def_pos = np.array([5.681, 0., 5.]) # defect position

# http://en.wikipedia.org/wiki/Carbon_dioxide_(data_page)
CO_bond = 1.16 # Ang. C=O bond length in CO2

atoms =  [Atoms(G_defect) for i in range(len(heights))]
for i, h in enumerate(heights):
    CO2 = Atoms([Atom('O', def_pos + (0., 0., h - CO_bond)),
                 Atom('C', def_pos + (0., 0., h)),
                 Atom('O', def_pos + (0., 0., h + CO_bond))])

    atoms[i].extend(CO2)

# Constraint - fix all carbons (including the CO2 carbon)
carbon_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Hookean constraint
# Values for constants rt [Ang] and k [eV/Ang^-2] are from https://wiki.fysik.dtu.dk/ase/ase/constraints.html for a C=O bond
for atom in atoms[0]:
    if atom.symbol == 'O':
        hook_constraint = [Hookean(a1=atom.index, a2=atom.index+1, rt=1.58, k=10.),
                           Hookean(a1=atom.index+1, a2=atom.index+2, rt=1.58, k=10.)]
        break

ready = True

# Constrained graphene, constrained carbon in CO2
print('Unconstrained graphene, constrained carbon in CO2:')

atoms_yy = [Atoms(atoms[i]) for i in range(len(heights))]
#for i in range(len(heights)):
#    atoms_yy[i].set_constraint(carbon_constraint)





with jasp('transport/G-c-CO2-transport-no-yes-d=1.00a'.format(h),
                encut=450,         # From convergence check
                kpts=(6,6,1),      # From convergence check
                xc='PBE',          # GGA functional type. Important for the defect.
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms_yy[i]) as calc:
        try:
            calc.calculate()
            energy = atoms_yy[i].get_potential_energy()
            print_converged(h, energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            print_inprogress(h)
            ready = False
            pass
sys.exit()





TE_yy = []
BO_yy = [[], []]
for i, h in enumerate(heights):
    with jasp('transport/G-c-CO2-transport-no-yes-d={0:0.2f}'.format(h),
                encut=450,         # From convergence check
                kpts=(6,6,1),      # From convergence check
                xc='PBE',          # GGA functional type. Important for the defect.
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms_yy[i]) as calc:
        try:
            calc.calculate()
            energy = atoms_yy[i].get_potential_energy()
            TE_yy.append(energy)
            BO_yy[0].append(atoms_yy[i].get_distance(17,18))
            BO_yy[1].append(atoms_yy[i].get_distance(18,19))
            print_converged(h, energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            print_inprogress(h)
            ready = False
            pass


# Constrained graphene, constrained carbon in CO2 + Hookean oxygen
print('')
print('Unconstrained graphene, constrained carbon + Hookean oxygen:')

atoms_yh = [Atoms(atoms[i]) for i in range(len(heights))]
#for i in range(len(heights)):
#    atoms_yh[i].set_constraint(carbon_constraint + hook_constraint)

TE_yh = []
BO_yh = [[], []]
for i, h in enumerate(heights):
    with jasp('transport/G-c-CO2-transport-no-hook-d={0:0.2f}'.format(h),
                encut=450,         # From convergence check
                kpts=(6,6,1),      # From convergence check
                xc='PBE',          # GGA functional type. Important for the defect.
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms_yh[i]) as calc:
        try:
            calc.calculate()
            energy = atoms_yh[i].get_potential_energy()
            TE_yh.append(energy)
            BO_yh[0].append(atoms_yh[i].get_distance(17,18))
            BO_yh[1].append(atoms_yh[i].get_distance(18,19))
            print_converged(h, energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            print_inprogress(h)
            ready = False
            pass

if not ready:
    import sys; sys.exit()

import matplotlib.pyplot as plt

# Consider the change in energy from lowest energy state
TE_yy = np.array(TE_yy)
TE_yh = np.array(TE_yh)
TE_yy -= min(TE_yy)
TE_yh -= min(TE_yh)

print('')
print('Comparison of constraint techniques:')
file_path = './img/G-c-C-linear.png'
plt.figure(0)
plt.plot(heights, TE_yy, label='O uconstrained')
plt.plot(heights, TE_yh, label='Hookean constraint')
plt.xlabel('Height (Ang)')
plt.ylabel('$\Delta$ Energy (eV)')
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#view(atoms_yy)
#view(atoms_yh)
#+END_SRC

#+RESULTS:
: Unconstrained graphene, constrained carbon in CO2:
: CO2 Distance: -3.00. In progress.

*** Bilayer / Trilayer graphene
**** Bilayer

#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys

def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

layer_dist = 3.32
b1 = a1
b2 = a * np.array([1./2., 3.0**0.5/2., 0.])
b3 = a3 - 2 * np.array([0., 0., layer_dist])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3),
                  Atom('C', 1./2. * b3),
                  Atom('C', 1./3. * b1 + 1./3. * b2 + 1./2. * b3)],
                  cell=[a1, a2, a3])


atoms = unitcell
#atoms = unitcell.repeat((3,3,1))
view(atoms)
sys.exit()

defect_pos = atoms[9].position
del atoms[9]

ready = True
with jasp('graphene/G-c-final',
            encut=450,         # From convergence check
            kpts=(6,6,1),      # From convergence check
            xc='PBE',          # GGA functional type. Important for the defect.
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

if not ready:
    sys.exit()

print('')
print('Defect position: {}'.format(defect_pos))

print('')
file_path = './img/bilayer.png'
#file_path = './img/G-c-final-repeat-present.png'
#atoms = atoms.repeat((3,3,1))
#atoms.rotate('x', -np.pi/4)
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
view(atoms)
#+END_SRC

#+RESULTS:
** DONE 2016-06-10 3pm Group meeting presentation
   CLOSED: [2016-06-15 Wed 09:44] DEADLINE: <2016-06-10 Fri 3pm>

*** Presentation
**** 06-640 Final project
***** Concept movie

 #+BEGIN_SRC python
from jasp import *
from ase.visualize import view

fp_dir = '~/techela/s16-06640/final-project/' # Directory of final project.

heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]

images_h2 = []
images_co2 = []

for h in heights:

    with jasp(fp_dir + 'transport/G-c-HHc-constraints-yes-hook-d={0:0.2f}'.format(h)) as calc:
        images_h2.append(calc.get_atoms())

    with jasp(fp_dir + 'transport/G-c-CO2-transport-yes-hook-d={0:0.2f}'.format(h)) as calc:
        images_co2.append(calc.get_atoms())

view(images_co2)
#view(images_h2) 
 #+END_SRC

 #+RESULTS:

 Limitations:
 - Graphene layer consisted of a 3x3 repeated monolayer in the x and y directions. Not large enough to say pores do not have an effect on one another.
 - Carbon atoms in graphene plane are fixed
 - One atom in each molecule is chosen to be fixed, with other atoms constrained with a Hookean constraint
   - Preserved molecule structure
   - Introduced new error (empirical correction)
     - If the atoms within a molecule got beyond a certain distance, an artificial energy penalty would be imposed to persuade the geometry relaxation to maintain the integrity of the molecule's structure.

***** Bond length change
 [[./img/final-project/G-bond-length.png]]

***** Barrier energy

 [[./img/final-project/total_energy-comparison.png]]


 Energy barriers:
     H2:  1.879 eV
     CO2: 4.643 eV

 Significantly large energy barrier, even for H2.

 Literature comparison: cite:jiang-2009-porous-graph
     H2: 0.22 eV
     6x6 repeated graphene monolayer.
     Pore = 10 removed carbons. H passivated.
 [[./img/ref/jiang-2009-h2passivated.png]]
 [[./img/material/g-mono/3x3/pore=1/final.png]]

**** Vacuum distance for convergence

 #+CAPTION: Vaccuum distance convergence. Height represents distance between the molecule's closest atom and the graphene plane.
 #+NAME: fig:vaccuum-molecule-distance
 [[./img/results/convergence-vaccuum-pore=1.png]]


 Converged distance appears to be around 4 Å.

 cite:sun-2014-mechan-molec reports between 5-6 Å is the distance of non-interaction for these molecules. They used classical MD with LJ potentials.

 Final project max distance for both molecules was 3 Å. CO2 calculations probably affected since the minimum should have been lower, meaning the barrier energy would be higher.

**** Monolayer graphene pore distance convergence

 Ideally, we could model a pore placed on an infinite graphene sheet. The energy per atom of this structure would aproach a pristine graphene sheet.

 #+CAPTION: The effect of distance between pores on energy and calculation time.
 #+NAME: fig:g-mono-energy_vs_pore_distance
 [[./img/results/monolayer-energy_vs_pore_distance.png]]
***** Structures

 Distance = 4.92. Structure = 2x2
 [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=2.png]]
 Distance = 7.38. Structure = 3x3
 [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=3.png]]
 Distance = 9.84. Structure = 4x4
 [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=4.png]]
 Distance = 12.3. Structure = 5x5
 [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=5.png]]
 Distance = 14.76. Structure = 6x6
 [[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=6.png]]


***** Pore=10 comparison

 Note that the 4x4 structure is the smallest possible size for a pore with 10 removed carbon atoms.

 Distance = 9.84. Structure = 4x4
 [[./img/results/monolayer-energy_vs_pore_distance-pore=10-size=4.png]]
 Distance = 12.3. Structure = 5x5
 [[./img/results/monolayer-energy_vs_pore_distance-pore=10-size=5.png]]
 Distance = 14.76. Structure = 6x6
 [[./img/results/monolayer-energy_vs_pore_distance-pore=10-size=6.png]]
 #+CAPTION: The effect of distance between pores on energy and calculation time.
 #+NAME: fig:g-mono-energy_vs_pore_distance
 [[./img/results/monolayer-energy_vs_pore_distance-pore=10.png]]

**** Bilayer graphene neural network sidebar
 Proposed project: Use a neural network trained on different bilayer graphene pore structures to 

 Sidebar: Determine minimum energy structures of different pore configurations for smaller structures first. Use this information to inform the larger structures.

 Motivation:
 - DFT relaxations bilayer graphene with significant pore size would take too long.
 - Current etching of pores does not allow for the geometric accuracy. (cite:koenig-2012-selec-molec: heavily cited experimental graphene transport paper uses bilayer graphene but didn't determine exact pore structure after etching.)
 - Graphene was found to reknit itself, so minimum energy pore structures are important. cite:zan-2012-graph-reknit
 [[./img/ref/zan-2012-reknit.png]]
 - This smaller project can be done on monolayer graphene at the same time with minimal effort and faster speeds.

 Where I'm at with this:
 - Created a function for determining candidates for etching based on current index.
 - Working on the structure for managing all the calculations and removing duplicates.

 get_neighbors example:
 #+BEGIN_SRC python
from jasp import *
from ase import Atoms, Atom
import devon_toolbox as dtb

with jasp('dft/material/g-bi/final') as calc:
    atoms = calc.get_atoms()
i = 3
atoms = atoms.repeat([i,i,1])

#dtb.bp(atoms)
struct = dtb.structure(atoms, layers=2)
index = 16
neighbors = dtb.get_neighbors(atoms, index, struct['layers'][0])
neighbors.append(index)
dtb.paint_atoms(atoms, neighbors, layers=struct['layers'])
dtb.bp(atoms)
 #+END_SRC

** 2016-06-24 3pm Group meeting
** 2016-07-06 3pm Group meeting presentation
** 2016-07-15 3pm Group meeting
** 2016-08-12 3pm Group meeting presentation
* Research
** Literature
*** Graphene
**** cite:novoselov-2005-two-dimen
**** cite:partoens-2006-from-graph graphene structure unitcell
**** cite:geim-2009-graph
**** *cite:jiang-2009-porous-graph DFT porous graphene separation of H2/CH4
 Selectivity results
 | Graphene monolayer porous N/H functionalized |  10^8 |
 | Graphene monolayer porous H functionalized   | 10^23 |
 | Traditional polymer / silica membranes       |  10^8 |
**** cite:pontes-2009-barrier-free DFT HCN production with substitutional doping using boron
**** DONE cite:du-2011-separ-hydrog DFT H2/N2 separation
     CLOSED: [2016-06-01 Wed 14:59]
**** DONE *cite:koenig-2012-selec-molec Experimental separation of common gases
     CLOSED: [2016-06-01 Wed 14:59]
**** cite:shan-2012-influen-chemic CO2/N2 separation using cite:jiang-2009-porous-graph funcitonalized groups
**** DONE cite:drahushuk-2012-mechan-gas MD H2/N2 separation. Explains mechanisms for gases crossing the membrane
     CLOSED: [2016-06-01 Wed 14:59]
**** cite:kim-2013-selec-gas  Exp O2/N2. Most work done on GO.
**** cite:miao-2013-first-princ DFT proton/H separation
**** cite:qin-2013-graph-with H2&He separation from air. Octogon pore + secondary small pore.
**** cite:ambrosetti-2014-gas-separ Water filtration through porous graphene. No permeation/selectivity data.
**** cite:celebi-2014-ultim-permeat Exp separation of H2/CO2 with bilayer G. Also a water permeance comparison to Goretex.
**** cite:tsetseris-2014-graph DFT Boron can pass through pristine graphene under moderate annealing conditions
**** cite:sun-2015-applic-nanop DFT separation for gases in natural gas processing
**** cite:wen-2015-inhib-effec Inhibition effect of non-permeating components
**** cite:achtyl-2015-aqueous-proton Exp/DFT Defect detection. Aqueous proton transfer

*** Polyphenylene (Porous Graphene (PG))
**** cite:bieri-2009-porous-graph Synthesis of PG
**** *cite:blankenburg-2010-porous-graph Selectivity study of common gases with DFT
 [[./img/blankenburg-2010-porous-graph-3.png]]
**** cite:schrier-2010-helium-separ Helium isotope separation
**** cite:li-2010-two-dimen-polyp H2 separation from CO2, CO, CH4
**** cite:lu-2014-promis-monol DFT O2 separation from harmful gases
**** cite:huang-2014-improv-permeab Bilayer porous graphene. H2/CH4 separation. High permeance and selectivity
**** cite:tao-2014-tunab-hydrog DFT PG-ESX study on hydrogen purification
 | Molecule |     Kinetic |
 |          | Diam. (Ang) |
 |----------+-------------|
 | H2       |         2.9 |
 | N2       |        3.64 |
 | CO       |        3.76 |
 | CH4      |         3.8 |
 Note: Agrees with common molecules table.

**** *cite:brockway-2013-noble-gas DFT PG-ESX study similar to Blankenberg's
**** Notes 
 High temperatures required for permeance of H2 and He would destroy a PG monolayer. cite:huang-2014-improv-permeab
*** hexagonal Boron Nitride (hBN)
**** cite:corso-2004-boron-nitrid-nanom Boron nitride nanomesh
 Hole in mesh: size 20 Å
 - 'likely driven by the lattice mismatch of the film and the rhodium substrate'
**** cite:jin-2009-fabric-frees monolayer fabrication with electron irradiation
**** cite:nag-2010-graph-analog-bn properties of hBN compared to graphene
**** cite:hu-2014-proton-trans proton transport of graphene, hBN, MoS2
**** *cite:zhang-2015-hexag-boron H2/CH4 separation. Triangular pores.
 Drahushuk, L. W.; Strano, M. S. Mechanisms of Gas Permeation
 through Single Layer Graphene. Langmuir 2012, 28, 16671−16678.
*** Graphene oxide
**** *cite:kim-2013-selec-gas
**** *cite:li-2013-ultrat-molec
**** cite:yoo-2013-graph-graph
*** Molybdenum disulphide (MoS2)
**** cite:hong-2015-explor-atomic 
*** Quantum mechanics
**** Lennard-Jones potential
 [[http://chemwiki.ucdavis.edu/Core/Physical_Chemistry/Physical_Properties_of_Matter/Atomic_and_Molecular_Properties/Intermolecular_Forces/Specific_Interactions/Lennard-Jones_Potential][ChemWiki - UC Davis]]

**** van der Waals radius
 [[http://chemwiki.ucdavis.edu/Core/Theoretical_Chemistry/Chemical_Bonding/General_Principles_of_Chemical_Bonding/Covalent_Bond_Distance%2C_Radius_and_van_der_Waals_Radius][ChemWiki - UC Davis]]
*** Neural networks
**** *cite:behler-2007-gener-neural
**** TODO cite:behler-2008-press-induc
**** TODO cite:behler-2011-neural-networ
**** TODO cite:behler-2014-repres-poten
*** Review articles
**** cite:yoo-2013-graph-graph Graphene and graphene oxide uses as barriers
*** Patents
**** TODO Aperture
 http://www.google.com/patents/US20140263035
*** Non-pertinent
**** TODO cite:britnell-2012-elect-tunnel hBN as a dielectric
*** To Read
**** TODO cite:elstner-1998-self-consis
**** TODO cite:zhu-2006-permean-shoul
**** TODO cite:zhang-2012-tunab-hydrog
**** TODO cite:drahushuk-2012-mechan-gas
**** TODO cite:nieszporek-2015-alkan-separ
**** TODO cite:liu-2014-mechan-proper
**** TODO cite:tao-2014-tunab-hydrog
**** TODO cite:wang-2014-trans-metal
**** TODO cite:bunch-2008-imper-atomic
**** TODO cite:leeuwen-1994-deriv-stock Derivation of L-J lengths of liquids.
**** TODO cite:hauser-2012-methan-selec Methane transfer through graphene, DFT
** Questions
** Are the kinetic diameters used in Blankenberg correct?
cite:blankenburg-2010-porous-graph uses cite:leeuwen-1994-deriv-stock for kinetic diameter of ammonia, even though they're stated for liquids.
cite:tsuru-2010-permeat-proper shows that certain kinetic diameter calculations may not apply to certain separations.
** What is the unit GPU?
Gas permeance unit
1 GPU = 0.33 mol/(m^2*s*Pa)
** What's a dispersion correction in dft?
Dipoles occur as a molecule passes through the membrane. They need to be accounted for in the energy calculations.
** Ryd compared to eV?
Stands for Rydberg constant.
1 eV = 7.350e-2 Ryd
300 eV = 22.096 Ryd
** TODO Best way to calculate a pore's diameter?
** What should I compare H2 transport with?
- cite:koenig-2012-selec-molec 
- cite:jiang-2009-porous-graph 
- cite:blankenburg-2010-porous-graph

** Properties
*** Bond lengths

| Molecule | Bond | Bond Length (Å) |
| H2       | H-H  |            0.74 |
| CO2      | C=O  |            1.21 |
| N2       | N=-N |            1.13 |

**** References
CO2 C=O, H2, N2: CRC Handbook, Section 9, Characteristic Bond Lengths in Free Molecules

*** Common molecules
Useful numbers:
- Average energy of a gas particle at room temperature: ~0.037 eV (need cite)
  - calculated as $E=(3/2)kT$, where $k$ is the Boltzmann constant

#+caption: Properties of common industrial gases.
#+name: tab:properties-common_gases
| Molecule      |  Kinetic |
|               | diameter |
|               |      (Å) |
|---------------+----------|
| He            |     2.60 |
| H2O           |     2.65 |
| Ne            |     2.79 |
| H2            |     2.89 |
| NH3           |     3.26 |
| CO2           |     3.30 |
| Ar            |     3.42 |
| O2            |     3.46 |
| Kr            |     3.60 |
| H2S           |     3.60 |
| N2            |     3.64 |
| CO            |     3.76 |
| CH4           |     3.80 |
|---------------+----------|
| CH4           |      3.8 |
| C2H6          |      --- |
| C2H4          |      3.9 |
| C3H8          |      4.3 |
| n-C4H10       |      4.3 |
| C3H6          |      4.5 |
| i-C4H10       |        6 |
|---------------+----------|
| Benzene       |     5.85 |
| Toluene       |     5.85 |
| p-xylene      |     5.85 |
| Ethyl-benzene |     6.00 |
| Cyclohexane   |      6.0 |
| o-xylene      |     6.80 |
| m-xylene      |     6.80 |

**** References
Kinetic diameter
- He, H2S, CO: [[https://en.wikipedia.org/wiki/Kinetic_diameter][Wiki]]
- CO2, O2, N2, H2O, CH4, H2: cite:ismail-2015-fundam-gas p14
- CO2, CO, CH4: cite:li-2010-two-dimen-polyp
- NH3: cite:blankenburg-2010-porous-graph 
- Ne, Ar: [[http://www.kayelaby.npl.co.uk/general_physics/2_2/2_2_4.html][NPL]]
- Kr: [[https://smartech.gatech.edu/handle/1853/50383][Crawford-2013]]
- He, H2, O2, N2, CO, CO2, CH4, C2H6, C2H4, C3H8, C3H6, n-C4H10, i-C4H10: cite:matteucci-2006-trans-gases Has L-J parameters in same table
- benz, tol, eth-benz, xylene: cite:baertsch-1996-permeat-aromat
- cyclohexane: cite:sing-2004-use-molec

*** 2D materials

Structure
| Material | Stack | Lattice      |
|          |       | Constant [Å] |
|----------+-------+--------------|
| Graphene | Mono  | 2.460        |
|          |       |              |


Stability
| Material | Stack | Production | Temperature   | Ref                       |
|          |       |            | Stability [K] |                           |
|----------+-------+------------+---------------+---------------------------|
| Graphene | Mono  | CVD        | 2600          | cite:kim-2010-high-temper |



| Material | Features    | Pore     |
|          |             | Size (Å) |
|----------+-------------+----------|
| Graphene | Pristine    |          |
| PG       |             | 2.48     |
| PG-ES1   |             |          |
| PG-ES2   |             |          |
| PG-ES3   |             |          |
| hBN      |             |          |

**** References

Structure
- Lattice constant
  - Graphene mono: cite:partoens-2006-from-graph

Pore size
- Graphene, Pristine: 
- PG: cite:li-2010-two-dimen-polyp
** Separations

Materials to research
- Graphene Monolayer
- Graphene Bilayer
- Graphene oxide
- Boron nitride monolayer
- Boron nitride bilayer

*** Master Table

Table legend:
- 2D Material:
  - hBN: hexagonal boron nitride
  - PG: Polyphenylene (porous graphene)
  - PG-ES1: Porous Graphene-E-Stilbene-1
- Features: Distinctive variations of the material.
  - Porous: Intentially engineered pores
  - Defects: Naturally occuring defects from the production process.
- Func. Groups: Functional groups attached around a pore.
  - CNT: Carbon nanotubes
- Methods:
  - DFT: Density functional theory
  - Exp: Experimental
  - MD: Molecular dynamics simulation
  - TST: Transition state theory
- Molecules: Numbers denote separation groups. Members of "a" can be separated from "b" and both can be separated from "c". Additionally, "a" transfers across the barrier before "b".

#+caption: Table of separation selectivity groupings found in literature with molecule columns ordered by kinetic diameter.
#+name: tab:separations-common_gases
| Reference                          | Methods  | 2D             | Stack   | Features | Func.  | He | H2O | Ne | H2 | NH3 | CO2 | Ar | O2 | N2 | Kr | H2S | CO | CH4 | Note |
|                                    |          | Material       |         |          | Groups |    |     |    |    |     |     |    |    |    |    |     |    |     |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:jiang-2009-porous-graph       | DFT, MD  | Graphene       | Mono    | Porous   | N/H, H |    |     |    | a  |     |     |    |    |    |    |     |    | b   |      |
| cite:wesołowski-2011-pillar-graph  | MD       | Graphene       | Multi   | Porous   | CNT    | c  |     |    |    |     |     | b  |    |    | a  |     |    |     |      |
| cite:du-2011-separ-hydrog          | MD       | Graphene       | Mono    | Porous   |        |    |     |    | a  |     |     |    |    | b  |    |     |    |     |      |
| cite:koenig-2012-selec-molec       | Exp      | Graphene       | Bilayer | Porous   |        |    |     |    | a  |     | a   | b  |    | b  |    |     |    | b   |      |
| cite:kim-2013-selec-gas            | Exp      | Graphene       | Multi   | Defects  |        |    |     |    |    |     |     |    | a  | b  |    |     |    |     |      |
| cite:celebi-2014-ultim-permeat     | Exp      | Graphene       | Bilayer | Porous   |        |    |     |    | a  |     | b   |    |    |    |    |     |    |     |      |
| cite:lei-2014-separ-hydrog         | DFT      | Graphene       | Mono    | Porous   |        |    |     |    |    |     |     |    |    |    |    | a   |    | b   |    3 |
| cite:liu-2015-selec-trend          | MD       | Graphene       | Mono    | Porous   | N/H    |    |     |    | a  |     | a   | b  |    | b  |    |     |    | b   |      |
| cite:sun-2015-applic-nanop         | MD       | Graphene       | Mono    | Porous   | N/H    |    |     |    |    |     | a   |    |    | a  |    | a   |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:blankenburg-2010-porous-graph | DFT, MD  | PG             | Mono    |          |        | a  |     | a  | a  | c   | b   | d  | b  | c  |    |     | c  |     |      |
| cite:li-2010-two-dimen-polyp       | DFT      | PG             | Mono    |          |        |    |     |    | a  |     | b   |    |    |    |    |     | b  | b   |      |
| cite:huang-2014-improv-permeab     | DFT, MD  | PG             | Bilayer |          |        |    |     |    | a  |     |     |    |    |    |    |     |    | b   |      |
| cite:schrier-2012-carbon-dioxid    | MD       | PG-ES1         | Mono    |          |        |    |     |    |    |     | a   |    | b  | b  |    |     |    |     |      |
| cite:brockway-2013-noble-gas       | DFT, MD  | PG-ES1         | Mono    |          |        | a  |     | a  |    |     | b   | b  | b  | b  |    |     |    | c   |      |
| cite:tao-2014-tunab-hydrog         | DFT, MD  | PG-ES1         | Mono    |          |        |    |     |    | a  |     | b   |    |    | b  |    |     |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:nair-2012-unimp-permeat       | Exp, MD  | Graphene oxide | 1 µm    |          |        | b  | a   |    | b  |     |     | b  |    | b  |    |     |    |     |      |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 2-18 nm |          |        |    |     |    | a  |     | b   |    |    |    |    |     |    |     |      |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 2-18 nm |          |        |    |     |    | a  |     |     |    |    | b  |    |     |    |     |      |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 18 nm   |          |        | a  |     |    | a  |     | b   |    | b  | b  |    |     | b  | b   |    1 |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide | 3-7 nm  |          |        |    |     |    | a  |     | b   |    |    |    |    |     |    |     |    2 |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide | 3-7 nm  |          |        | b  |     |    | b  |     | a   |    | b  | b  |    |     |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:zhang-2015-hexag-boron        | DFT, MD  | hBN            | Mono    | Porous   | N/H    |    |     |    | a  |     |     |    |    |    |    |     |    | b   |      |
|------------------------------------+----------+----------------+---------+----------+--------+----+-----+----+----+-----+-----+----+----+----+----+-----+----+-----+------|
| cite:jiao-2011-graph               | DFT, TST | Graphdiyne     | Mono    |          |        |    |     |    | a  |     | b   |    |    |    |    |     |    | b   |      |
| cite:zhu-2015-c-n                  | DFT      | C2N            | Mono    |          |        | a  | b   | b  |    |     | b   | b  | b  | b  |    | b   |    | b   |      |
| cite:li-2015-effic-helium          | DFT, MD  | g-C3N4         | Mono    |          |        | a  |     | b  | b  |     | b   | b  |    | b  |    |     | b  | b   |      |

Notes:
1. Extrapolated from single-gas permeation results.
2. Long time scale ~1 hr. At short time scales <0.1 hr, the permeance rate is reversed.
3. Pore carbons had negative charge (-0.241 e).

*** Atmospheric separations
N2, O2, Ar, CO2, Ne, He, CH4 

| Reference                          | Methods  | 2D             | Stack   | Features | Func.  | N2 | O2 | Ar | CO2 | Ne | He | CH4 |
|                                    |          | Material       |         |          | Groups |    |    |    |     |    |    |     |
|------------------------------------+----------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:koenig-2012-selec-molec       | Exp      | Graphene       | Bilayer | Porous   |        | b  |    | b  | a   |    |    | b   |
| cite:kim-2013-selec-gas            | Exp      | Graphene       | Multi   | Defects  |        | b  | a  |    |     |    |    |     |
| cite:liu-2015-selec-trend          | MD       | Graphene       | Mono    | Porous   | N/H    | b  |    | b  | a   |    |    | b   |
| cite:sun-2015-applic-nanop         | MD       | Graphene       | Mono    | Porous   | N/H    | a  |    |    | a   |    |    | b   |
|------------------------------------+----------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:blankenburg-2010-porous-graph | DFT, MD  | PG             | Mono    |          |        | c  | b  | d  | b   | a  | a  |     |
| cite:schrier-2012-carbon-dioxid    | MD       | PG-ES1         | Mono    |          |        | b  | b  |    | a   |    |    |     |
| cite:brockway-2013-noble-gas       | DFT, MD  | PG-ES1         | Mono    |          |        | b  | b  | b  | b   | a  | a  | c   |
|------------------------------------+----------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | 18 nm   |          |        | b  | b  |    | b   |    | a  | b   |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide | 3-7 nm  |          |        | b  | b  |    | a   |    | b  | b   |
|------------------------------------+----------+----------------+---------+----------+--------+----+----+----+-----+----+----+-----|
| cite:zhu-2015-c-n                  | DFT      | C2N            | Mono    |          |        | b  | b  | b  | b   | b  | a  | b   |
| cite:li-2015-effic-helium          | DFT, MD  | g-C3N4         | Mono    |          |        | b  |    | b  | b   | b  | a  | b   |

*** Water-gas shift
CO + H2O -> CO2 + H2

| Reference                          | Methods  | 2D             | CO | H2O | CO2 | H2 |
|                                    |          | Material       |    |     |     |    |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:celebi-2014-ultim-permeat     | Exp      | Graphene       |    |     | b   | a  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:blankenburg-2010-porous-graph | DFT      | PG             | c  |     | b   | a  |
| cite:li-2010-two-dimen-polyp       | DFT      | PG             | b  |     | b   | a  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:tao-2014-tunab-hydrog         | DFT, MD  | PG-ES1         |    |     | b   | a  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:nair-2012-unimp-permeat       | Exp, MD  | Graphene oxide |    | a   |     | b  |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide |    |     | b   | a  |
| cite:li-2013-ultrat-molec          | Exp      | Graphene oxide | b  |     | b   | a  |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide |    |     | b   | a  |
| cite:kim-2013-selec-gas            | Exp      | Graphene oxide |    |     | a   | b  |
|------------------------------------+----------+----------------+----+-----+-----+----|
| cite:jiao-2011-graph               | DFT, TST | Graphdiyne     |    |     | b   | a  |

*** Nobel gas separation
He, Ne, Ar, Kr

| Reference                          | Methods  | 2D             | He | Ne | Ar | Kr |
|                                    |          | Material       |    |    |    |    |
|------------------------------------+----------+----------------+----+----+----+----|
| cite:wesołowski-2011-pillar-graph  | MD       | Graphene       | c  |    | b  | a  |
|------------------------------------+----------+----------------+----+----+----+----|
| cite:blankenburg-2010-porous-graph | DFT      | PG             | a  | a  | d  |    |
|------------------------------------+----------+----------------+----+----+----+----|
| cite:zhu-2015-c-n                  | DFT      | C2N            | a  | b  | b  |    |
| cite:li-2015-effic-helium          | DFT, MD  | g-C3N4         | a  | b  | b  |    |

** TODO H2 transport comparison
Use the following works to generate a table with comparisons of H2 transport
- cite:koenig-2012-selec-molec 
- cite:jiang-2009-porous-graph 
- cite:blankenburg-2010-porous-graph

* Scripts

** 2016-03-07: Remote copying
*Note 2016-05-18* - Copying is better done by maintaining the git repo. 

To Gilgamesh:
#+BEGIN_SRC sh
scp ~/Google_Drive/projects/hydrogen2D/hydrogen2D.org devonw@gilgamesh.cheme.cmu.edu:projects/hydrogen2D
#+END_SRC

#+RESULTS:

To host:
#+BEGIN_SRC sh
scp devonw@gilgamesh.cheme.cmu.edu:projects/hydrogen2D/hydrogen2D.org ~/Google_Drive/projects/hydrogen2D
#+END_SRC

To update buffer
#+BEGIN_SRC 
M-x revert-buffer
#+END_SRC

** 2016-05-10: Tramp remote execution
This is a way to run code on a remote server while maintaining the code locally. It works for basic things that have text output. It doesn't work for things like ASE's view, which spawns a gui, and I haven't tried it for running vasp codes (not sure how directories would work out exactly -> may need to use absolute paths).

Check tramp works
#+begin_src sh :dir /devonw@gilgamesh.cheme.cmu.edu: :results output
echo "Executed by `whoami` on `hostname` in `pwd`"
#+end_srC

#+RESULTS:
: Executed by devonw on gilgamesh.cheme.cmu.edu in /home-guest/devonw

Test what $PATH is defined as. May need to copy the remote's path to the tramp path (Don't know why they'd want this to be different except for speed(?)).
#+begin_src sh :dir /ssh:devonw@gilgamesh.cheme.cmu.edu: :results output
#source ~/.bash_profile
#echo $PATH
#source .bash_profile
echo $PATH
#+end_src

#+RESULTS:
: /opt/kitchingroup/vasp-5.3.5/vtstscripts-914:/home-research/jkitchin/bin:/opt/vtk/bin:/opt/kitchingroup/vasp-5.3.5/ase-s16/tools:/opt/kitchingroup/vasp-5.3.5/jasp-s16/jasp/bin:/opt/kitchingroup/vasp-5.3.5/bin:/usr/mpi/intel/openmpi-1.4-qlc/bin:/opt/kitchingroup/CANOPY/Canopy_64bit/User/bin:/opt/maui/bin:/opt/fav/bin:/usr/local/texlive/2012/bin/x86_64-linux:/opt/intel/Compiler/11.1/072/bin/intel64:/opt/intel/impi/4.0.0.028/intel64/bin:/usr/lib64/qt-3.3/bin:/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin:/usr/share/pvm3/lib:/sbin:/usr/sbin:/usr/local/sbin

Modules are used to load in python code (?). Weird that this doesn't print what it does in shell.
#+begin_src sh :dir /devonw@gilgamesh.cheme.cmu.edu: :results output
source ~/.bash_profile
module list
#+end_src

#+RESULTS:

Test remote execution of a python file. The import statements working is the important part.
#+BEGIN_SRC python :results output :dir /devonw@gilgamesh.cheme.cmu.edu:
import os
from ase import Atoms
import numpy as np
from jasp import *
a = 5
print(a)
#+END_SRC

#+RESULTS:
: 5

Local python test. Unless you've installed ase and jasp locally, this shouln't work but the previous block should have.
#+BEGIN_SRC python :results output
import numpy as np
from ase import Atoms
from jasp import *
a = 5
print(a)
#+END_SRC

#+RESULTS:

** 2016-05-23: Test vasp is working on the server

#+BEGIN_SRC python
import sys

from ase import Atoms, Atom
from ase.structure import molecule
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
JASPRC['queue.walltime'] = '00:30:00'

atoms = molecule('C2H6')
atoms.center(vacuum=4)

ENCUTS = [300]
energies_en = []
forces_en = []
ready = True
for en in ENCUTS:
    job_name = '~/tmp/vasp_test/molecules/c2h6-en-{0}'.format(en)
    with jasp(job_name,
              encut=en,
              xc='PBE',
              atoms=atoms) as calc:
        try:
            energies_en.append(atoms.get_potential_energy())
            forces_en.append(atoms.get_forces())
        except (VaspSubmitted, VaspQueued):
            ready = False
            print("Still processing: {}".format(job_name))

if not ready:
    import sys; sys.exit()

print("{0:5s}    {1:7s}    {2:9s}".format("ENCUT", "Energy", "Max force"))
print("{0:5s}    {1:7s}    {2:9s}".format("", "[eV]", "[eV/Ang]"))
print("-----------------------------")
for i, energy, force in zip(ENCUTS, energies_en, forces_en):
    print("{0:5d}    {1:7.3f}    {2:9.3f}".format(i, energy, force.max()))
#+END_SRC

#+RESULTS:
: Still processing: ~/tmp/vasp_test/molecules/c2h6-en-300

** TODO Better movies

** 2016-05-31: View atoms
#+BEGIN_SRC python
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
    
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]

def view_atoms(name):
    images = []
    for i, h in enumerate(heights):
	with jasp('./dft/' + name + '/d={0:0.2f}'.format(h)) as calc:
	    atoms = calc.get_atoms()
	    images.append(atoms)
    view(images)

base_name = 'transport/g-mono/3x3/pore=1/molec=CO2/'

name_free = base_name + 'linear-unconst_all'
#view_atoms(name_free)

name_uncon = base_name + 'linear-unconst_G'
#view_atoms(name_uncon)

name_con = base_name + 'linear-const'
view_atoms(name_con)
#+END_SRC

#+RESULTS:

** TODO 2016-06-02: Improve energy curve resolution at curves
Suggest more points to improve the resolution of a total energy curve for a transporting molecule through a 2D material plane.

#+BEGIN_SRC python


#+END_SRC

* Toolbox

#+BEGIN_SRC python :tangle devon_toolbox.py :results drawer
import os
import sys
from types import ModuleType

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt

import seaborn as sns
sns.set_style("white")

def bp(info=None):
    """A breakpoint to view something and stop the rest of the script."""
    if isinstance(info, Atoms):
        view(info)    
    elif isinstance(info, list):
        if all(isinstance(i, Atoms) for i in info):
            view(info)
        else:
            for i in info:
                print(i)
                print("")
    elif info is not None:
        print(info)

    sys.exit()


def center(atoms):
    """Return the position (x,y,z) of the center of the cell."""
    cell = np.array(atoms.get_cell())
    center = (cell[0] + cell[1]) / 2
    center += cell[2] / 2
    return center


def is_the_same(x, fun, *args):
    """True if the object is unchanged during the function call."""
    import copy
    y = copy.deepcopy(x)
    fun(*args)
    return x == y


def get_neighbors(atoms, index, layer, cutoff=4.0):
    """Return neighbor indices of the atom at index for a cutoff distance.

    Determines a list of neighboring atoms to the index atom. It uses a cutoff distance to determine the absolute distance away from an atom that would constitute it as a neighbor.

    Args:
        atoms (Atoms): Cell of atoms with multiple layers of a 2D material.
        index (int): atoms[index] is the atom used to find its neighbors.
        layer (List[int]): Indices of atoms in the layer of question.
        cutoff (float): If an atom's position away is less than cutoff, it is a neighbor.
        
    Returns:
        A list of indices (int) of neighbors in atoms.
    """
    neighbors = []
    pos = atoms[index].position
    layer_atoms = [a for a in atoms if a.index in layer]
    for a in layer_atoms:
        dist = np.linalg.norm(a.position - pos)
        if dist <= cutoff and dist > 0.001:
            neighbors.append(a.index)

    return neighbors


def make_pore(atoms, indices):
    """Delete atoms at indices to create a pore."""
    for index in sorted(indices, reverse=True):
        del atoms[index]


def paint_atoms(atoms, indices, sym=None, layers=None):
    """Update the chemical symbol of atoms in the list of indices."""
    if sym is not None:
        symbols = sym
    else:
        symbols = ["N", "O", "B", "F"]

    if layers is not None:
        for i in indices:
            for j, l in enumerate(layers):
                if i in l:
                    atoms[i].symbol = symbols[j % len(symbols)]
    else:
        for i in indices:
            atoms[i].symbol = symbols[0]


def set_vacuum(atoms, vacuum):
    """Center atoms in the z-direction in a cell of size vacuum.

    Centers atoms in a unitcell with space above and below of 1/2 * vacuum. Assumes the current unitcell is centered and cell length changes only in the z-direction.
    
    Args:
        atoms (Atoms): Unitcell of atoms
        vacuum (float): Height of new unitcell

    Returns:
        An Atoms object with the new cell height.
    """
    cell = atoms.get_cell()
    center_old = cell[2][2] / 2.
    center_new = vacuum / 2.
    cell[2][2] = vacuum
    atoms.set_cell(cell)

    for atom in atoms:
        atom.position[2] = center_new - (center_old - atom.position[2])

def result(name, calc, fu=None):
    """Print a brief calculation report."""
    atoms = calc.get_atoms()
    energy = atoms.get_potential_energy()

    if energy is None:
        stat = "Inprogress."
    else:
        time = calc.get_elapsed_time()
        stat = "Energy = {:0.4f}. Calc time: {:.0f} min.".format(energy, time/60.)

    print(name + ": " + stat)

def status_converged(energy, time):
    print("Final structure calculation: Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(energy, time/60.))


def status_inprogress():
    print("Final structure calculation: In progress.")


def status_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


def structure(atoms, layers=1, molecs=0, thresh=2.0):
    """Return lists of the indices of different structures in a unitcell.
    
    Specifically used for my 2D material transport structures to retrieve layers and molecules. Starts from height of z=0 and moves upwards. Note: A k-means algorithm could work well here, but the one currently (2016-06-06) in scipy did not work reliably here due to some randomness. It may be worthwhile to look into it more if we want to define molecules in 3D space.

    Args:
        atoms (Atoms): Unitcell of atoms
        layers (int): Number of layers
        molecs (int): Number of molecules. 0 or 1. >1 not implemented.
        thresh (float): Total height of a layer.

    Returns:
        Dict containing indices of atoms representing layers and molecules.
        
        Example:
        {'layers': [[0, 1, 4, 5], [2, 3, 6, 7]]
         'molecs': [8,9]}
    """
    structure = {}
    structure['layers'] = []
    structure['molecs'] = []
    unaccounted = [atom for atom in atoms]
    
    for layer in range(layers):
        anchor = closest_atom_to_height(unaccounted, 0)

        group = []
        for atom in unaccounted:
            dist = abs(anchor.position[2] - atom.position[2])
            if dist <= thresh:
                group.append(atom)


        indices = [g.index for g in group]
        structure['layers'].append(indices)
        unaccounted = [a for a in unaccounted if a.index not in indices]
    
    if molecs > 0:
        structure['molecs'].append([a.index for a in unaccounted])

    return structure


def closest_atom(atoms, position, exclude=None):
    """Return the index of the atom closest to a position."""
    choices = [a.index for a in atoms]

    if exclude is not None:
        choices = [i for i in choices if i not in exclude]

    closest = None
    min_dist = None
    for i in choices:
        dist = np.linalg.norm(atoms[i].position - position)
        if np.absolute(dist) < min_dist or closest is None:
            min_dist = dist
            closest = i

    return closest


def closest_atom_to_height(atoms, height):
    """Return the first atom closest to height in the z-direction."""
    closest = atoms[0]
    min_dist = abs(height - closest.position[2])

    for atom in atoms:
        dist = abs(height - atom.position[2])
        if dist < min_dist:
            closest = atom
            min_dist = dist

    return closest


def spline(x, y, points=200):
    """Return x and y spline values over the same range as x."""
    from scipy.interpolate import interp1d
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(x[0], x[-1], points)
    y_interp = spline(x_lin)

    return [x_lin, y_interp]


def print_image(path, data, fig_name=None, caption=None):
    if caption is not None:
        print('#+CAPTION: {}'.format(caption))
    if fig_name is not None:
        print('#+NAME: fig:{}'.format(fig_name))
    print(write_image(path, data))


def write_image(path, data, options=None):
    file_path = './img/' + path
    directory = file_path[:file_path.rfind('/')]
    if not os.path.exists(directory):
        os.makedirs(directory)
    
    if isinstance(data, ModuleType):
        if data.__name__ == "matplotlib.pyplot":
            data.savefig(file_path)
    elif isinstance(data, Atoms):
        #atoms.rotate('x', np.pi/-5) # TODO: do a .copy() instead of this
        file_path += '.png'
        ase_write(file_path, data)

    else:
        print("No functionality for type = {}".format(type(data)))

    return '[[' + file_path + ']]'
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

*** Examples
**** get_neighbors
#+BEGIN_SRC python
from jasp import *
from ase import Atoms, Atom
import devon_toolbox as dtb

with jasp('dft/material/g-bi/final') as calc:
    atoms = calc.get_atoms()
i = 3
atoms = atoms.repeat([i,i,1])

struct = dtb.structure(atoms, layers=2)
index = 16
neighbors = dtb.get_neighbors(atoms, index, struct['layers'][0])
neighbors.append(index)
dtb.paint_atoms(atoms, neighbors, layers=struct['layers'])
dtb.bp(atoms)
#+END_SRC

#+RESULTS:
: [2, 3, 6, 7, 10, 11, 14, 15, 18, 19, 22, 23, 26, 27, 30, 31, 34, 35]
: 
: [0, 1, 4, 5, 8, 9, 12, 13, 16, 17, 20, 21, 24, 25, 28, 29, 32, 33]
: 

* TODO twodee

Functions to facilitate easy 2D material unitcell manipulation.

#+BEGIN_SRC python :tangle twodee.py :results drawer
from ase import Atoms, Atom
import numpy as np
from vasp import Vasp

import devon_toolbox as dtb


## Graphene class with neighbor cutoffs

def center_layer(atoms, layer):
    """Return the position (x,y,z) of the center of a layer of atoms.

    Args:
        atoms (Atoms): Cell of atoms.
        layer (List[int]): Indices of atoms in layer."""
    cell = np.array(atoms.get_cell())
    center = (cell[0] + cell[1]) / 2
    atoms = [a for a in atoms if a.index in layer]
    center += [0, 0, np.mean([a.position[2] for a in atoms])]
    return center


def create_base(mat='graphene', layers=1, size=1):
    """Return a relaxed structure of the base material with n layers."""
    name = 'vasp/base/mat={0}/layers={1}'.format(mat, layers)
    atoms = Vasp(name).get_atoms()

    atoms = atoms.repeat([size, size, 1])
    return atoms


def edges(atoms, unitcell):
    """Return lists of indices of edge atoms in each layer.

    Args:
        atoms (Atoms): Superstructure of atoms
        unitcell (Atoms): Unitcell making up the superstructure
    """
    edges = []
    [u1, u2, u3] = unitcell.get_cell()
    [a1, a2, a3] = atoms.get_cell()
    repeats = a1[0] / u1[0]
    for u in unitcell:
        edges.append(u.index)
        for i in range(1, int(repeats)):
            pos1 = u.position + i * u1
            pos2 = u.position + i * u2
            edges.append(dtb.closest_atom(atoms, pos2))
            edges.append(dtb.closest_atom(atoms, pos1))

    return edges


def get_neighbors(atoms, index, layer, cutoff=4.0):
    """Return neighbor indices of the atom at index for a cutoff distance.

    Determines a list of neighboring atoms to the index atom. It uses a cutoff distance to determine the absolute distance away from an atom that would constitute it as a neighbor.

    Args:
        atoms (Atoms): Cell of atoms with multiple layers of a 2D material.
        index (int): atoms[index] is the atom used to find its neighbors.
        layer (List[int]): Indices of atoms in the layer of question.
        cutoff (float): If an atom's position away is less than cutoff, it is a neighbor.
        
    Returns:
        A list of indices (int) of neighbors in atoms.
    """
    neighbors = []
    pos = atoms[index].position
    layer_atoms = [a for a in atoms if a.index in layer]
    for a in layer_atoms:
        dist = np.linalg.norm(a.position - pos)
        if dist <= cutoff and dist is not 0.000:
            neighbors.append(a.index)

    return neighbors


def layers(atoms, thresh=2.0):
    """Return lists of the indices of atoms in layers, top layer first.

    Note that the threshold could cause inaccuracy after a drastic relaxation.
    """
    height = atoms.get_cell()[2][2]
    layers = []
    unaccounted = [atom for atom in atoms]
    while len(unaccounted) > 0:
        anchor = dtb.closest_atom_to_height(unaccounted, height)

        group = []
        for atom in unaccounted:
            dist = abs(anchor.position[2] - atom.position[2])
            if dist <= thresh:
                group.append(atom)

        indices = [g.index for g in group]
        layers.append(indices)
        unaccounted = [a for a in unaccounted if a.index not in indices]
    
    return layers


def set_vacuum(atoms, vacuum):
    """Center atoms in the z-direction in a cell of size vacuum.

    Centers atoms in a unitcell with space above and below of 1/2 * vacuum. Assumes the current unitcell is centered and cell length changes only in the z-direction.
    
    Args:
        atoms (Atoms): Unitcell of atoms
        vacuum (float): Height of new unitcell

    Returns:
        An Atoms object with the new cell height.
    """
    cell = atoms.get_cell()
    center_old = cell[2][2] / 2.
    center_new = vacuum / 2.
    cell[2][2] = vacuum
    atoms.set_cell(cell)

    for atom in atoms:
        atom.position[2] = center_new - (center_old - atom.position[2])
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

** Function examples

Show what each function does.

*** candidates

#+BEGIN_SRC python :results drawer
from sets import Set

import devon_toolbox as dtb
import twodee as td


graphene_cutoff = 1.5 # Angstrom. Should put this somewhere more permanent.

def candidates(atoms, layers, exclude=None, depth=None):
    pos_center = td.center_layer(atoms, layers[0])
    center_atom = dtb.closest_atom(atoms, pos_center)
    can = [center_atom]
    cans = [can]

    indices = [a.index for a in atoms if a.index not in exclude] #TODO devon: There's a cleaner way to do this. Need something for layers here?

    candidates_loop(atoms, indices, can, cans, center_atom, depth)

    return cans


def candidates_loop(atoms, indices, can, cans, index, depth, step=1):
    layer = [i for i in indices] #TODO devon: Clean up get_neighbors.
    neighbors = dtb.get_neighbors(atoms, index, layer, graphene_cutoff)

    if len(neighbors) == 1:
        n = neighbors[0]
        if depth is None or step + 1 < depth:
            candidates_loop(atoms, indices, can, cans, n, depth, step+1)
    
    neighbors = [n for n in neighbors if len(neighbors) > 1 and  n not in can]
    for n in neighbors:
        c = [i for i in can]
        c.append(n)
        c.sort()
        if c not in cans:
            cans.append(c)
            if depth is None or step + 1 < depth:
                candidates_loop(atoms, indices, c, cans, n, depth, step+1)
            

unitcell = td.create_base("graphene", layers=1)
size = 3
atoms = td.create_base("graphene", layers=1, size=size)
#dtb.bp(atoms)
layers = td.layers(atoms)
edges = td.edges(atoms, unitcell)#
cans = candidates(atoms, layers, exclude=edges)

dtb.bp(cans)
images = []
dtb.paint_atoms(atoms, edges)
for i, c in enumerate(cans):
    a = atoms.copy()
    dtb.paint_atoms(a, c, sym="O")
    dtb.write_image('tmp/algo-movie/size={1}/{0:0>4}'.format(i, size), a)

dtb.bp()
dtb.bp(cans)
#+END_SRC

#+RESULTS:
:RESULTS:
[9]

[8, 9]

[8, 9, 10]

[8, 9, 10, 11]

[8, 9, 10, 11, 16]

[8, 9, 10, 11, 15, 16]

[8, 9, 10, 11, 14, 15, 16]

[8, 9, 10, 11, 16, 17]

[8, 9, 10, 11, 15, 16, 17]

[8, 9, 10, 11, 14, 15, 16, 17]

[8, 9, 14]

[8, 9, 14, 15]

[8, 9, 14, 15, 16]

[8, 9, 11, 14, 15, 16]

[8, 9, 14, 15, 16, 17]

[8, 9, 11, 14, 15, 16, 17]

[9, 10]

[9, 10, 11]

[9, 10, 11, 16]

[9, 10, 11, 15, 16]

[9, 10, 11, 14, 15, 16]

[9, 10, 11, 16, 17]

[9, 10, 11, 15, 16, 17]

[9, 10, 11, 14, 15, 16, 17]

[9, 14]

[9, 14, 15]

[9, 14, 15, 16]

[9, 11, 14, 15, 16]

[9, 14, 15, 16, 17]

[9, 11, 14, 15, 16, 17]

:END:

*** center_layer

#+BEGIN_SRC python :results drawer
import devon_toolbox as dtb
import twodee as td

atoms = td.create_base("graphene", layers=2, size=4)
layers = td.layers(atoms)
center1 = td.center_layer(atoms, layers[0])
center2 = td.center_layer(atoms, layers[1])
c1 = dtb.closest_atom(atoms, center1)
c2 = dtb.closest_atom(atoms, center2)
dtb.paint_atoms(atoms, [c1, c2])
dtb.bp(atoms)
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

*** create_base

#+BEGIN_SRC python :results drawer
import devon_toolbox as dtb
import twodee as td

atoms = td.create_base("graphene", size=3)

dtb.bp(atoms)
#+END_SRC

#+RESULTS:

*** edges

#+BEGIN_SRC python :results drawer
import devon_toolbox as dtb
import twodee as td

unitcell = td.create_base("graphene", layers=2)
atoms = td.create_base("graphene", layers=2, size=5)

e = td.edges(atoms, unitcell)
dtb.paint_atoms(atoms, e)
dtb.bp(atoms)
dtb.bp([e])
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

* jasp
** Testing
*** DONE nsw test
    CLOSED: [2016-06-09 Thu 09:19]

Brief test to understand if nsw is having an effect on my calculations being run in the queue.

 #+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *

import devon_toolbox as dtb


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

i = 3
atoms = atoms.repeat([i,i,1])
del atoms[17:19]

nsw = [0]
print("Did not converge: [10]")

def calculate(nsw):
    name = 'material/g-bi/3x3/pore=1/test/nsw={:0.0f}'.format(nsw)
    dtb.print_image(name, atoms)

    with jasp('./jasp/' + name,
                encut=520,
                kpts=(6,6,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=nsw,             # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            dtb.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            dtb.status_inprogress()
            ready = False
            pass


for n in nsw:
    print("nsw: {:}".format(n))
    calculate(n)
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Did not converge: [10]
 nsw: 0
 [[./img/material/g-bi/3x3/pore=1/test/nsw=0.png]]
 Final structure calculation: Energy/f.u. = -8.742. Calculation time: 308 min.
 :END:

 The calculation did not converge for nsw=10 (probably should have expected).

** Material
*** INPROGRESS Graphene monolayer
**** Pristine

#+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

name = 'material/g-mono/final'

print(atoms)
with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

print(atoms)
file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Atoms(symbols='C2', positions=..., cell=[[2.130422493309719, -1.23,
      0.0], [2.130422493309719, 1.23, 0.0], [0.0, 0.0, 18.0]],
      pbc=[False, False, False])
Final structure calculation: Atoms: 2. Energy/f.u. = -9.228. Calculation time: 6 min.
Atoms(symbols='C2', positions=..., cell=[[2.130422493309719, -1.23,
      0.0], [2.130422493309719, 1.23, 0.0], [0.0, 0.0, 18.0]],
      pbc=[False, False, False], calculator=Vasp(...))
[[./img/material/g-mono/final.png]]
:END:

**** Pore=1 (One carbon defect)
***** DONE 3x3. Non-centered, standard spacing
      CLOSED: [2016-06-02 Thu 14:44]
Looking back, the non-centered versions of these calculations are not as intuitive to watch in a movie format. Also, the desired ease of having the symmetry point being at the gamma point does not carry to pore sizes greater than 1.

#+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys
#JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 3
atoms = unitcell.repeat((i,i,1))

print('Graphene 3x3 pore=1:'.format(i))

del atoms[0]

name = 'material/g-mono/3x3/pore=1/non-centered/vac=10'

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Graphene 3x3 pore=1:
Final structure calculation: Atoms: 17. Energy/f.u. = -8.759. Calculation time: 188 min.
[[./img/material/g-mono/3x3/pore=1/non-centered/vac=10.png]]
:END:

***** DONE 3x3. Non-centered, wide vaccuum
      CLOSED: [2016-06-02 Thu 14:43]
Looking back, it doesn't really make sense to run these calculations with a vacuum any wider than the distance where planes of the superstructure do not interact.

#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *

import devon_toolbox as dtb


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 20.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 3
atoms = unitcell.repeat((i,i,1))

print('Graphene 3x3 pore=1:'.format(i))

del atoms[0]

name = 'material/g-mono/3x3/pore=1/non-centered/vac=20'
print(dtb.write_image(name, atoms))

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=100,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass
#+END_SRC

#+RESULTS:
:RESULTS:
Graphene 3x3 pore=1:
[[./img/material/g-mono/3x3/pore=1/non-centered/vac=20.png]]
Final structure calculation: Energy/f.u. = -8.760. Calculation time: 589 min.
:END:

***** DONE 3x3. Centered
      CLOSED: [2016-06-02 Thu 14:44]
Based on the gas transport graph, a distance of 8 Angstrom between graphene planes should be more than sufficient to say the planes are not interacting. 

#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'

import devon_toolbox as dtb


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 8.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 3
atoms = atoms.repeat((i,i,1))

print("Position of defect: {}".format(atoms[9].position))
del atoms[9]

name = 'material/g-mono/3x3/pore=1/final'
dtb.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=100,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass
#+END_SRC

#+RESULTS:
:RESULTS:
7.38
:END:

As expected, the energy is the same as the energies of the non-centered calculations.

***** DONE 4x4, 5x5, 6x6
      CLOSED: [2016-06-10 Fri 10:48]
****** DONE Same kpts
       CLOSED: [2016-06-10 Fri 10:48]
Calculate the energies for a monolayer of graphene with a single carbon pore for larger unitcells (more spacing between the pores).

#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '4GB'

import devon_toolbox as dtb


def calculate(name):
    ready = True
    with jasp('./jasp/' + name,
                encut=520,
                kpts=(3,3,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=0,             # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            dtb.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            dtb.status_inprogress()
            ready = False
            pass

    return ready


with jasp("jasp/material/g-mono/final") as calc:
    graphene = calc.get_atoms()

sizes = [2, 3, 4, 5, 6]
pores = [6, 9, 20, 24, 29]


for i, p in zip(sizes, pores):
    atoms = graphene.copy()
    atoms = atoms.repeat((i,i,1))
    dtb.make_pore(atoms, [p])

    print("size={0}x{0}".format(i))
    name = 'material/g-mono/{0:0.0f}x{0:0.0f}/pore=1/convergence/size'.format(i)
    dtb.print_image(name, atoms)
    calculate(name)
#+END_SRC

#+RESULTS:
:RESULTS:
size=2x2
[[./img/material/g-mono/2x2/pore=1/convergence/size.png]]
Final structure calculation: Energy/f.u. = -8.139. Calculation time: 3 min.
size=3x3
[[./img/material/g-mono/3x3/pore=1/convergence/size.png]]
Final structure calculation: Energy/f.u. = -8.743. Calculation time: 16 min.
size=4x4
[[./img/material/g-mono/4x4/pore=1/convergence/size.png]]
Final structure calculation: Energy/f.u. = -8.959. Calculation time: 87 min.
size=5x5
[[./img/material/g-mono/5x5/pore=1/convergence/size.png]]
Final structure calculation: Energy/f.u. = -9.056. Calculation time: 872 min.
size=6x6
[[./img/material/g-mono/6x6/pore=1/convergence/size.png]]
Final structure calculation: Energy/f.u. = -9.107. Calculation time: 2167 min.
:END:

****** DONE kpts differing by size
       CLOSED: [2016-06-09 Thu 10:27]
Calculate the energies for a monolayer of graphene with a single carbon pore for larger unitcells (more spacing between the pores).

#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '4GB'

import devon_toolbox as dtb


def calculate(name, k):
    ready = True
    with jasp('./jasp/' + name,
                encut=520,
                kpts=(k,k,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=0,             # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            dtb.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            dtb.status_inprogress()
            ready = False
            pass

    return ready


with jasp("jasp/material/g-mono/final") as calc:
    graphene = calc.get_atoms()

sizes = [2, 3, 4, 5, 6]
pores = [6, 9, 20, 24, 29]
kpts =  [5, 5, 5, 1, 1]

for i, p, k in zip(sizes, pores, kpts):
    atoms = graphene.copy()
    atoms = atoms.repeat((i,i,1))
    dtb.make_pore(atoms, [p])

    print("size={0}x{0}".format(i))
    name = 'material/g-mono/{0:0.0f}x{0:0.0f}/pore=1/convergence/size/kpts={1:0.0f}'.format(i, k)
    dtb.print_image(name, atoms)
    calculate(name, k)
#+END_SRC

#+RESULTS:
:RESULTS:
size=2x2
[[./img/material/g-mono/2x2/pore=1/convergence/size/kpts=5.png]]
Final structure calculation: Energy/f.u. = -8.180. Calculation time: 3 min.
size=3x3
[[./img/material/g-mono/3x3/pore=1/convergence/size/kpts=5.png]]
Final structure calculation: Energy/f.u. = -8.746. Calculation time: 18 min.
size=4x4
[[./img/material/g-mono/4x4/pore=1/convergence/size/kpts=5.png]]
Final structure calculation: Energy/f.u. = -8.958. Calculation time: 120 min.
size=5x5
[[./img/material/g-mono/5x5/pore=1/convergence/size/kpts=1.png]]
Final structure calculation: Energy/f.u. = -9.044. Calculation time: 340 min.
size=6x6
[[./img/material/g-mono/6x6/pore=1/convergence/size/kpts=1.png]]
Final structure calculation: Energy/f.u. = -9.090. Calculation time: 736 min.
:END:

**** INPROGRESS Pore=10 (Ten carbon defect)
***** TODO 4x4
****** TODO final
TODO: This does not match the results to the other k-point values. Check the nsw convergence test (running now) to see if it affects the energy.

#+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
import numpy as np
import sys
#JASPRC['queue.walltime'] = '10:00:00'

import devon_toolbox as dtb


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 20.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 4
atoms = unitcell.repeat((i,i,1))

print('Graphene 4x4 pore=10:'.format(i))
del atoms[26]
del atoms[17:21]
del atoms[11:15]
del atoms[5]


name = 'material/g-mono/4x4/pore=10/final'

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass

dtb.print_image(name, atoms)
#+END_SRC

#+RESULTS:
:RESULTS:
Graphene 4x4 pore=10:
Final structure calculation: Energy/f.u. = -8.167. Calculation time: 1933 min.
[[./img/material/g-mono/4x4/pore=10/final.png]]
:END:

****** DONE Convergence: kpts
       CLOSED: [2016-06-10 Fri 09:32]

#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '4GB'

import devon_toolbox as dtb


with jasp("jasp/material/g-mono/final") as calc:
    atoms = calc.get_atoms()

i = 4
atoms = atoms.repeat((i,i,1))

print('Graphene 4x4 pore=10:'.format(i))
del atoms[26]
del atoms[17:21]
del atoms[11:15]
del atoms[5]

kpts = [1, 3, 5]

name = 'material/g-mono/4x4/pore=10/convergence'
dtb.print_image(name, atoms)

def calculate(k):
    with jasp('./jasp/' + name + '/kpts={0:0.0f}'.format(k),
                encut=520,
                kpts=(k,k,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=0,             # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            dtb.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            dtb.status_inprogress()
            ready = False
            pass

for k in kpts:
    print("kpts={0}x{0}x1".format(k))
    calculate(k)
#+END_SRC

#+RESULTS:
:RESULTS:
Graphene 4x4 pore=10:
[[./img/material/g-mono/4x4/pore=10/convergence.png]]
kpts=1x1x1
Final structure calculation: Energy/f.u. = -8.128. Calculation time: 25 min.
kpts=3x3x1
Final structure calculation: Energy/f.u. = -8.112. Calculation time: 96 min.
kpts=5x5x1
Final structure calculation: Energy/f.u. = -8.112. Calculation time: 202 min.
:END:

****** INPROGRESS Convergence: nsw

#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'

import devon_toolbox as dtb


with jasp("jasp/material/g-mono/final") as calc:
    atoms = calc.get_atoms()

i = 4
atoms = atoms.repeat((i,i,1))

print('Graphene 4x4 pore=10:'.format(i))
del atoms[26]
del atoms[17:21]
del atoms[11:15]
del atoms[5]

name = 'material/g-mono/4x4/pore=10/convergence/nsw=50'
dtb.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=520,
            kpts=(3,3,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,             # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

***** DONE 5x5
      CLOSED: [2016-06-09 Thu 23:25]
****** DONE final
       CLOSED: [2016-06-08 Wed 15:42]
#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
JASPRC['queue.mem'] = '4GB'

import devon_toolbox as dtb


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 10.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

i = 5
atoms = unitcell.repeat((i,i,1))

print('Graphene 5x5 pore=10:'.format(i))
del atoms[32:35]
del atoms[23:27]
del atoms[15:18]

name = 'material/g-mono/5x5/pore=10/final'

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=0,             # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass

dtb.print_image(name, atoms)
#+END_SRC

#+RESULTS:
:RESULTS:
Graphene 5x5 pore=10:
Final structure calculation: Energy/f.u. = -8.604. Calculation time: 2933 min.
[[./img/material/g-mono/5x5/pore=10/final.png]]
:END:

Looking at the structure in view(atoms) shows that the structure has not changed at all from the base structure. All lattice constants are still 2.46, though the energy/f.u. is higher. Not sure if this structure is accurate.

****** INPROGRESS ediffg -0.05 comarison
#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'

import devon_toolbox as dtb


with jasp('jasp/material/g-mono/final') as calc:
    unitcell = calc.get_atoms()
i = 5
atoms = unitcell.repeat((i,i,1))

print('Graphene 5x5 pore=10:'.format(i))
dtb.make_pore(atoms, [15, 16, 17, 23, 24, 25, 26, 32, 33, 34])

name = 'jasp/material/g-mono/5x5/pore=10/convergence/ediffg=-0.05'
with jasp(name,
            encut=520,
            kpts=(5,5,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            ediffg=-0.05,
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass

dtb.print_image(name, atoms)
#+END_SRC

#+RESULTS:
:RESULTS:
Graphene 5x5 pore=10:
Final structure calculation: In progress.
[[./img/jasp/material/g-mono/5x5/pore=10/convergence/ediffg=-0.05.png]]
:END:

Looking at the structure in view(atoms) shows that the structure has not changed at all from the base structure. All lattice constants are still 2.46, though the energy/f.u. is higher. Not sure if this structure is accurate.

****** DONE Convergence: kpts
       CLOSED: [2016-06-09 Thu 22:21]

#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '4GB'

import devon_toolbox as dtb


with jasp("jasp/material/g-mono/final") as calc:
    atoms = calc.get_atoms()

i = 5
atoms = atoms.repeat((i,i,1))

print('Graphene 5x5 pore=10:'.format(i))
del atoms[32:35]
del atoms[23:27]
del atoms[15:18]


kpts = [1, 3, 5]

name = 'material/g-mono/5x5/pore=10/convergence'
dtb.print_image(name, atoms)

def calculate(k):
    with jasp('./jasp/' + name + '/kpts={0:0.0f}'.format(k),
                encut=520,
                kpts=(k,k,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=0,             # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            dtb.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            dtb.status_inprogress()
            ready = False
            pass

for k in kpts:
    print("kpts={0}x{0}x1".format(k))
    calculate(k)
#+END_SRC

#+RESULTS:
:RESULTS:
Graphene 5x5 pore=10:
[[./img/material/g-mono/5x5/pore=10/convergence.png]]
kpts=1x1x1
Final structure calculation: Energy/f.u. = -8.580. Calculation time: 96 min.
kpts=3x3x1
Final structure calculation: Energy/f.u. = -8.604. Calculation time: 966 min.
kpts=5x5x1
Final structure calculation: Energy/f.u. = -8.604. Calculation time: 1098 min.
:END:

Looks to be converged within 0.001 eV with a 3x3x1 k-point grid. A 1x1x1 grid is within ~0.02 eV. 

***** DONE 6x6
      CLOSED: [2016-06-21 Tue 14:44]

#+BEGIN_SRC python :results drawer
import numpy as np
import sys

from ase import Atom, Atoms
from ase.io import write as ase_write
from ase.visualize import view
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '8GB'

import devon_toolbox as dtb


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")

with jasp('jasp/material/g-mono/final') as calc:
    atoms = calc.get_atoms()
dtb.set_vacuum(atoms, 16)
i = 6
atoms = atoms.repeat((i,i,1))
pore = [19, 29, 30, 31, 32, 39, 40, 41, 42, 52]
dtb.make_pore(atoms, pore)

print('Graphene {0:1.1f}x{0:1.1f} pore=10:'.format(i))

name = 'material/g-mono/6x6/pore=10/vac=16/kpts=1'
dtb.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=520,
            kpts=(1,1,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass

#+END_SRC

#+RESULTS:
:RESULTS:
Graphene 6.0x6.0 pore=10:
[[./img/material/g-mono/6x6/pore=10/vac=16/kpts=1.png]]
Final structure calculation: Energy/f.u. = -8.850. Calculation time: 2929 min.

:END:

*** Graphene bilayer
**** Pristine
***** DONE final
      CLOSED: [2016-06-09 Thu 10:32]
 Structure obtained from https://www.tfkp.physik.uni-erlangen.de/download/theses/master_daniel-branski.pdf.

 #+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
JASPRC['queue.walltime'] = '10:00:00'


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

name = 'material/g-bi/final'

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=90,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
 #+END_SRC

 #+RESULTS:
 :RESULTS:
 Final structure calculation: Atoms: 4. Energy/f.u. = -9.225. Calculation time: 14 min.
 [[./img/material/g-bi/final.png]]
 :END:

**** TODO Pore=1
***** TODO 3x3
TODO: Update path to /final

#+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *

import devon_toolbox as dtb


def print_converged(num_atoms, energy, time):
    print("Final structure calculation: Atoms: {}. Energy/f.u. = {:0.3f}. Calculation time: {:.0f} min.".format(num_atoms, energy, time/60.))

def print_inprogress():
    print("Final structure calculation: In progress.")


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

i = 3
atoms = atoms.repeat([i,i,1])
del atoms[17:19]

name = 'material/g-bi/3x3/pore=1'

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=150,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        print_converged(len(atoms), energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        print_inprogress()
        ready = False
        pass

file_path = './img/' + name + '.png'
ase_write(file_path, atoms)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Final structure calculation: Atoms: 34. Energy/f.u. = -8.759. Calculation time: 277 min.
[[./img/material/g-bi/3x3/pore=1.png]]
:END:

***** TODO 4x4
****** DONE final
       CLOSED: [2016-06-21 Tue 15:04]
#+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from jasp import *

import devon_toolbox as dtb


with jasp('jasp/material/g-bi/final') as calc:
    atoms = calc.get_atoms()
dtb.set_vacuum(atoms, 16)
i = 4
atoms = atoms.repeat([i,i,1])
pore = [41, 42]
dtb.make_pore(atoms, pore)

name = 'material/g-bi/{0:0.0f}x{0:0.0f}/pore=1'.format(i)
dtb.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=520,
            kpts=(3,3,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass
#+END_SRC

#+RESULTS:
:RESULTS:
[[./img/material/g-bi/4x4/pore=1.png]]
Final structure calculation: Energy/f.u. = -8.967. Calculation time: 3287 min.
:END:

****** DONE nsw=0, kpts=1
       CLOSED: [2016-06-21 Tue 15:04]
#+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from jasp import *

import devon_toolbox as dtb


with jasp('jasp/material/g-bi/final') as calc:
    atoms = calc.get_atoms()
dtb.set_vacuum(atoms, 16)
i = 4
atoms = atoms.repeat([i,i,1])
pore = [41, 42]
dtb.make_pore(atoms, pore)

name = 'material/g-bi/{0:0.0f}x{0:0.0f}/pore=1/convergence/nsw=0'.format(i)
dtb.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=520,
            kpts=(3,3,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=0,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass

name = 'material/g-bi/{0:0.0f}x{0:0.0f}/pore=1/convergence/kpts=1'.format(i)
dtb.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=520,
            kpts=(1,1,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=0,            # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass
#+END_SRC

#+RESULTS:
:RESULTS:
[[./img/material/g-bi/4x4/pore=1/convergence/nsw=0.png]]
Final structure calculation: Energy/f.u. = -8.955. Calculation time: 418 min.
[[./img/material/g-bi/4x4/pore=1/convergence/kpts=1.png]]
Final structure calculation: Energy/f.u. = -8.979. Calculation time: 156 min.
:END:

**** CANCELED Pore=10
     CLOSED: [2016-06-21 Tue 14:59]
***** CANCELED Final
      CLOSED: [2016-06-09 Thu 09:14]

#+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
JASPRC['queue.mem'] = '8GB'

import devon_toolbox as dtb


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 16. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

i = 6
atoms = atoms.repeat([i,i,1])

pore_l1 = [57, 60, 61, 80, 81, 84, 85, 104, 105, 108]
pore_l2 = [35, 38, 39, 58, 59, 62, 63, 82, 83, 86]
pore = pore_l1 + pore_l2
pore.sort()
for p in reversed(pore):
#    atoms[p].symbol = "N"
    del atoms[p]


name = 'material/g-bi/6x6/pore=10/final'
dtb.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=520,
            kpts=(6,6,1),
            xc='PBE',          # GGA functional type
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=100,           # max number of steps to relax
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass
#+END_SRC

#+RESULTS:
:RESULTS:
[[./img/material/g-bi/6x6/pore=10/final.png]]
Final structure calculation: In progress.
:END:

***** CANCELED Kpts test
      CLOSED: [2016-06-09 Thu 09:15]
Test the effect that k-points may have on the convergence of a 6x6 repeated bilayer graphene.

#+BEGIN_SRC python :results drawer
import sys

from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
JASPRC['queue.mem'] = '8GB'

import devon_toolbox as dtb


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 16. # vaccuum height between material planes

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])

i = 6
atoms = atoms.repeat([i,i,1])

pore_l1 = [57, 60, 61, 80, 81, 84, 85, 104, 105, 108]
pore_l2 = [35, 38, 39, 58, 59, 62, 63, 82, 83, 86]
pore = pore_l1 + pore_l2
pore.sort()
for p in reversed(pore):
#    atoms[p].symbol = "N"
    del atoms[p]


name = 'material/g-bi/6x6/pore=10'
dtb.print_image(name, atoms)

kpts = [3, 5] 
print("Failed to complete: [1, 2, 4, 7]")

def calculate(k):
    with jasp('./jasp/' + name + '/kpts={:0.0f}'.format(k),
                encut=520,
                kpts=(k,k,1),
                xc='PBE',          # GGA functional type
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=100,           # max number of steps to relax
                atoms=atoms) as calc:
        try:
            calc.calculate()
            energy = atoms.get_potential_energy()/len(atoms)
            dtb.status_converged(energy, float(get_elapsed_time(calc)))
        except (VaspSubmitted, VaspQueued):
            dtb.status_inprogress()
            ready = False
            pass

for k in kpts:
    print("kpts=({0},{0},1):".format(k))
    calculate(k)
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

The 

| k-points (ixix1) | Memory requested [GB] |
|                1 |                   0.9 |
|                2 |                   3.0 |
|                3 |                   2.5 |
|                4 |                  10.4 |
|                5 |                   5.9 |
|                6 |                  22.9 |
|                7 |                  10.8 |

***** CANCELED Minimal resource use
      CLOSED: [2016-06-21 Tue 14:59]
Run a calculation with the least possible resources. It's okay if the energy is a poor calculation, let's just see if time-wise this type of calculation is feasible.

Some notes
- sigma for bi-layer smaller than monolayer 


#+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from ase.visualize import view
from ase.io import write as ase_write
from jasp import *
#JASPRC['queue.walltime'] = '10:00:00'
#JASPRC['queue.mem'] = '2GB'

import devon_toolbox as dtb


with jasp('jasp/material/g-bi/final') as calc:
    atoms = calc.get_atoms()
dtb.set_vacuum(atoms, 16)
i = 6
atoms = atoms.repeat([i,i,1])

pore_l1 = [57, 60, 61, 80, 81, 84, 85, 104, 105, 108]
pore_l2 = [35, 38, 39, 58, 59, 62, 63, 82, 83, 86]
pore = pore_l1 + pore_l2
dtb.make_pore(atoms, pore)

name = 'material/g-bi/6x6/pore=10/convergence/minimal'
dtb.print_image(name, atoms)

with jasp('./jasp/' + name,
            encut=350,
            kpts=(1,1,1),
            xc='LDA',
            ismear=0,
            sigma=0.2,
            isif=2,
            ibrion=1,
            nsw=50,
            atoms=atoms) as calc:
    try:
        calc.calculate()
        energy = atoms.get_potential_energy()/len(atoms)
        dtb.status_converged(energy, float(get_elapsed_time(calc)))
    except (VaspSubmitted, VaspQueued):
        dtb.status_inprogress()
        ready = False
        pass
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

** Transport
*** Graphene monolayer
**** Linear NEB
***** TODO H2 linear-const-const

#+BEGIN_SRC python :results drawer
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

import devon_toolbox as dtb


def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('jasp/material/g-mono/3x3/pore=1/final') as calc:
    graphene = calc.get_atoms()

dtb.set_vacuum(graphene, 20)
defect_pos = np.array([5.681, 0., 10.]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
#heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2.]
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1.5, -2.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
HH_bond = 0.74 # Bond length [Ang]
for i, h in enumerate(heights):
    H2 = Atoms([Atom('H', defect_pos + (0, 0, h - HH_bond/2.)),
                Atom('H', defect_pos + (0, 0, h + HH_bond/2.))])
    atoms[i].extend(H2)


# Hydrogen fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'H':
        hydrogen_constraint = [FixAtoms(indices=[atom.index])]
        break


# Graphene total constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Unconstrained graphene, unconstrained molecule
# Constraint one carbon so the entire plane doesn't shift as the molecule approaches
atoms_free = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_free[i].set_constraint([FixAtoms(indices=[0])])

# Unconstrained graphene, constrained molecule
atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(hydrogen_constraint)

# Constrained graphene, constrained molecule
atoms_con = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_con[i].set_constraint(hydrogen_constraint + graphene_constraint)

ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./jasp/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/'

print('Unconstrained graphene, unconstrained hydrogen:')
name_free = base_name + 'linear-free-free'
TE_free = []
calculate(name_free, atoms_free, TE_free)

#print('')
#print('Unconstrained graphene, constrained leading hydrogen:')
#name_uncon = base_name + 'linear-free-const'
#TE_uncon = []
#calculate(name_uncon, atoms_uncon, TE_uncon)

print('')
print('Constrained graphene, constrained leading hydrogen:')
name_con = base_name + 'linear-const-const'
TE_con = []
calculate(name_con, atoms_con, TE_con)

if not ready:
    sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
#TE_uncon = np.array(TE_uncon)
#TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(-2,10,200)
    plt.plot(x_lin, spline(x_lin), style)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
spline_free = interp1d(heights, TE_free, kind='cubic')
plt.plot(heights, TE_free, 'ro', label='No constraints')
#plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
#plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Center of molecule height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Unconstrained graphene, unconstrained hydrogen:
Distance: 10.00. Energy = -155.683. Calculation time: 807 min.
Distance:  9.00. Energy = -155.683. Calculation time: 811 min.
Distance:  8.00. Energy = -155.683. Calculation time: 422 min.
Distance:  7.00. Energy = -155.684. Calculation time: 421 min.
Distance:  6.00. Energy = -155.684. Calculation time: 582 min.
Distance:  5.00. Energy = -155.687. Calculation time: 582 min.
Distance:  4.00. Energy = -155.695. Calculation time: 307 min.
Distance:  3.00. Energy = -155.690. Calculation time: 299 min.
Distance:  2.50. Energy = -155.681. Calculation time: 1802 min.
Distance:  2.00. Energy = -155.707. Calculation time: 2886 min.
Distance:  1.50. Energy = -155.696. Calculation time: 2803 min.
Distance:  1.00. Energy = -158.272. Calculation time: 6159 min.
Distance:  0.50. Energy = -158.278. Calculation time: 5042 min.
Distance:  0.00. Energy = -155.239. Calculation time: 1338 min.
Distance: -0.50. Energy = -158.278. Calculation time: 5150 min.
Distance: -1.50. Energy = -155.695. Calculation time: 3496 min.
Distance: -2.00. Energy = -155.671. Calculation time: 2967 min.

Constrained graphene, constrained leading hydrogen:
Distance: 10.00. Energy = -155.683. Calculation time: 484 min.
Distance:  9.00. Energy = -155.683. Calculation time: 574 min.
Distance:  8.00. Energy = -155.683. Calculation time: 834 min.
Distance:  7.00. Energy = -155.684. Calculation time: 415 min.
Distance:  6.00. Energy = -155.684. Calculation time: 849 min.
Distance:  5.00. Energy = -155.687. Calculation time: 622 min.
Distance:  4.00. Energy = -155.695. Calculation time: 587 min.
Distance:  3.00. Energy = -155.690. Calculation time: 757 min.
Distance:  2.50. Energy = -155.611. Calculation time: 1040 min.
Distance:  2.00. Energy = -155.283. Calculation time: 981 min.
Distance:  1.50. Energy = -154.461. Calculation time: 1070 min.
Distance:  1.00. Energy = -153.815. Calculation time: 508 min.
Distance:  0.50. Energy = -154.247. Calculation time: 515 min.
Distance:  0.00. Energy = -154.990. Calculation time: 509 min.
Distance: -0.50. Energy = -155.130. Calculation time: 787 min.
Distance: -1.50. Energy = -154.380. Calculation time: 464 min.
Distance: -2.00. Energy = -155.269. Calculation time: 477 min.

[[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison.png]]
:END:

The free-free calculation did not converge at a molecule height of -1.0 Ang.

**** TODO Linear - 3x3 pore=1
This is the type of transport I used for the final project in 0640. Essentially, I believe it tries to simulate an ab-initio MD calculation, which I need to look into.

Pros:
- Better than a L-J MD at each point.

Cons:
- This should be setup as a NEB calculation
- Meaningful calculations are too costly.
- Pore distances must be kept small.

***** H2
****** const-const, const-free. Same params as final project
Somewhat done for now. The unconstrained graphene + constrained H2 molecule calculations did not finish in time. Unfortunately, that is the one that would be most accurate to what is really going on with the transport.

#+BEGIN_SRC python :results drawer
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

import devon_toolbox as dtb


def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('jasp/material/g-mono/3x3/pore=1/final') as calc:
    graphene = calc.get_atoms()

dtb.set_vacuum(graphene, 20)
defect_pos = np.array([5.681, 0., 10.]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
#heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2.]
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1.5, -2.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
HH_bond = 0.74 # Bond length [Ang]
for i, h in enumerate(heights):
    H2 = Atoms([Atom('H', defect_pos + (0, 0, h - HH_bond/2.)),
                Atom('H', defect_pos + (0, 0, h + HH_bond/2.))])
    atoms[i].extend(H2)


# Hydrogen fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'H':
        hydrogen_constraint = [FixAtoms(indices=[atom.index])]
        break


# Graphene total constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Unconstrained graphene, unconstrained molecule
# Constraint one carbon so the entire plane doesn't shift as the molecule approaches
atoms_free = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_free[i].set_constraint([FixAtoms(indices=[0])])

# Unconstrained graphene, constrained molecule
atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(hydrogen_constraint)

# Constrained graphene, constrained molecule
atoms_con = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_con[i].set_constraint(hydrogen_constraint + graphene_constraint)

ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./jasp/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/'

print('Unconstrained graphene, unconstrained hydrogen:')
name_free = base_name + 'linear-free-free'
TE_free = []
calculate(name_free, atoms_free, TE_free)

#print('')
#print('Unconstrained graphene, constrained leading hydrogen:')
#name_uncon = base_name + 'linear-free-const'
#TE_uncon = []
#calculate(name_uncon, atoms_uncon, TE_uncon)

print('')
print('Constrained graphene, constrained leading hydrogen:')
name_con = base_name + 'linear-const-const'
TE_con = []
calculate(name_con, atoms_con, TE_con)

if not ready:
    sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
#TE_uncon = np.array(TE_uncon)
#TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(-2,10,200)
    plt.plot(x_lin, spline(x_lin), style)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
spline_free = interp1d(heights, TE_free, kind='cubic')
plt.plot(heights, TE_free, 'ro', label='No constraints')
#plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
#plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Center of molecule height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Unconstrained graphene, unconstrained hydrogen:
Distance: 10.00. Energy = -155.683. Calculation time: 807 min.
Distance:  9.00. Energy = -155.683. Calculation time: 811 min.
Distance:  8.00. Energy = -155.683. Calculation time: 422 min.
Distance:  7.00. Energy = -155.684. Calculation time: 421 min.
Distance:  6.00. Energy = -155.684. Calculation time: 582 min.
Distance:  5.00. Energy = -155.687. Calculation time: 582 min.
Distance:  4.00. Energy = -155.695. Calculation time: 307 min.
Distance:  3.00. Energy = -155.690. Calculation time: 299 min.
Distance:  2.50. Energy = -155.681. Calculation time: 1802 min.
Distance:  2.00. Energy = -155.707. Calculation time: 2886 min.
Distance:  1.50. Energy = -155.696. Calculation time: 2803 min.
Distance:  1.00. Energy = -158.272. Calculation time: 6159 min.
Distance:  0.50. Energy = -158.278. Calculation time: 5042 min.
Distance:  0.00. Energy = -155.239. Calculation time: 1338 min.
Distance: -0.50. Energy = -158.278. Calculation time: 5150 min.
Distance: -1.50. Energy = -155.695. Calculation time: 3496 min.
Distance: -2.00. Energy = -155.671. Calculation time: 2967 min.

Constrained graphene, constrained leading hydrogen:
Distance: 10.00. Energy = -155.683. Calculation time: 484 min.
Distance:  9.00. Energy = -155.683. Calculation time: 574 min.
Distance:  8.00. Energy = -155.683. Calculation time: 834 min.
Distance:  7.00. Energy = -155.684. Calculation time: 415 min.
Distance:  6.00. Energy = -155.684. Calculation time: 849 min.
Distance:  5.00. Energy = -155.687. Calculation time: 622 min.
Distance:  4.00. Energy = -155.695. Calculation time: 587 min.
Distance:  3.00. Energy = -155.690. Calculation time: 757 min.
Distance:  2.50. Energy = -155.611. Calculation time: 1040 min.
Distance:  2.00. Energy = -155.283. Calculation time: 981 min.
Distance:  1.50. Energy = -154.461. Calculation time: 1070 min.
Distance:  1.00. Energy = -153.815. Calculation time: 508 min.
Distance:  0.50. Energy = -154.247. Calculation time: 515 min.
Distance:  0.00. Energy = -154.990. Calculation time: 509 min.
Distance: -0.50. Energy = -155.130. Calculation time: 787 min.
Distance: -1.50. Energy = -154.380. Calculation time: 464 min.
Distance: -2.00. Energy = -155.269. Calculation time: 477 min.

[[./img/transport/g-mono/3x3/pore=1/molec=H2/TE-comparison.png]]
:END:

The free-free calculation did not converge at a molecule height of -1.0 Ang.

****** INPROGRESS free-const

#+BEGIN_SRC python :results drawer
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

import devon_toolbox as dtb


def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('jasp/material/g-mono/3x3/pore=1/final') as calc:
    graphene = calc.get_atoms()

dtb.set_vacuum(graphene, 20)
defect_pos = np.array([5.681, 0., 10.]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
#heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2.]
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1.5, -2.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
HH_bond = 0.74 # Bond length [Ang]
for i, h in enumerate(heights):
    H2 = Atoms([Atom('H', defect_pos + (0, 0, h - HH_bond/2.)),
                Atom('H', defect_pos + (0, 0, h + HH_bond/2.))])
    atoms[i].extend(H2)


# Hydrogen fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'H':
        hydrogen_constraint = [FixAtoms(indices=[atom.index])]
        break


# Graphene total constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]


# Unconstrained graphene, constrained molecule
atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(hydrogen_constraint)


ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./jasp/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(5,5,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=0,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/'

print('Unconstrained graphene, constrained leading hydrogen:')
name_uncon = base_name + 'linear-free-const'
TE_uncon = []
calculate(name_uncon, atoms_uncon, TE_uncon)

if not ready:
    sys.exit()

# Consider the change in energy from lowest energy state
TE_uncon = np.array(TE_uncon)
TE_uncon -= min(TE_uncon)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(-2,10,200)
    plt.plot(x_lin, spline(x_lin), style)

from ase.visualize import view
view(atoms_uncon)
dtb.bp()
dtb.bp(atoms_uncon)
# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plot_spline(heights, TE_uncon, plt, 'g-')
plt.xlabel('Center of molecule height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Unconstrained graphene, constrained leading hydrogen:
Distance: 10.00. Energy = -155.682. Calculation time:  88 min.
Distance:  9.00. Energy = -155.682. Calculation time:  96 min.
Distance:  8.00. Energy = -155.682. Calculation time: 304 min.
Distance:  7.00. Energy = -155.683. Calculation time:  78 min.
Distance:  6.00. Energy = -155.683. Calculation time:  79 min.
Distance:  5.00. Energy = -155.686. Calculation time: 249 min.
Distance:  4.00. Energy = -155.694. Calculation time: 126 min.
Distance:  3.00. Energy = -155.688. Calculation time: 197 min.
Distance:  2.50. Energy = -155.606. Calculation time:  66 min.
Distance:  2.00. Energy = -155.263. Calculation time: 153 min.
Distance:  1.50. Energy = -154.363. Calculation time:  54 min.
Distance:  1.00. Energy = -153.467. Calculation time: 228 min.
Distance:  0.50. Energy = -153.590. Calculation time:  86 min.
Distance:  0.00. Energy = -153.925. Calculation time: 262 min.
Distance: -0.50. Energy = -153.590. Calculation time:  72 min.
Distance: -1.50. Energy = -154.363. Calculation time:  98 min.
Distance: -2.00. Energy = -155.263. Calculation time: 109 min.
Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

:END:

****** INPROGRESS free-const 2

#+BEGIN_SRC python :results drawer
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

import devon_toolbox as dtb


def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('jasp/material/g-mono/3x3/pore=1/final') as calc:
    graphene = calc.get_atoms()

dtb.set_vacuum(graphene, 20)
defect_pos = np.array([5.681, 0., 10.]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
#heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2.]
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1.5, -2.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
HH_bond = 0.74 # Bond length [Ang]
for i, h in enumerate(heights):
    H2 = Atoms([Atom('H', defect_pos + (0, 0, h - HH_bond/2.)),
                Atom('H', defect_pos + (0, 0, h + HH_bond/2.))])
    atoms[i].extend(H2)


# Hydrogen fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'H':
        hydrogen_constraint = [FixAtoms(indices=[atom.index])]
        break


# Graphene total constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]


# Unconstrained graphene, constrained molecule
atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(hydrogen_constraint)


ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./jasp/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(5,5,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=50,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/nsw=50/'

dtb.bp(atoms_uncon)
print('Unconstrained graphene, constrained leading hydrogen:')
name_uncon = base_name + 'linear-free-const'
TE_uncon = []
calculate(name_uncon, atoms_uncon, TE_uncon)

if not ready:
    sys.exit()

# Consider the change in energy from lowest energy state
TE_uncon = np.array(TE_uncon)
TE_uncon -= min(TE_uncon)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(-2,10,200)
    plt.plot(x_lin, spline(x_lin), style)

# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plot_spline(heights, TE_uncon, plt, 'g-')
plt.xlabel('Center of molecule height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

Atoms(symbols='C17H2', positions=..., tags=...,
      cell=[[6.391267479929157, -3.69, 0.0], [6.391267479929157, 3.69,
      0.0], [0.0, 0.0, 20.0]], pbc=[True, True, True],
      constraint=FixAtoms(indices=[17]), calculator=Vasp(...))

:END:

***** DONE N2
      CLOSED: [2016-06-08 Wed 16:05]

Only ran the       


#+BEGIN_SRC python
import copy
import numpy as np
import matplotlib.pyplot as plt
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('jasp/material/g-mono/3x3/pore=1/non-centered/vac=20') as calc:
    graphene = calc.get_atoms()
plane_height = 10.
defect_pos = np.array([0, 0., plane_height]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]
atoms =  [Atoms(graphene) for i in range(len(heights))]
bond1 = 1.13 # Bond length [Ang]
for i, h in enumerate(heights):
    N2 = Atoms([Atom('N', defect_pos + (0, 0, h - bond1/2.)),
                Atom('N', defect_pos + (0, 0, h + bond1/2.))])
    atoms[i].extend(N2)


# Fixed position constraint
for atom in atoms[0]:
    if atom.symbol == 'N':
        molecule_constraint = [FixAtoms(indices=[atom.index])]
        break

# Graphene constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Make images with constraints
atoms_free = copy.deepcopy(atoms)

atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(molecule_constraint)

atoms_con = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_con[i].set_constraint(molecule_constraint + graphene_constraint)

ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./jasp/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=N2/'

#print('Unconstrained graphene, unconstrained hydrogen:')
#name_free = base_name + 'linear-unconst_all'
#TE_free = []
#calculate(name_free, atoms_free, TE_free)
#
#print('')
#print('Unconstrained graphene, constrained leading hydrogen:')
#name_uncon = base_name + 'linear-unconst_G'
#TE_uncon = []
#calculate(name_uncon, atoms_uncon, TE_uncon)

print('')
print('Constrained graphene, constrained leading atom:')
name_con = base_name + 'linear-const'
TE_con = []
calculate(name_con, atoms_con, TE_con)

if not ready:
    sys.exit()
sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
TE_uncon = np.array(TE_uncon)
TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.plot(heights, TE_free, label='No constraints')
plt.plot(heights, TE_uncon, label='Leading H atom constrained')
plt.plot(heights, TE_con, label='All constrained')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:

***** DONE CO2
      CLOSED: [2016-06-08 Wed 16:05]

#+BEGIN_SRC python
import copy
import numpy as np
import matplotlib.pyplot as plt
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Graphene base
with jasp('jasp/material/g-mono/3x3/pore=1/vac=20') as calc:
    graphene = calc.get_atoms()
plane_height = 10.
defect_pos = np.array([0, 0., plane_height]) # defect position


# Transport initial images. Distance of molecule's center from grahene plane
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]
CO_bond = 1.21 # Bond length [Ang]
atoms =  [Atoms(graphene) for i in range(len(heights))]
for i, h in enumerate(heights):
    CO2 = Atoms([Atom('O', defect_pos + (0., 0., h - CO_bond)),
                 Atom('C', defect_pos + (0., 0., h)),
                 Atom('O', defect_pos + (0., 0., h + CO_bond))])
    atoms[i].extend(CO2)

# Fixed position constraint
for i, atom in enumerate(atoms[0]):
    if atom.symbol == 'O':
        molecule_constraint = [FixAtoms(indices=[atom.index+1])]
        break

# Graphene constraint
# (for comparison with final project results)
graphene_constraint = [FixAtoms(indices=[atom.index for atom in atoms[0] if atom.symbol=='C'])]

# Make images with constraints
atoms_free = copy.deepcopy(atoms)

atoms_uncon = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_uncon[i].set_constraint(molecule_constraint)

atoms_con = copy.deepcopy(atoms)
for i in range(len(heights)):
    atoms_con[i].set_constraint(molecule_constraint + graphene_constraint)


ready = True
def calculate(name, atoms, TE):
    for i, h in enumerate(heights):
        with jasp('./jasp/' + name + '/d={0:0.2f}'.format(h),
                    encut=520,
                    kpts=(6,6,1),
                    xc='PBE',          # GGA functional type
                    ismear=0,          # Gaussian smearing
                    sigma=0.2,         # "Metallic" system smearing
                    isif=2,            # relax positions only
                    ibrion=2,          # conjugate gradient optimizer
                    nsw=100,            # max number of steps to relax
                    atoms=atoms[i]) as calc:
            try:
                calc.calculate()
                energy = atoms[i].get_potential_energy()
                TE.append(energy)
                print_converged(h, energy, float(get_elapsed_time(calc)))
            except (VaspSubmitted, VaspQueued):
                print_inprogress(h)
                ready = False
                pass


base_name = 'transport/g-mono/3x3/pore=1/molec=CO2/'

print('Unconstrained graphene, unconstrained molecule:')
name_free = base_name + 'linear-unconst_all'
TE_free = []
calculate(name_free, atoms_free, TE_free)

print('')
print('Unconstrained graphene, constrained CO2 carbon:')
name_uncon = base_name + 'linear-unconst_G'
TE_uncon = []
calculate(name_uncon, atoms_uncon, TE_uncon)

print('')
print('Constrained graphene, constrained CO2 carbon:')
name_con = base_name + 'linear-const'
TE_con = []
calculate(name_con, atoms_con, TE_con)

if not ready:
    sys.exit()
sys.exit()

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
TE_uncon = np.array(TE_uncon)
TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


# Plot a comparison of the total energies of each constraint type
print('')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.plot(heights, TE_free, label='No constraints')
plt.plot(heights, TE_uncon, label='Leading H atom constrained')
plt.plot(heights, TE_con, label='All constrained')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
#+begin_example
Unconstrained graphene, unconstrained molecule:
Distance: 10.00. Energy = -171.861. Calculation time: 387 min.
Distance:  9.00. Energy = -171.861. Calculation time: 604 min.
Distance:  8.00. Energy = -171.861. Calculation time: 556 min.
Distance:  7.00. Energy = -171.861. Calculation time: 339 min.
Distance:  6.00. Energy = -171.861. Calculation time: 347 min.
Distance:  5.00. Energy = -171.863. Calculation time: 381 min.
Distance:  4.00. Energy = -171.803. Calculation time: 355 min.
Distance:  3.00. Energy = -171.800. Calculation time: 2632 min.
Distance:  2.50. Energy = -171.741. Calculation time: 4954 min.
Distance:  2.00. Energy = -171.777. Calculation time: 4830 min.
Distance:  1.50. Energy = -173.486. Calculation time: 2459 min.
Distance:  1.00. Energy = -172.259. Calculation time: 1947 min.
Distance:  0.50. Energy = -172.258. Calculation time: 2127 min.
Distance:  0.00. Energy = -170.043. Calculation time: 1282 min.

Unconstrained graphene, constrained CO2 carbon:
Distance: 10.00. Energy = -171.861. Calculation time: 265 min.
Distance:  9.00. Energy = -171.861. Calculation time: 277 min.
Distance:  8.00. Energy = -171.861. Calculation time: 291 min.
Distance:  7.00. Energy = -171.861. Calculation time: 275 min.
Distance:  6.00. Energy = -171.861. Calculation time: 267 min.
Distance:  5.00. Energy = -171.863. Calculation time: 284 min.
Distance:  4.00. Energy = -171.803. Calculation time: 273 min.
Distance:  3.00. Energy = -171.757. Calculation time: 2732 min.
Distance:  2.50. Energy = -171.796. Calculation time: 4690 min.
Distance:  2.00. Energy = -171.787. Calculation time: 4402 min.
Distance:  1.50. In progress.
Distance:  1.00. Energy = -172.244. Calculation time: 814 min.
Distance:  0.50. Energy = -172.256. Calculation time: 2039 min.
Distance:  0.00. Energy = -170.043. Calculation time: 786 min.

Constrained graphene, constrained CO2 carbon:
Distance: 10.00. Energy = -171.861. Calculation time: 300 min.
Distance:  9.00. Energy = -171.861. Calculation time: 303 min.
Distance:  8.00. Energy = -171.861. Calculation time: 325 min.
Distance:  7.00. Energy = -171.861. Calculation time: 323 min.
Distance:  6.00. Energy = -171.861. Calculation time: 313 min.
Distance:  5.00. Energy = -171.863. Calculation time: 318 min.
Distance:  4.00. Energy = -171.803. Calculation time: 215 min.
Distance:  3.00. Energy = -170.736. Calculation time: 249 min.
Distance:  2.50. Energy = -168.686. Calculation time: 247 min.
Distance:  2.00. Energy = -166.160. Calculation time: 122 min.
Distance:  1.50. Energy = -171.428. Calculation time: 432 min.
Distance:  1.00. Energy = -171.304. Calculation time: 306 min.
Distance:  0.50. Energy = -170.840. Calculation time: 504 min.
Distance:  0.00. Energy = -169.706. Calculation time: 424 min.
#+end_example

* Vasp

Calculations using the new Vasp().

** Tests

Mostly tests for energy convergence based on different calculation parameters.

*** DONE base/mat=graphene/layers=1 - kpts
    CLOSED: [2016-06-22 Wed 10:11]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp

import devon_toolbox as dtb


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

ks = [3, 5, 7, 9, 11, 13, 15, 17]
energies = []
for k in ks:
    atoms = unitcell.copy()
    name = 'vasp/test/base/mat=graphene/layers=1/kpts={0}'.format(k)
    calc = Vasp(name,
                xc='PBE',          # GGA functional type
                encut=520,
                kpts=[k,k,1],
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms)
    dtb.result('kpts={0:2.0f} x {0:2.0f} x 1'.format(k), calc)
    energies.append(atoms.get_potential_energy())

plt.plot(ks, energies)
plt.xlabel("k-points (i x i x 1)")
plt.ylabel("Total energy [eV]")
dtb.print_image(name + '.png', plt)
#+END_SRC

#+RESULTS:
:RESULTS:
kpts= 3 x  3 x 1: Energy = -17.8966. Calc time: 0 min.
kpts= 5 x  5 x 1: Energy = -18.4222. Calc time: 0 min.
kpts= 7 x  7 x 1: Energy = -18.4602. Calc time: 0 min.
kpts= 9 x  9 x 1: Energy = -18.4329. Calc time: 1 min.
kpts=11 x 11 x 1: Energy = -18.4479. Calc time: 1 min.
kpts=13 x 13 x 1: Energy = -18.4494. Calc time: 1 min.
kpts=15 x 15 x 1: Energy = -18.4446. Calc time: 2 min.
kpts=17 x 17 x 1: Energy = -18.4477. Calc time: 1 min.
[[./img/vasp/test/base/mat=graphene/layers=1/kpts=17.png]]
:END:

An 11x11x1 k-point grid is converged within 10 meV.

*** DONE base/mat=graphene/layers=1 - ediffg
    CLOSED: [2016-06-22 Wed 10:11]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from vasp import Vasp

import devon_toolbox as dtb


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

ediffgs = [1e-2, 1e-3, 1e-4, -0.1, -0.05, -0.01]

for e in ediffgs:
    atoms = unitcell.copy()
    name = 'vasp/test/base/mat=graphene/layers=1/ediffg={0}'.format(e)
    calc = Vasp(name,
                xc='PBE',          # GGA functional type
                encut=520,
                kpts=[5,5,1],
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                ediffg=e,
                atoms=atoms)
    dtb.result('ediffg={0:7.4f}'.format(e), calc)
#+END_SRC

#+RESULTS:
:RESULTS:
ediffg= 0.0100: Energy = -18.4222. Calc time: 1 min.
ediffg= 0.0010: Energy = -18.4222. Calc time: 0 min.
ediffg= 0.0001: Energy = -18.4222. Calc time: 0 min.
ediffg=-0.1000: Energy = -18.4222. Calc time: 0 min.
ediffg=-0.0500: Energy = -18.4222. Calc time: 1 min.
ediffg=-0.0100: Energy = -18.4222. Calc time: 0 min.
:END:

This is a simple unitcell so the time wasn't greatly affected. Would be better to check this against a complicated pore structure.

*** DONE base/mat=graphene/layers=1 - sigma
    CLOSED: [2016-06-22 Wed 10:42]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from vasp import Vasp

import devon_toolbox as dtb


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

sigmas = [0.01, 0.05, 0.1, 0.15, 0.2, 0.25]

for s in sigmas:
    atoms = unitcell.copy()
    name = 'vasp/test/base/mat=graphene/layers=1/sigma={0}'.format(s)
    calc = Vasp(name,
                xc='PBE',          # GGA functional type
                encut=520,
                kpts=[9,9,1],
                ismear=0,          # Gaussian smearing
                sigma=s,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms)
    dtb.result('sigma={0:4.2f}'.format(s), calc)
#+END_SRC

#+RESULTS:
:RESULTS:
sigma=0.01: Energy = -18.4302. Calc time: 1 min.
sigma=0.05: Energy = -18.4308. Calc time: 1 min.
sigma=0.10: Energy = -18.4315. Calc time: 0 min.
sigma=0.15: Energy = -18.4322. Calc time: 0 min.
sigma=0.20: Energy = -18.4329. Calc time: 1 min.
sigma=0.25: Energy = -18.4336. Calc time: 1 min.
:END:

*** DONE base/mat=graphene/layers=1 - cell size
    CLOSED: [2016-06-22 Wed 10:26]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp

import devon_toolbox as dtb


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

unitcell = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

zs = [6, 10, 14, 16, 18, 20, 22]
energies = []
for z in zs:
    atoms = unitcell.copy()
    dtb.set_vacuum(atoms, z)
    name = 'vasp/test/base/mat=graphene/layers=1/vac={0}'.format(z)
    calc = Vasp(name,
                xc='PBE',          # GGA functional type
                encut=520,
                kpts=[7,7,1],
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms)
    dtb.result('vacuum z={0:2d}'.format(z), calc)
    energies.append(atoms.get_potential_energy())

if None not in energies:
    plt.plot(zs, energies)
    plt.xlabel("Vacuum in z-direction [$\AA$]")
    plt.ylabel("Total energy [eV]")
    dtb.print_image(name + '.png', plt)
#+END_SRC

#+RESULTS:
:RESULTS:
vacuum z= 6: Energy = -18.4404. Calc time: 0 min.
vacuum z=10: Energy = -18.4600. Calc time: 0 min.
vacuum z=14: Energy = -18.4589. Calc time: 0 min.
vacuum z=16: Energy = -18.4601. Calc time: 1 min.
vacuum z=18: Energy = -18.4602. Calc time: 0 min.
vacuum z=20: Energy = -18.4602. Calc time: 1 min.
vacuum z=22: Energy = -18.4602. Calc time: 0 min.
[[./img/vasp/test/base/mat=graphene/layers=1/vac=22.png]]
:END:

The structure is converged within 10 meV at a vacuum distance of 16 Å between graphene layers.

*** DONE base/mat=graphene/layers=2 - kpts-z
    CLOSED: [2016-06-22 Wed 11:39]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp

import devon_toolbox as dtb


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

unitcell = Atoms([Atom('C', rA1),
                    Atom('C', rB1),
                    Atom('C', rA2),
                    Atom('C', rB2)],
                    cell=[a1, a2, a3])


ks = [1, 2, 3]
energies = []
for k in ks:
    atoms = unitcell.copy()
    name = 'vasp/test/base/mat=graphene/layers=2/kptsz={0}'.format(k)
    calc = Vasp(name,
                xc='PBE',          # GGA functional type
                encut=520,
                kpts=[11,11,k],
                ismear=0,          # Gaussian smearing
                sigma=0.2,         # "Metallic" system smearing
                isif=2,            # relax positions only
                ibrion=2,          # conjugate gradient optimizer
                nsw=50,            # max number of steps to relax
                atoms=atoms)
    dtb.result('kptsz={0}'.format(k), calc)
    energies.append(atoms.get_potential_energy())

if None not in energies:
    plt.plot(ks, energies)
    plt.xlabel("k-points (i x i x 1)")
    plt.ylabel("Total energy [eV]")
    dtb.print_image(name + '.png', plt)
#+END_SRC

#+RESULTS:
:RESULTS:
kptsz=1: Energy = -36.8821. Calc time: 2 min.
kptsz=2: Energy = -36.8820. Calc time: 2 min.
kptsz=3: Energy = -36.8821. Calc time: 9 min.
[[./img/vasp/test/base/mat=graphene/layers=2/kptsz=3.png]]
:END:

No change, as expected.

** Base structures

Structures for use in building more complex structures.

*** DONE mat=graphene/layers=1
    CLOSED: [2016-06-22 Wed 11:39]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from vasp import Vasp

import devon_toolbox as dtb


a = 2.46
a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., 18.])

atoms = Atoms([Atom('C', 1./2. * a3),
                  Atom('C', 1./3. * a1 + 1./3. * a2 + 1./2. * a3)],
                  cell=[a1, a2, a3])

name = 'vasp/base/mat=graphene/layers=1'
calc = Vasp(name,
            xc='PBE',          # GGA functional type
            encut=520,
            kpts=[13,13,1],
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms)

print('energy = {0} eV'.format(atoms.get_potential_energy()))
dtb.print_image(name, atoms)
#+END_SRC

#+RESULTS:
:RESULTS:
energy = -18.44932999 eV
[[./img/vasp/base/mat=graphene/layers=1.png]]
:END:

*** DONE mat=graphene/layers=2
    CLOSED: [2016-06-22 Wed 11:39]

#+BEGIN_SRC python :results drawer
from ase import Atoms, Atom
import numpy as np
from vasp import Vasp

import devon_toolbox as dtb


a = 2.46  # lattice constant
b = 3.49  # interlayer distance
gap = np.array([0., 0., b])
vac = 20. # vaccuum on either side of graphene

a1 = a * np.array([3.0**0.5/2., -1./2., 0.])
a2 = a * np.array([3.0**0.5/2., 1./2., 0.])
a3 = np.array([0., 0., vac])

layer1_height = 1./2. * (a3 + gap)
layer2_height = 1./2. * (a3 - gap)
rA1 = 0. + layer1_height
rB1 = a * np.array([1./3.**0.5, 0., 0.]) + layer1_height
rA2 = a * np.array([1./3.**0.5, 0., 0.]) + layer2_height
rB2 = a * np.array([2./3.**0.5, 0., 0.]) + layer2_height

atoms = Atoms([Atom('C', rA1),
               Atom('C', rB1),
               Atom('C', rA2),
               Atom('C', rB2)],
               cell=[a1, a2, a3])


name = 'vasp/base/mat=graphene/layers=2'
calc = Vasp(name,
            xc='PBE',          # GGA functional type
            encut=520,
            kpts=[13,13,1],
            ismear=0,          # Gaussian smearing
            sigma=0.2,         # "Metallic" system smearing
            isif=2,            # relax positions only
            ibrion=2,          # conjugate gradient optimizer
            nsw=50,            # max number of steps to relax
            atoms=atoms)

dtb.result("Final bilayer graphene:", calc)
dtb.print_image(name, atoms)
#+END_SRC

#+RESULTS:
:RESULTS:
Final bilayer graphene:: Energy = -36.8838. Calc time: 1 min.
[[./img/vasp/base/mat=graphene/layers=2.png]]
:END:

* Results
** DONE Final project
   CLOSED: [2016-06-09 Thu 22:20]
*** DONE Bond length
    CLOSED: [2016-06-09 Thu 22:20]

#+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

import devon_toolbox as dtb


fp_dir = '~/techela/s16-06640/final-project/' # Directory of final project.

# Distance of the molecule normal to the graphene plane
heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]

# Calculated distance after relaxation
h_rel = []

BL_h = []
BL_co2 = [[], []]
for i, h in enumerate(heights):

    with jasp(fp_dir + 'transport/G-c-HHc-constraints-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        bond_dist = atoms.get_distance(17,18)
        BL_h.append(bond_dist)
        h_fixed = atoms[17].position[2]
        h_graphene = atoms[0].position[2]
        h_rel_i = h_fixed + (bond_dist / 2.) - h_graphene
        h_rel.append(h_rel_i)

    with jasp(fp_dir + 'transport/G-c-CO2-transport-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        BL_co2[0].append(atoms.get_distance(17,18))
        BL_co2[1].append(atoms.get_distance(18,19))


file_path = './img/final-project/G-bond-length.png'
plt.plot(h_rel, BL_h, 'ro-', label='H2')
plt.plot(heights, BL_co2[0], 'go-', label='CO2 #1')
plt.plot(heights, BL_co2[1], 'bo-', label='CO2 #2')
plt.xlabel('Molecule center distance from graphene plane ($\AA$)')
plt.ylabel('Bond length ($\AA$)')
plt.ylim([0.5,3])
plt.xlim([-3,3])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
[[./img/final-project/G-bond-length.png]]
:END:

*** DONE Barrier energy
    CLOSED: [2016-06-09 Thu 22:20]

#+BEGIN_SRC python :results drawer
from ase import Atom, Atoms
from ase.visualize import view
from jasp import *
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

import devon_toolbox as dtb


fp_dir = '~/techela/s16-06640/final-project/' # Directory of final project.

# Distance of the molecule normal to the graphene plane
heights = [3., 2.5, 2., 1.5, 1., 0.5, 0., -0.5, -1., -1.5, -2, -2.5, -3]

# Calculated distance after relaxation
h_rel = []

TE_h = []
TE_co2 = []
for i, h in enumerate(heights):

    with jasp(fp_dir + 'transport/G-c-HHc-constraints-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        energy = atoms.get_potential_energy()
        TE_h.append(energy)
        bond_dist = atoms.get_distance(17,18)
        h_fixed = atoms[17].position[2]
        h_graphene = atoms[0].position[2]
        h_rel_i = h_fixed + (bond_dist / 2.) - h_graphene
        h_rel.append(h_rel_i)

    with jasp(fp_dir + 'transport/G-c-CO2-transport-yes-hook-d={0:0.2f}'.format(h)) as calc:
        atoms = calc.get_atoms()
        calc.calculate()
        energy = atoms.get_potential_energy()
        TE_co2.append(energy)

TE_h = np.array(TE_h)
TE_h -= min(TE_h)
TE_co2 = np.array(TE_co2)
TE_co2 -= min(TE_co2)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(x[0],x[-1],200)
    print('Max energy: {:0.3f} eV'.format(max(spline(x_lin)))) 
    plt.plot(x_lin, spline(x_lin), style)

print('Energy barriers:')
file_path = './img/final-project/total_energy-comparison.png'
plt.plot(h_rel, TE_h, 'ro', label='H2')
plt.plot(heights, TE_co2, 'go', label='CO2')
plot_spline(h_rel, TE_h, plt, 'r-')
plot_spline(heights, TE_co2, plt, 'g-')
plt.xlabel('Molecule distance from graphene plane ($\AA$)')
plt.ylabel('$\Delta$ Energy (eV)')
plt.xlim([-3.,3.])
plt.ylim([0,5.5])
plt.legend(loc='upper center')
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
Energy barriers:
Max energy: 1.879 eV
Max energy: 4.643 eV
[[./img/final-project/total_energy-comparison.png]]
:END:

Barrier peaks could mean clustering around the pores.

** TODO Transport. Pore=1
#+BEGIN_SRC python
import copy
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import sys

from ase import Atom, Atoms
from ase.constraints import FixAtoms
from ase.visualize import view
from jasp import *

def print_converged(i, energy, time):
    print("Distance: {:5.2f}. Energy = {:8.3f}. Calculation time: {:3.0f} min.".format(i, energy, time/60.))

def print_inprogress(i):
    print("Distance: {:5.2f}. In progress.".format(i))

def print_unconverged(i):
    print("Distance: {:5.2f}. Did not converge.".format(i))


# Transport initial images. Distance of molecule's center from grahene plane
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]

def calculate(name, TE):
    for i, h in enumerate(heights):
        with jasp('./dft/' + name + '/d={0:0.2f}'.format(h)) as calc:
            calc.calculate()
            atoms = calc.get_atoms()
            energy = atoms.get_potential_energy()
            TE.append(energy)


base_name = 'transport/g-mono/3x3/pore=1/molec=H2/'

name_free = base_name + 'linear-unconst_all'
TE_free = []
calculate(name_free, TE_free)

#name_uncon = base_name + 'linear-unconst_G'
#TE_uncon = []
#calculate(name_uncon, TE_uncon)

name_con = base_name + 'linear-const'
TE_con = []
calculate(name_con, TE_con)

# Consider the change in energy from lowest energy state
TE_free = np.array(TE_free)
TE_free -= min(TE_free)
#TE_uncon = np.array(TE_uncon)
#TE_uncon -= min(TE_uncon)
TE_con = np.array(TE_con)
TE_con -= min(TE_con)


def plot_spline(x, y, plt, style):
    spline = interp1d(x, y, kind='cubic')
    x_lin = np.linspace(0,10,1000)
    plt.plot(x_lin, spline(x_lin), style)


print('')
print('Normal view')
file_path = './img/' + base_name + 'TE-comparison.png'
plt.figure(1)
plt.plot(heights, TE_free, 'ro', label='No constraints')
#plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,10])
#plt.ylim([0,0.1])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')

print('')
print('Lennard-Jones potential well and convergence view')
file_path = './img/' + base_name + 'TE-comparison-LJ_zoom.png'
plt.figure(2)
plt.plot(heights, TE_free, 'ro', label='No constraints')
#plt.plot(heights, TE_uncon, 'go', label='Leading H atom constrained')
plt.plot(heights, TE_con, 'bo', label='Leading H + graphene constrained')
plot_spline(heights, TE_free, plt, 'r-')
#plot_spline(heights, TE_uncon, plt, 'g-')
plot_spline(heights, TE_con, plt, 'b-')
plt.xlabel('Height ($\AA$)')
plt.ylabel('Total Energy (eV)')
plt.xlim([0,8])
plt.ylim([-0.15,0.2])
plt.legend()
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:

** DONE Vacuum distance convergence
   CLOSED: [2016-06-08 Wed 15:59]
Look at the distance the molecule away from the graphene plane is to know when it appears to be a free molecule in space and does not exhibit changes in energy due to interaction.

#+BEGIN_SRC python :results drawer
import numpy as np
import matplotlib.pyplot as plt

from ase import Atom, Atoms
from jasp import *

import devon_toolbox as dtb

def closest_atom_distance(atoms):
    pos = atoms.get_positions()
    dist = (pos[17] - pos[0])[2] # leading atom was always #17 in these calculations
    return dist


def calculate(molec, dist, TE, heights):
    for h in heights:
        with jasp('./dft/transport/g-mono/3x3/pore=1/molec=' + molec + '/linear-const-const/d={0:0.2f}'.format(h)) as calc:
	    calc.calculate()
	    atoms = calc.get_atoms()
	    dist.append(closest_atom_distance(atoms))
	    energy = atoms.get_potential_energy()
	    TE.append(energy)


dists = [[] for i in range(3)]
TEs = [[] for i in range(3)]
molecs = ['H2', 'N2', 'CO2']
heights = [10., 9., 8., 7., 6., 5., 4., 3., 2.5, 2., 1.5, 1., 0.5, 0.]
for i, (molec, dist, TE) in enumerate(zip(molecs, dists, TEs)):
    calculate(molec, dist, TE, heights)
    TE = np.array(TE)
    TE -= min(TE)
    TEs[i] = TE


for dist, TE in zip(dists, TEs):
    plt.plot(dist, TE)
plt.xlabel('Closest atom distance from graphene plane ($\AA$)')
plt.ylabel('$\Delta$ Energy (eV)')
plt.xlim([0,8])
plt.ylim([-0.5,2])
plt.legend(molecs)

path = 'results/convergence-vaccuum-pore=1.png'
caption = "Vaccuum distance convergence. Height represents distance between the molecule\'s closest atom and the graphene plane."
name = "vaccuum-molecule-distance"
dtb.print_image(path, plt, name, caption)
#+END_SRC

#+RESULTS:
:RESULTS:
#+CAPTION: Vaccuum distance convergence. Height represents distance between the molecule's closest atom and the graphene plane.
#+NAME: fig:vaccuum-molecule-distance
[[./img/results/convergence-vaccuum-pore=1.png]]
:END:

cite:sun-2014-mechan-molec reports between 5-6 Å is the distance of non-interaction for these molecules. They used classical MD with LJ potentials.

It appears that when the leading atom is 4 Å away from the graphene plane, there is no interaction. Since most molecules that we'll be testing are about 2-4 Å in length, it seems reasonable to make the z-direction vaccuum space of the calculations to be 9 Å on either side of the graphene plane. 

This probably the lowest case, as all atoms are constrained and the pore is not functionalized. The carbon atoms in graphene around a pore are not directly inline with the graphene plane.

** DONE Height of carbon atoms around an unfunctionalized graphene pore
   CLOSED: [2016-06-09 Thu 11:16]
Show that the carbon atoms around an unfunctionalized graphene pore do not change in height from the rest of the graphene plane.

*** DONE Monolayer graphene 5x5 pore=10
    CLOSED: [2016-06-09 Thu 11:17]
Show that at a pore, carbon atoms are not directly in line with the bulk graphene plane.

#+BEGIN_SRC python :results drawer
import numpy as np
import matplotlib.pyplot as plt

from ase import Atoms, Atom
from ase.io import write as ase_write
from jasp import *

import devon_toolbox as dtb

name = "dft/material/g-mono/5x5/pore=10/final"
with jasp(name) as calc:
    atoms = calc.get_atoms()


dtb.print_image("results/carbon-5x5-around-pore-vertical", atoms)
atoms2 = atoms.copy()
atoms2.rotate('x', np.pi/2)
dtb.print_image("results/carbon-5x5-around-pore-side", atoms2)

heights = []
dists = []
defect = [5.681, 0., 4.]
center = atoms.cell[2][2] / 2.
for i, a in enumerate(atoms):
    dist_defect = np.linalg.norm(a.position - defect)
    dists.append(dist_defect)
    heights.append(a.position[2] - center)

plt.plot(dists, heights)
file_path = './img/results/carbon-5x5-around-pore-plot.png'
plt.xlabel('Distance from pore ($\AA$)')
plt.ylabel('Distance from plane center ($\AA$)')
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
[[./img/results/carbon-5x5-around-pore-vertical.png]]
[[./img/results/carbon-5x5-around-pore-side.png]]
[[./img/results/carbon-5x5-around-pore-plot.png]]
:END:

*** DONE Monolayer graphene 3x3 pore=1
    CLOSED: [2016-06-09 Thu 11:17]
Show that at a pore, carbon atoms are not directly in line with the bulk graphene plane.

#+BEGIN_SRC python :results drawer
import numpy as np
import matplotlib.pyplot as plt

from ase import Atoms, Atom
from ase.io import write as ase_write
from jasp import *

import devon_toolbox as dtb

name = "dft/material/g-mono/3x3/pore=1/final"
with jasp(name) as calc:
    atoms = calc.get_atoms()


dtb.print_image("results/carbon-3x3-around-pore-vertical", atoms)
atoms2 = atoms.copy()
atoms2.rotate('x', np.pi/2)
dtb.print_image("results/carbon-3x3-around-pore-side", atoms2)

heights = []
dists = []
defect = [5.681, 0., 4.]
center = atoms.cell[2][2] / 2.
for i, a in enumerate(atoms):
    dist_defect = np.linalg.norm(a.position - defect)
    dists.append(dist_defect)
    heights.append(a.position[2] - center)

plt.plot(dists, heights)
file_path = './img/results/carbon-3x3-around-pore-plot.png'
plt.xlabel('Distance from pore ($\AA$)')
plt.ylabel('Distance from plane center ($\AA$)')
plt.savefig(file_path)
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
[[./img/results/carbon-3x3-around-pore-vertical.png]]
[[./img/results/carbon-3x3-around-pore-side.png]]
matplotlib.pyplot
:END:

** TODO Height of carbon atoms around a functionalized graphene pore
** Monolayer graphene pore distance convergence
Show that as the graphene layers get larger, the negative effect of the pore on the total energy decreases.

#+BEGIN_SRC python :results drawer
import matplotlib.pyplot as plt
import numpy as np

from ase import Atom, Atoms
from jasp import *

import devon_toolbox as dtb


sizes = [2, 3, 4, 5, 6]
kpts =  [5, 5, 5, 1, 1]

energies = []
dists = []
times = []
images = []
for i, k in zip(sizes, kpts):
    name = 'dft/material/g-mono/{0:0.0f}x{0:0.0f}/pore=1/convergence/size/kpts={1:0.0f}'.format(i, k)

    with jasp(name) as calc:
        atoms = calc.get_atoms()
        energy = atoms.get_potential_energy()/len(atoms)
        time = float(get_elapsed_time(calc)) / 60 # minutes

    energies.append(energy)
    dists.append(np.linalg.norm(atoms.cell[0]))
    times.append(time)
    images.append(atoms)

# Pristine comparison
with jasp("dft/material/g-mono/final") as calc:
    atoms = calc.get_atoms()
    energy = atoms.get_potential_energy()/len(atoms)
px = np.linspace(dists[0], dists[-1])
py = [energy for i in px]


path = 'results/monolayer-energy_vs_pore_distance'

ax1 = plt.gca()
ax1.plot(px, py, 'g--', label="Pristine graphene")
ax1.plot(dists, energies, 'go', label="Pore=1")
spline = dtb.spline(dists, energies)
ax1.plot(spline[0], spline[1], 'g-')

ax2 = plt.gca().twinx()
ax2.plot(dists, times, 'ro', label="Pore=1")
spline = dtb.spline(dists, times)
ax2.plot(spline[0], spline[1], 'r-')

ax1.set_xlabel("Distance between pore centers ($\AA$)")
ax1.set_ylabel("Energy per atom (eV/f.u.)", color='g')
ax2.set_ylabel("Calculation time (min)", color='r')
plt.xlim(dists[0],dists[-1])
ax1.legend(loc='upper left')
ax2.legend(loc='upper right')

caption = "The effect of distance between pores on energy and calculation time."
name = "g-mono-energy_vs_pore_distance"
dtb.print_image(path + '.png', plt, name, caption)

for i, [s, d] in enumerate(zip(sizes, dists)):
    print("Distance = {0}. Structure = {1}x{1}".format(d, s))
    if s in [2, 3]:
        r = 3
    else:
        r = 2
    dtb.print_image(path + '-pore=1-size={}'.format(s), images[i].repeat([r,r,1]))


# Pore=10 comparison
p10dists = [dists[sizes.index(4)], dists[sizes.index(5)], dists[sizes.index(6)]]
p10energies = [-8.128, -8.604, -8.850]
p10times = [96, 966, 2929]
p10sizes = [4, 5, 6]
p10images = []

for i, [s, d] in enumerate(zip(p10sizes, p10dists)):
    with jasp('dft/material/g-mono/{0}x{0}/pore=10/final'.format(s)) as calc:
        p10images.append(calc.get_atoms())
    print("Distance = {0}. Structure = {1}x{1}".format(d, s))
    dtb.print_image(path + '-pore=10-size={}'.format(s), p10images[i].repeat([2,2,1]))

ax1.plot(p10dists, p10energies, 'gd-', label="Pore=10")
ax2.plot(p10dists, p10times, 'rd-', label="Pore=10")
#spline = dtb.spline(p10dists, p10energies)
#ax1.plot(spline[0], spline[1], 'g-')
#spline = dtb.spline(p10dists, p10times)
#ax2.plot(spline[0], spline[1], 'r-')
ax1.legend(loc='upper left')
ax2.legend(loc='upper right')
dtb.print_image(path + '-pore=10.png', plt, name, caption)
#+END_SRC

#+RESULTS:
:RESULTS:
#+CAPTION: The effect of distance between pores on energy and calculation time.
#+NAME: fig:g-mono-energy_vs_pore_distance
[[./img/results/monolayer-energy_vs_pore_distance.png]]
Distance = 4.92. Structure = 2x2
[[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=2.png]]
Distance = 7.38. Structure = 3x3
[[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=3.png]]
Distance = 9.84. Structure = 4x4
[[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=4.png]]
Distance = 12.3. Structure = 5x5
[[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=5.png]]
Distance = 14.76. Structure = 6x6
[[./img/results/monolayer-energy_vs_pore_distance-pore=1-size=6.png]]
Distance = 9.84. Structure = 4x4
[[./img/results/monolayer-energy_vs_pore_distance-pore=10-size=4.png]]
Distance = 12.3. Structure = 5x5
[[./img/results/monolayer-energy_vs_pore_distance-pore=10-size=5.png]]
Distance = 14.76. Structure = 6x6
[[./img/results/monolayer-energy_vs_pore_distance-pore=10-size=6.png]]
#+CAPTION: The effect of distance between pores on energy and calculation time.
#+NAME: fig:g-mono-energy_vs_pore_distance
[[./img/results/monolayer-energy_vs_pore_distance-pore=10.png]]
:END:

Approaches the pristine limit but calculation time goes way up. This is also one of the best case scenarios - a single missing carbon atom. As the ammount of carbon atoms removed increases, the energy goes up.

** TODO Charge density view of monolayer graphene pore=10

Show what the charge density looks like around a pore.

#+BEGIN_SRC python
from ase.data import vdw_radii
from ase.data.colors import cpk_colors
from enthought.mayavi import mlab
from jasp import *

import devon_toolbox as dtb


with jasp('dft/material/g-mono/5x5/pore=10/final') as calc:
    atoms = calc.get_atoms()
    x, y, z, cd = calc.get_charge_density()

mlab.contour3d(x,y,z,cd)

dtb.bp()
mlab.figure(bgcolor=(1, 1, 1))

# plot the atoms as spheres
for atom in atoms:
    mlab.points3d(atom.x,
                  atom.y,
                  atom.z,
                  scale_factor=vdw_radii[atom.number]/5,
                  resolution=20,
                  # a tuple is required for the color
                  color=tuple(cpk_colors[atom.number]),
                  scale_mode='none')

# draw the unit cell - there are 8 corners, and 12 connections
a1, a2, a3 = atoms.get_cell()
origin = [0, 0, 0]
cell_matrix = [[origin,  a1],
               [origin,  a2],
               [origin,  a3],
               [a1,      a1 + a2],
               [a1,      a1 + a3],
               [a2,      a2 + a1],
               [a2,      a2 + a3],
               [a3,      a1 + a3],
               [a3,      a2 + a3],
               [a1 + a2, a1 + a2 + a3],
               [a2 + a3, a1 + a2 + a3],
               [a1 + a3, a1 + a3 + a2]]

for p1, p2 in cell_matrix:
    mlab.plot3d([p1[0], p2[0]], # x-positions
                [p1[1], p2[1]], # y-positions
                [p1[2], p2[2]], # z-positions
                tube_radius=0.02)


# Now plot the charge density
mlab.contour3d(x, y, z, cd, transparent=True)

# this view was empirically found by iteration
mlab.view(azimuth=-90, elevation=90, distance='auto')

file_path = 'tmp/test_charge.png'
mlab.savefig(file_path)
#mlab.show()
print('[[' + file_path + ']]')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:
